if ( TRACE ) { TRACE( JSON.parse( '["BrokenPlatform#init","BrokenPlatform#Start","BrokenPlatform#OnCollisionEnter2D","CameraFollower#FixedUpdate","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","EpicToonFX.ETFXButtonScript#Start","EpicToonFX.ETFXButtonScript#Update","EpicToonFX.ETFXButtonScript#getProjectileNames","EpicToonFX.ETFXButtonScript#overButton","EpicToonFX.ETFXFireProjectile#init","EpicToonFX.ETFXFireProjectile#Start","EpicToonFX.ETFXFireProjectile#Update","EpicToonFX.ETFXFireProjectile#nextEffect","EpicToonFX.ETFXFireProjectile#previousEffect","EpicToonFX.ETFXFireProjectile#AdjustSpeed","EpicToonFX.ETFXLightFade#init","EpicToonFX.ETFXLightFade#Start","EpicToonFX.ETFXLightFade#Update","EpicToonFX.ETFXLoopScript#init","EpicToonFX.ETFXLoopScript#Start","EpicToonFX.ETFXLoopScript#PlayEffect","EpicToonFX.ETFXLoopScript#EffectLoop","EpicToonFX.ETFXMouseOrbit#ClampAngle","EpicToonFX.ETFXMouseOrbit#init","EpicToonFX.ETFXMouseOrbit#Start","EpicToonFX.ETFXMouseOrbit#LateUpdate","EpicToonFX.ETFXPitchRandomizer#init","EpicToonFX.ETFXPitchRandomizer#Start","EpicToonFX.ETFXRotation#init","EpicToonFX.ETFXRotation#Start","EpicToonFX.ETFXRotation#Update","EpicToonFX.ETFXTarget#Start","EpicToonFX.ETFXTarget#SpawnTarget","EpicToonFX.ETFXTarget#OnTriggerEnter","EpicToonFX.ETFXTarget#Respawn","ETFXProjectileScript#init","ETFXProjectileScript#Start","ETFXProjectileScript#FixedUpdate","ETFXSceneManager#init","ETFXSceneManager#LoadScene2DDemo","ETFXSceneManager#LoadSceneCards","ETFXSceneManager#LoadSceneCombat","ETFXSceneManager#LoadSceneDecals","ETFXSceneManager#LoadSceneDecals2","ETFXSceneManager#LoadSceneEmojis","ETFXSceneManager#LoadSceneEmojis2","ETFXSceneManager#LoadSceneExplosions","ETFXSceneManager#LoadSceneExplosions2","ETFXSceneManager#LoadSceneFire","ETFXSceneManager#LoadSceneFire2","ETFXSceneManager#LoadSceneFire3","ETFXSceneManager#LoadSceneFireworks","ETFXSceneManager#LoadSceneFlares","ETFXSceneManager#LoadSceneMagic","ETFXSceneManager#LoadSceneMagic2","ETFXSceneManager#LoadSceneMagic3","ETFXSceneManager#LoadSceneMainDemo","ETFXSceneManager#LoadSceneMissiles","ETFXSceneManager#LoadScenePortals","ETFXSceneManager#LoadScenePortals2","ETFXSceneManager#LoadScenePowerups","ETFXSceneManager#LoadScenePowerups2","ETFXSceneManager#LoadSceneSparkles","ETFXSceneManager#LoadSceneSwordCombat","ETFXSceneManager#LoadSceneSwordCombat2","ETFXSceneManager#LoadSceneMoney","ETFXSceneManager#LoadSceneHealing","ETFXSceneManager#LoadSceneWind","ETFXSceneManager#Update","ParticleEffectsLibrary#init","ParticleEffectsLibrary#Awake","ParticleEffectsLibrary#Start","ParticleEffectsLibrary#GetCurrentPENameString","ParticleEffectsLibrary#PreviousParticleEffect","ParticleEffectsLibrary#NextParticleEffect","ParticleEffectsLibrary#SpawnParticleEffect","PEButtonScript#init","PEButtonScript#Start","PEButtonScript#OnPointerEnter","PEButtonScript#OnPointerExit","PEButtonScript#OnButtonClicked","Projects.Scripts.GamePlay.Building.CheckPoint#init","Projects.Scripts.GamePlay.Building.CheckPoint#OnTriggerEnter2D","Projects.Scripts.GamePlay.Building.CheckPoint#ShowEffect","Projects.Scripts.GamePlay.Building.StartLevel#Instance#get","Projects.Scripts.GamePlay.Building.StartLevel#Awake","Projects.Scripts.GamePlay.Building.StartLevel#Init","Projects.Scripts.GamePlay.CharacterController.BallAnimation#Init","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayIdle","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlaySmile","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayHurt","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayDie","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayRevive","Projects.Scripts.GamePlay.CharacterController.BallAnimation#Die","Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayMix","Projects.Scripts.GamePlay.CharacterController.BallAnimation#SetSkin","Projects.Scripts.GamePlay.CharacterController.BallAttack#init","Projects.Scripts.GamePlay.CharacterController.BallAttack#Init","Projects.Scripts.GamePlay.CharacterController.BallAttack#OnAttackEnemy","Projects.Scripts.GamePlay.CharacterController.BallAttack#AfterDamage","Projects.Scripts.GamePlay.CharacterController.BallController#Instance#get","Projects.Scripts.GamePlay.CharacterController.BallController#init","Projects.Scripts.GamePlay.CharacterController.BallController#Awake","Projects.Scripts.GamePlay.CharacterController.BallController#Start","Projects.Scripts.GamePlay.CharacterController.BallController#Update","Projects.Scripts.GamePlay.CharacterController.BallController#CollectingCoin","Projects.Scripts.GamePlay.CharacterController.BallController#Collected","Projects.Scripts.GamePlay.CharacterController.BallController#ActiveMagnet","Projects.Scripts.GamePlay.CharacterController.BallController#Damage","Projects.Scripts.GamePlay.CharacterController.BallController#IsDie","Projects.Scripts.GamePlay.CharacterController.BallController#Revive","Projects.Scripts.GamePlay.CharacterController.BallController#SetForce","Projects.Scripts.GamePlay.CharacterController.BallController#SetForceInstant","Projects.Scripts.GamePlay.CharacterController.BallController#ActiveHeartEffect","Projects.Scripts.GamePlay.CharacterController.BallController#Win","Projects.Scripts.GamePlay.CharacterController.BallController#MoveLeft","Projects.Scripts.GamePlay.CharacterController.BallController#MoveRight","Projects.Scripts.GamePlay.CharacterController.BallController#Jump","Projects.Scripts.GamePlay.CharacterController.BallController#CancelAllMove","Projects.Scripts.GamePlay.CharacterController.BallController#SetCanDamage","Projects.Scripts.GamePlay.CharacterController.BallController#TrySkin","Projects.Scripts.GamePlay.CharacterController.BallHealth#init","Projects.Scripts.GamePlay.CharacterController.BallHealth#Init","Projects.Scripts.GamePlay.CharacterController.BallHealth#Start","Projects.Scripts.GamePlay.CharacterController.BallHealth#Damage","Projects.Scripts.GamePlay.CharacterController.BallHealth#Die","Projects.Scripts.GamePlay.CharacterController.BallHealth#DieComplete","Projects.Scripts.GamePlay.CharacterController.BallHealth#Revive","Projects.Scripts.GamePlay.CharacterController.BallHealth#SetInviolable","Projects.Scripts.GamePlay.CharacterController.BallMagnetic#Init","Projects.Scripts.GamePlay.CharacterController.BallMagnetic#ActiveMagnet","Projects.Scripts.GamePlay.CharacterController.BallMagnetic#CollectingCoin","Projects.Scripts.GamePlay.CharacterController.BallMagnetic#Collected","Projects.Scripts.GamePlay.CharacterController.BallMovement#init","Projects.Scripts.GamePlay.CharacterController.BallMovement#Init","Projects.Scripts.GamePlay.CharacterController.BallMovement#Update","Projects.Scripts.GamePlay.CharacterController.BallMovement#CheckIsGrounded","Projects.Scripts.GamePlay.CharacterController.BallMovement#OnCollisionEnter2D","Projects.Scripts.GamePlay.CharacterController.BallMovement#OnCollisionExit2D","Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchMoveLeft","Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchMoveRight","Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchJump","Projects.Scripts.GamePlay.CharacterController.BallMovement#SetForce","Projects.Scripts.GamePlay.CharacterController.BallMovement#SetForceInstant","Projects.Scripts.GamePlay.CharacterController.BallMovement#RollEffect","Projects.Scripts.GamePlay.CharacterController.BallMovement#RunEffect","Projects.Scripts.GamePlay.CharacterController.FollowCharacter#init","Projects.Scripts.GamePlay.CharacterController.FollowCharacter#Update","Projects.Scripts.GamePlay.Damage.DamageToBall#TriggerEnter","Projects.Scripts.GamePlay.Damage.DamageToBall#OnCollide","Projects.Scripts.GamePlay.Enemy.EnemyController#init","Projects.Scripts.GamePlay.Enemy.EnemyController#Start","Projects.Scripts.GamePlay.Enemy.EnemyController#CheckVisible","Projects.Scripts.GamePlay.Enemy.EnemyController#Idle","Projects.Scripts.GamePlay.Enemy.EnemyController#Flip","Projects.Scripts.GamePlay.Enemy.EnemyController#OnCollisionEnter2D","Projects.Scripts.GamePlay.Enemy.EnemyController#ReachPlayer","Projects.Scripts.GamePlay.Enemy.EnemyController#Die","Projects.Scripts.GamePlay.Enemy.EnemyController#SpawnStar","Projects.Scripts.GamePlay.Enemy.EnemyController#OnDrawGizmos","Projects.Scripts.GamePlay.Item.Cage#init","Projects.Scripts.GamePlay.Item.Cage#Start","Projects.Scripts.GamePlay.Item.Cage#OnValueChange","Projects.Scripts.GamePlay.Item.Cage#GetAllSkinName","Projects.Scripts.GamePlay.Item.Cage#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.Coin#init","Projects.Scripts.GamePlay.Item.Coin#Start","Projects.Scripts.GamePlay.Item.Coin#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.Coin#Update","Projects.Scripts.GamePlay.Item.Coin#TriggerEnter","Projects.Scripts.GamePlay.Item.Coin#OnCollect","Projects.Scripts.GamePlay.Item.HeartItem#Start","Projects.Scripts.GamePlay.Item.HeartItem#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.MagnetItem#Start","Projects.Scripts.GamePlay.Item.MagnetItem#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.MagnetItem#TriggerEnter","Projects.Scripts.GamePlay.Item.Star#Start","Projects.Scripts.GamePlay.Item.Star#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.Star#TriggerEnter","Projects.Scripts.GamePlay.Item.Star#OnCollect","Projects.Scripts.GamePlay.Item.Star#OnCollide","Projects.Scripts.GamePlay.Item.TrySkinItem#OnValueChange","Projects.Scripts.GamePlay.Item.TrySkinItem#Start","Projects.Scripts.GamePlay.Item.TrySkinItem#OnTriggerEnter2D","Projects.Scripts.GamePlay.Item.TrySkinItem#TrySkin","Projects.Scripts.GamePlay.Item.TrySkinItem#Active","Projects.Scripts.GamePlay.ObjectCollision#OnCollisionEnter2D","Projects.Scripts.GamePlay.ObjectCollision#OnCollisionExit2D","Projects.Scripts.GamePlay.ObjectCollision#OnCollisionStay2D","Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerEnter2D","Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerExit2D","Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerStay2D","Projects.Scripts.GamePlay.ParticleCallback#OnParticleSystemStopped","Projects.Scripts.GamePlay.Platform.Gate#init","Projects.Scripts.GamePlay.Platform.Gate#OnTriggerEnter2D","Projects.Scripts.GamePlay.Sound.SoundInGameManager#Instance#get","Projects.Scripts.GamePlay.Sound.SoundInGameManager#Awake","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallJumpSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallLandingSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallDamagedSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallAttackSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallDieSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectCoin","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectStar","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectHeart","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectMagnet","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallTrySkin","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallWinSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallExplode","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallInCheckPoint","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallRevive","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBgmSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBossFightSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayLoseSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayWinSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlaySpringSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayCageBreakSound","Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayRescueSound","Projects.Scripts.UIController.ButtonEffect#Awake","Projects.Scripts.UIController.ButtonEffect#OnPointerDown","Projects.Scripts.UIController.ButtonEffect#OnPointerEnter","Projects.Scripts.UIController.ButtonEffect#OnPointerExit","Projects.Scripts.UIController.ButtonEffect#OnPointerUp","Projects.Scripts.UIController.ButtonEffect#OnValidate","Projects.Scripts.UIController.CoinValueText#SetValue","Projects.Scripts.UIController.CoinValueText#Complete","Projects.Scripts.UIController.CustomButton#init","Projects.Scripts.UIController.CustomButton#OnPointerDown","Projects.Scripts.UIController.CustomButton#OnPointerEnter","Projects.Scripts.UIController.CustomButton#OnPointerExit","Projects.Scripts.UIController.GamePlayController#Instance#get","Projects.Scripts.UIController.GamePlayController#init","Projects.Scripts.UIController.GamePlayController#Awake","Projects.Scripts.UIController.GamePlayController#Start","Projects.Scripts.UIController.GamePlayController#StartGame","Projects.Scripts.UIController.GamePlayController#CollectCoin","Projects.Scripts.UIController.GamePlayController#SetCollectingCurrency","Projects.Scripts.UIController.GamePlayController#SetCollectedCurrency","Projects.Scripts.UIController.GamePlayController#CollectStar","Projects.Scripts.UIController.GamePlayController#CollectHp","Projects.Scripts.UIController.GamePlayController#CollectMagnet","Projects.Scripts.UIController.GamePlayController#IsMagnetActive","Projects.Scripts.UIController.GamePlayController#OnDestroy","Projects.Scripts.UIController.GamePlayController#CollectLife","Projects.Scripts.UIController.GamePlayController#SetSkin","Projects.Scripts.UIController.GamePlayController#SetCheckPoint","Projects.Scripts.UIController.GamePlayController#BallDamaged","Projects.Scripts.UIController.GamePlayController#BallDie","Projects.Scripts.UIController.GamePlayController#PauseWhenBallDie","Projects.Scripts.UIController.GamePlayController#Win","Projects.Scripts.UIController.GamePlayController#ShowContinue","Projects.Scripts.UIController.GamePlayController#GoToStore","Projects.Scripts.UIController.GamePlayController#TouchMoveLeft","Projects.Scripts.UIController.GamePlayController#TouchMoveRight","Projects.Scripts.UIController.GamePlayController#TouchJump","Projects.Scripts.UIController.GamePlayController#ExitRoom","Projects.Scripts.UIController.GamePlayController#ActiveWarning","Projects.Scripts.UIController.GamePlayController#SetBossHealth","Projects.Scripts.UIController.GamePlayController#SetBossSkin","Projects.Scripts.UIController.ToggleHelper#Awake","Projects.Scripts.UIController.ToggleHelper#OnValueChange","Projects.Scripts.UIController.ToggleHelper#OnDrawGizmos","SharpJson.JsonDecoder#DecodeText","SharpJson.JsonDecoder#ctor","SharpJson.JsonDecoder#Decode","SharpJson.JsonDecoder#ParseObject","SharpJson.JsonDecoder#ParseArray","SharpJson.JsonDecoder#ParseValue","SharpJson.JsonDecoder#TriggerError","SharpJson.JsonDecoder#EvalLexer","SharpJson.Lexer#NextToken","SharpJson.Lexer#hasError#get","SharpJson.Lexer#init","SharpJson.Lexer#ctor","SharpJson.Lexer#Reset","SharpJson.Lexer#ParseString","SharpJson.Lexer#GetNumberString","SharpJson.Lexer#ParseFloatNumber","SharpJson.Lexer#ParseDoubleNumber","SharpJson.Lexer#GetLastIndexOfNumber","SharpJson.Lexer#SkipWhiteSpaces","SharpJson.Lexer#LookAhead","SharpJson.Lexer#NextToken","Spine.Animation#BinarySearch$1","Spine.Animation#BinarySearch","Spine.Animation#LinearSearch","Spine.Animation#Timelines#get","Spine.Animation#Timelines#set","Spine.Animation#Duration#get","Spine.Animation#Duration#set","Spine.Animation#Name#get","Spine.Animation#ctor","Spine.Animation#HasTimeline","Spine.Animation#Apply","Spine.Animation#toString","Spine.AnimationState#init","Spine.AnimationState#ApplyRotateTimeline","Spine.AnimationState#TimeScale#get","Spine.AnimationState#TimeScale#set","Spine.AnimationState#Data#get","Spine.AnimationState#Data#set","Spine.AnimationState#Tracks#get","Spine.AnimationState#init","Spine.AnimationState#ctor","Spine.AnimationState#OnStart","Spine.AnimationState#OnInterrupt","Spine.AnimationState#OnEnd","Spine.AnimationState#OnDispose","Spine.AnimationState#OnComplete","Spine.AnimationState#OnEvent","Spine.AnimationState#AssignEventSubscribersFrom","Spine.AnimationState#AddEventSubscribersFrom","Spine.AnimationState#Update","Spine.AnimationState#UpdateMixingFrom","Spine.AnimationState#Apply","Spine.AnimationState#ApplyEventTimelinesOnly","Spine.AnimationState#ApplyMixingFrom","Spine.AnimationState#ApplyMixingFromEventTimelinesOnly","Spine.AnimationState#ApplyAttachmentTimeline","Spine.AnimationState#SetAttachment","Spine.AnimationState#QueueEvents","Spine.AnimationState#ClearTracks","Spine.AnimationState#ClearTrack","Spine.AnimationState#SetCurrent","Spine.AnimationState#SetAnimation$1","Spine.AnimationState#SetAnimation","Spine.AnimationState#AddAnimation$1","Spine.AnimationState#AddAnimation","Spine.AnimationState#SetEmptyAnimation","Spine.AnimationState#AddEmptyAnimation","Spine.AnimationState#SetEmptyAnimations","Spine.AnimationState#ExpandToIndex","Spine.AnimationState#NewTrackEntry","Spine.AnimationState#DisposeNext","Spine.AnimationState#AnimationsChanged","Spine.AnimationState#ComputeHold","Spine.AnimationState#GetCurrent","Spine.AnimationState#ClearListenerNotifications","Spine.AnimationState#toString","Spine.AnimationStateData#SkeletonData#get","Spine.AnimationStateData#DefaultMix#get","Spine.AnimationStateData#DefaultMix#set","Spine.AnimationStateData#init","Spine.AnimationStateData#ctor","Spine.AnimationStateData#SetMix$1","Spine.AnimationStateData#SetMix","Spine.AnimationStateData#GetMix","Spine.AnimationStateData.AnimationPair#getDefaultValue","Spine.AnimationStateData.AnimationPair#$ctor1","Spine.AnimationStateData.AnimationPair#ctor","Spine.AnimationStateData.AnimationPair#toString","Spine.AnimationStateData.AnimationPair#getHashCode","Spine.AnimationStateData.AnimationPair#equals","Spine.AnimationStateData.AnimationPair#$clone","Spine.AtlasRegion#Clone","Spine.AtlasPage#Clone","Spine.Attachment#ctor","Spine.Attachment#toString","Spine.BoneData#Index#get","Spine.BoneData#Name#get","Spine.BoneData#Parent#get","Spine.BoneData#Length#get","Spine.BoneData#Length#set","Spine.BoneData#X#get","Spine.BoneData#X#set","Spine.BoneData#Y#get","Spine.BoneData#Y#set","Spine.BoneData#Rotation#get","Spine.BoneData#Rotation#set","Spine.BoneData#ScaleX#get","Spine.BoneData#ScaleX#set","Spine.BoneData#ScaleY#get","Spine.BoneData#ScaleY#set","Spine.BoneData#ShearX#get","Spine.BoneData#ShearX#set","Spine.BoneData#ShearY#get","Spine.BoneData#ShearY#set","Spine.BoneData#TransformMode#get","Spine.BoneData#TransformMode#set","Spine.BoneData#SkinRequired#get","Spine.BoneData#SkinRequired#set","Spine.BoneData#init","Spine.BoneData#ctor","Spine.BoneData#toString","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.Collections.CollectionExtensions#ToOrderedDictionary","Spine.Collections.CollectionExtensions#ToOrderedDictionary$1","Spine.Collections.OrderedDictionary$2#init","Spine.Collections.OrderedDictionary$2#Comparer#get","Spine.Collections.OrderedDictionary$2#Keys#get","Spine.Collections.OrderedDictionary$2#Values#get","Spine.Collections.OrderedDictionary$2#Count#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Keys#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Values#get","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2#ctor","Spine.Collections.OrderedDictionary$2#$ctor2","Spine.Collections.OrderedDictionary$2#$ctor1","Spine.Collections.OrderedDictionary$2#$ctor3","Spine.Collections.OrderedDictionary$2#getItem$1","Spine.Collections.OrderedDictionary$2#setItem$1","Spine.Collections.OrderedDictionary$2#getItem","Spine.Collections.OrderedDictionary$2#setItem","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$getItem","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$setItem","Spine.Collections.OrderedDictionary$2#add","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add","Spine.Collections.OrderedDictionary$2#Insert","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert","Spine.Collections.OrderedDictionary$2#containsKey","Spine.Collections.OrderedDictionary$2#GetKey","Spine.Collections.OrderedDictionary$2#IndexOf","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf","Spine.Collections.OrderedDictionary$2#remove","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove","Spine.Collections.OrderedDictionary$2#removeAt","Spine.Collections.OrderedDictionary$2#tryGetValue","Spine.Collections.OrderedDictionary$2#clear","Spine.Collections.OrderedDictionary$2#GetEnumerator","Spine.Collections.OrderedDictionary$2#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains","Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo","Spine.Collections.OrderedDictionary$2.KeyCollection#Count#get","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2.KeyCollection#ctor","Spine.Collections.OrderedDictionary$2.KeyCollection#copyTo","Spine.Collections.OrderedDictionary$2.KeyCollection#GetEnumerator","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$contains","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$add","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$clear","Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$remove","Spine.Collections.OrderedDictionary$2.ValueCollection#Count#get","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get","Spine.Collections.OrderedDictionary$2.ValueCollection#ctor","Spine.Collections.OrderedDictionary$2.ValueCollection#copyTo","Spine.Collections.OrderedDictionary$2.ValueCollection#GetEnumerator","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$IEnumerable$GetEnumerator","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$contains","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$add","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$clear","Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$remove","Spine.Collections.OrderedDictionaryDebugView$2#Items#get","Spine.Collections.OrderedDictionaryDebugView$2#ctor","Spine.ConstraintData#Name#get","Spine.ConstraintData#Order#get","Spine.ConstraintData#Order#set","Spine.ConstraintData#SkinRequired#get","Spine.ConstraintData#SkinRequired#set","Spine.ConstraintData#ctor","Spine.ConstraintData#toString","Spine.Event#Data#get","Spine.Event#Time#get","Spine.Event#Int#get","Spine.Event#Int#set","Spine.Event#Float#get","Spine.Event#Float#set","Spine.Event#String#get","Spine.Event#String#set","Spine.Event#Volume#get","Spine.Event#Volume#set","Spine.Event#Balance#get","Spine.Event#Balance#set","Spine.Event#ctor","Spine.Event#toString","Spine.EventData#Name#get","Spine.EventData#ctor","Spine.EventData#toString","Spine.EventQueue#init","Spine.EventQueue#ctor","Spine.EventQueue#Start","Spine.EventQueue#Interrupt","Spine.EventQueue#End","Spine.EventQueue#Dispose","Spine.EventQueue#Complete","Spine.EventQueue#Event","Spine.EventQueue#Drain","Spine.EventQueue#Clear","Spine.EventQueue.EventQueueEntry#getDefaultValue","Spine.EventQueue.EventQueueEntry#$ctor1","Spine.EventQueue.EventQueueEntry#ctor","Spine.EventQueue.EventQueueEntry#getHashCode","Spine.EventQueue.EventQueueEntry#equals","Spine.EventQueue.EventQueueEntry#$clone","Spine.ExposedList$1#init","Spine.ExposedList$1#CheckMatch","Spine.ExposedList$1#Capacity#get","Spine.ExposedList$1#Capacity#set","Spine.ExposedList$1#ctor","Spine.ExposedList$1#$ctor2","Spine.ExposedList$1#$ctor3","Spine.ExposedList$1#$ctor1","Spine.ExposedList$1#Add","Spine.ExposedList$1#GrowIfNeeded","Spine.ExposedList$1#Resize","Spine.ExposedList$1#EnsureCapacity","Spine.ExposedList$1#CheckRange","Spine.ExposedList$1#AddCollection","Spine.ExposedList$1#AddEnumerable","Spine.ExposedList$1#AddRange","Spine.ExposedList$1#AddRange$1","Spine.ExposedList$1#BinarySearch","Spine.ExposedList$1#BinarySearch$1","Spine.ExposedList$1#BinarySearch$2","Spine.ExposedList$1#Clear","Spine.ExposedList$1#Contains","Spine.ExposedList$1#ConvertAll","Spine.ExposedList$1#CopyTo","Spine.ExposedList$1#CopyTo$1","Spine.ExposedList$1#CopyTo$2","Spine.ExposedList$1#Exists","Spine.ExposedList$1#Find","Spine.ExposedList$1#FindAll","Spine.ExposedList$1#FindAllList","Spine.ExposedList$1#FindIndex$2","Spine.ExposedList$1#FindIndex$1","Spine.ExposedList$1#FindIndex","Spine.ExposedList$1#GetIndex","Spine.ExposedList$1#FindLast","Spine.ExposedList$1#FindLastIndex$2","Spine.ExposedList$1#FindLastIndex$1","Spine.ExposedList$1#FindLastIndex","Spine.ExposedList$1#GetLastIndex","Spine.ExposedList$1#ForEach","Spine.ExposedList$1#GetEnumerator","Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator","Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator","Spine.ExposedList$1#GetRange","Spine.ExposedList$1#IndexOf","Spine.ExposedList$1#IndexOf$1","Spine.ExposedList$1#IndexOf$2","Spine.ExposedList$1#Shift","Spine.ExposedList$1#CheckIndex","Spine.ExposedList$1#Insert","Spine.ExposedList$1#CheckCollection","Spine.ExposedList$1#InsertRange","Spine.ExposedList$1#InsertCollection","Spine.ExposedList$1#InsertEnumeration","Spine.ExposedList$1#LastIndexOf","Spine.ExposedList$1#LastIndexOf$1","Spine.ExposedList$1#LastIndexOf$2","Spine.ExposedList$1#Remove","Spine.ExposedList$1#RemoveAll","Spine.ExposedList$1#RemoveAt","Spine.ExposedList$1#Pop","Spine.ExposedList$1#RemoveRange","Spine.ExposedList$1#Reverse","Spine.ExposedList$1#Reverse$1","Spine.ExposedList$1#Sort","Spine.ExposedList$1#Sort$1","Spine.ExposedList$1#Sort$2","Spine.ExposedList$1#Sort$3","Spine.ExposedList$1#ToArray","Spine.ExposedList$1#TrimExcess","Spine.ExposedList$1#TrueForAll","Spine.ExposedList$1.Enumerator#getDefaultValue","Spine.ExposedList$1.Enumerator#Current#get","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get","Spine.ExposedList$1.Enumerator#init","Spine.ExposedList$1.Enumerator#$ctor1","Spine.ExposedList$1.Enumerator#ctor","Spine.ExposedList$1.Enumerator#Dispose","Spine.ExposedList$1.Enumerator#VerifyState","Spine.ExposedList$1.Enumerator#moveNext","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset","Spine.ExposedList$1.Enumerator#getHashCode","Spine.ExposedList$1.Enumerator#equals","Spine.ExposedList$1.Enumerator#$clone","Spine.IInterpolation#init","Spine.IInterpolation#Apply","Spine.Json#Deserialize","Spine.MathUtils#init","Spine.MathUtils#Sin","Spine.MathUtils#Cos","Spine.MathUtils#SinDeg","Spine.MathUtils#CosDeg","Spine.MathUtils#Atan2","Spine.MathUtils#Clamp","Spine.MathUtils#RandomTriangle","Spine.MathUtils#RandomTriangle$1","Spine.Polygon#ctor","Spine.Pool$1#Count#get","Spine.Pool$1#ctor","Spine.Pool$1#Obtain","Spine.Pool$1#Free","Spine.Pool$1#Clear","Spine.Pool$1#Reset","Spine.Skeleton#SortReset","Spine.Skeleton#Data#get","Spine.Skeleton#Bones#get","Spine.Skeleton#UpdateCacheList#get","Spine.Skeleton#Slots#get","Spine.Skeleton#DrawOrder#get","Spine.Skeleton#IkConstraints#get","Spine.Skeleton#PathConstraints#get","Spine.Skeleton#TransformConstraints#get","Spine.Skeleton#Skin#get","Spine.Skeleton#Skin#set","Spine.Skeleton#R#get","Spine.Skeleton#R#set","Spine.Skeleton#G#get","Spine.Skeleton#G#set","Spine.Skeleton#B#get","Spine.Skeleton#B#set","Spine.Skeleton#A#get","Spine.Skeleton#A#set","Spine.Skeleton#Time#get","Spine.Skeleton#Time#set","Spine.Skeleton#X#get","Spine.Skeleton#X#set","Spine.Skeleton#Y#get","Spine.Skeleton#Y#set","Spine.Skeleton#ScaleX#get","Spine.Skeleton#ScaleX#set","Spine.Skeleton#ScaleY#get","Spine.Skeleton#ScaleY#set","Spine.Skeleton#FlipX#get","Spine.Skeleton#FlipX#set","Spine.Skeleton#FlipY#get","Spine.Skeleton#FlipY#set","Spine.Skeleton#RootBone#get","Spine.Skeleton#init","Spine.Skeleton#ctor","Spine.Skeleton#UpdateCache","Spine.Skeleton#SortIkConstraint","Spine.Skeleton#SortPathConstraint","Spine.Skeleton#SortTransformConstraint","Spine.Skeleton#SortPathConstraintAttachment$1","Spine.Skeleton#SortPathConstraintAttachment","Spine.Skeleton#SortBone","Spine.Skeleton#UpdateWorldTransform","Spine.Skeleton#UpdateWorldTransform$1","Spine.Skeleton#SetToSetupPose","Spine.Skeleton#SetBonesToSetupPose","Spine.Skeleton#SetSlotsToSetupPose","Spine.Skeleton#FindBone","Spine.Skeleton#FindBoneIndex","Spine.Skeleton#FindSlot","Spine.Skeleton#FindSlotIndex","Spine.Skeleton#SetSkin$1","Spine.Skeleton#SetSkin","Spine.Skeleton#GetAttachment$1","Spine.Skeleton#GetAttachment","Spine.Skeleton#SetAttachment","Spine.Skeleton#FindIkConstraint","Spine.Skeleton#FindTransformConstraint","Spine.Skeleton#FindPathConstraint","Spine.Skeleton#Update","Spine.Skeleton#GetBounds","Spine.SkeletonBinary#init","Spine.SkeletonBinary#GetVersionString","Spine.SkeletonBinary#init","Spine.SkeletonBinary#ctor","Spine.SkeletonBinary#$ctor1","Spine.SkeletonBinary#ReadSkeletonData$1","Spine.SkeletonBinary#ReadSkeletonData","Spine.SkeletonBinary#ReadSkin","Spine.SkeletonBinary#ReadAttachment","Spine.SkeletonBinary#ReadVertices","Spine.SkeletonBinary#ReadFloatArray","Spine.SkeletonBinary#ReadShortArray","Spine.SkeletonBinary#ReadAnimation","Spine.SkeletonBinary#ReadCurve","Spine.SkeletonBinary.SkeletonInput#init","Spine.SkeletonBinary.SkeletonInput#ctor","Spine.SkeletonBinary.SkeletonInput#ReadByte","Spine.SkeletonBinary.SkeletonInput#ReadSByte","Spine.SkeletonBinary.SkeletonInput#ReadBoolean","Spine.SkeletonBinary.SkeletonInput#ReadFloat","Spine.SkeletonBinary.SkeletonInput#ReadInt","Spine.SkeletonBinary.SkeletonInput#ReadInt$1","Spine.SkeletonBinary.SkeletonInput#ReadString","Spine.SkeletonBinary.SkeletonInput#ReadStringRef","Spine.SkeletonBinary.SkeletonInput#ReadFully","Spine.SkeletonBinary.SkeletonInput#GetVersionString","Spine.SkeletonBounds#MinX#get","Spine.SkeletonBounds#MinX#set","Spine.SkeletonBounds#MinY#get","Spine.SkeletonBounds#MinY#set","Spine.SkeletonBounds#MaxX#get","Spine.SkeletonBounds#MaxX#set","Spine.SkeletonBounds#MaxY#get","Spine.SkeletonBounds#MaxY#set","Spine.SkeletonBounds#Width#get","Spine.SkeletonBounds#Height#get","Spine.SkeletonBounds#init","Spine.SkeletonBounds#ctor","Spine.SkeletonBounds#Update","Spine.SkeletonBounds#AabbCompute","Spine.SkeletonBounds#AabbContainsPoint","Spine.SkeletonBounds#AabbIntersectsSegment","Spine.SkeletonBounds#AabbIntersectsSkeleton","Spine.SkeletonBounds#ContainsPoint$1","Spine.SkeletonBounds#ContainsPoint","Spine.SkeletonBounds#IntersectsSegment","Spine.SkeletonBounds#IntersectsSegment$1","Spine.SkeletonBounds#GetPolygon","Spine.SkeletonClipping#MakeClockwise","Spine.SkeletonClipping#ClippedVertices#get","Spine.SkeletonClipping#ClippedTriangles#get","Spine.SkeletonClipping#ClippedUVs#get","Spine.SkeletonClipping#IsClipping#get","Spine.SkeletonClipping#init","Spine.SkeletonClipping#ClipStart","Spine.SkeletonClipping#ClipEnd$1","Spine.SkeletonClipping#ClipEnd","Spine.SkeletonClipping#ClipTriangles","Spine.SkeletonClipping#Clip","Spine.SkeletonData#Name#get","Spine.SkeletonData#Name#set","Spine.SkeletonData#Bones#get","Spine.SkeletonData#Slots#get","Spine.SkeletonData#Skins#get","Spine.SkeletonData#Skins#set","Spine.SkeletonData#DefaultSkin#get","Spine.SkeletonData#DefaultSkin#set","Spine.SkeletonData#Events#get","Spine.SkeletonData#Events#set","Spine.SkeletonData#Animations#get","Spine.SkeletonData#Animations#set","Spine.SkeletonData#IkConstraints#get","Spine.SkeletonData#IkConstraints#set","Spine.SkeletonData#TransformConstraints#get","Spine.SkeletonData#TransformConstraints#set","Spine.SkeletonData#PathConstraints#get","Spine.SkeletonData#PathConstraints#set","Spine.SkeletonData#X#get","Spine.SkeletonData#X#set","Spine.SkeletonData#Y#get","Spine.SkeletonData#Y#set","Spine.SkeletonData#Width#get","Spine.SkeletonData#Width#set","Spine.SkeletonData#Height#get","Spine.SkeletonData#Height#set","Spine.SkeletonData#Version#get","Spine.SkeletonData#Version#set","Spine.SkeletonData#Hash#get","Spine.SkeletonData#Hash#set","Spine.SkeletonData#ImagesPath#get","Spine.SkeletonData#ImagesPath#set","Spine.SkeletonData#AudioPath#get","Spine.SkeletonData#AudioPath#set","Spine.SkeletonData#Fps#get","Spine.SkeletonData#Fps#set","Spine.SkeletonData#init","Spine.SkeletonData#FindBone","Spine.SkeletonData#FindBoneIndex","Spine.SkeletonData#FindSlot","Spine.SkeletonData#FindSlotIndex","Spine.SkeletonData#FindSkin","Spine.SkeletonData#FindEvent","Spine.SkeletonData#FindAnimation","Spine.SkeletonData#FindIkConstraint","Spine.SkeletonData#FindTransformConstraint","Spine.SkeletonData#FindPathConstraint","Spine.SkeletonData#FindPathConstraintIndex","Spine.SkeletonData#toString","Spine.SkeletonJson#ReadCurve","Spine.SkeletonJson#GetFloatArray","Spine.SkeletonJson#GetIntArray","Spine.SkeletonJson#GetFloat","Spine.SkeletonJson#GetInt","Spine.SkeletonJson#GetBoolean","Spine.SkeletonJson#GetString","Spine.SkeletonJson#ToColor","Spine.SkeletonJson#init","Spine.SkeletonJson#ctor","Spine.SkeletonJson#$ctor1","Spine.SkeletonJson#ReadSkeletonData$1","Spine.SkeletonJson#ReadSkeletonData","Spine.SkeletonJson#ReadAttachment","Spine.SkeletonJson#ReadVertices","Spine.SkeletonJson#ReadAnimation","Spine.SkeletonJson.LinkedMesh#ctor","Spine.Skin#Name#get","Spine.Skin#Attachments#get","Spine.Skin#Bones#get","Spine.Skin#Constraints#get","Spine.Skin#init","Spine.Skin#ctor","Spine.Skin#SetAttachment","Spine.Skin#AddSkin","Spine.Skin#CopySkin","Spine.Skin#GetAttachment","Spine.Skin#RemoveAttachment","Spine.Skin#GetAttachments","Spine.Skin#GetAttachments$1","Spine.Skin#Clear","Spine.Skin#toString","Spine.Skin#AttachAll","Spine.Skin.SkinEntry#getDefaultValue","Spine.Skin.SkinEntry#SlotIndex#get","Spine.Skin.SkinEntry#Name#get","Spine.Skin.SkinEntry#Attachment#get","Spine.Skin.SkinEntry#$ctor1","Spine.Skin.SkinEntry#ctor","Spine.Skin.SkinEntry#getHashCode","Spine.Skin.SkinEntry#equals","Spine.Skin.SkinEntry#$clone","Spine.Slot#Data#get","Spine.Slot#Bone#get","Spine.Slot#Skeleton#get","Spine.Slot#R#get","Spine.Slot#R#set","Spine.Slot#G#get","Spine.Slot#G#set","Spine.Slot#B#get","Spine.Slot#B#set","Spine.Slot#A#get","Spine.Slot#A#set","Spine.Slot#R2#get","Spine.Slot#R2#set","Spine.Slot#G2#get","Spine.Slot#G2#set","Spine.Slot#B2#get","Spine.Slot#B2#set","Spine.Slot#HasSecondColor#get","Spine.Slot#HasSecondColor#set","Spine.Slot#Attachment#get","Spine.Slot#Attachment#set","Spine.Slot#AttachmentTime#get","Spine.Slot#AttachmentTime#set","Spine.Slot#Deform#get","Spine.Slot#Deform#set","Spine.Slot#init","Spine.Slot#$ctor1","Spine.Slot#ctor","Spine.Slot#ClampColor","Spine.Slot#ClampSecondColor","Spine.Slot#SetToSetupPose","Spine.Slot#toString","Spine.SlotData#Index#get","Spine.SlotData#Name#get","Spine.SlotData#BoneData#get","Spine.SlotData#R#get","Spine.SlotData#R#set","Spine.SlotData#G#get","Spine.SlotData#G#set","Spine.SlotData#B#get","Spine.SlotData#B#set","Spine.SlotData#A#get","Spine.SlotData#A#set","Spine.SlotData#R2#get","Spine.SlotData#R2#set","Spine.SlotData#G2#get","Spine.SlotData#G2#set","Spine.SlotData#B2#get","Spine.SlotData#B2#set","Spine.SlotData#HasSecondColor#get","Spine.SlotData#HasSecondColor#set","Spine.SlotData#AttachmentName#get","Spine.SlotData#AttachmentName#set","Spine.SlotData#BlendMode#get","Spine.SlotData#BlendMode#set","Spine.SlotData#init","Spine.SlotData#ctor","Spine.SlotData#toString","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#IsRenderable","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.SpineSkeletonExtensions#SetPropertyToSetupPose","Spine.SpineSkeletonExtensions#SetDrawOrderToSetupPose","Spine.SpineSkeletonExtensions#SetSlotAttachmentsToSetupPose","Spine.SpineSkeletonExtensions#SetColorToSetupPose","Spine.SpineSkeletonExtensions#SetAttachmentToSetupPose","Spine.SpineSkeletonExtensions#SetSlotAttachmentToSetupPose","Spine.SpineSkeletonExtensions#SetKeyedItemsToSetupPose","Spine.SpineSkeletonExtensions#AllowImmediateQueue","Spine.Triangulator#IsConcave","Spine.Triangulator#PositiveArea","Spine.Triangulator#Winding","Spine.Triangulator#init","Spine.Triangulator#Triangulate","Spine.Triangulator#Decompose","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AttachmentTools.SkinUtilities#UnshareSkin","Spine.Unity.AttachmentTools.SkinUtilities#GetClonedSkin","Spine.Unity.AttachmentTools.SkinUtilities#GetClone","Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment$1","Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment","Spine.Unity.AttachmentTools.SkinUtilities#AddAttachments","Spine.Unity.AttachmentTools.SkinUtilities#GetAttachment","Spine.Unity.AttachmentTools.SkinUtilities#RemoveAttachment","Spine.Unity.AttachmentTools.SkinUtilities#Clear","Spine.Unity.AttachmentTools.SkinUtilities#Append","Spine.Unity.AttachmentTools.SkinUtilities#CopyTo","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.Deprecated.SlotBlendModes#MaterialTable#get","Spine.Unity.Deprecated.SlotBlendModes#GetOrAddMaterialFor","Spine.Unity.Deprecated.SlotBlendModes#GetExistingMaterialFor","Spine.Unity.Deprecated.SlotBlendModes#RemoveMaterialFromTable","Spine.Unity.Deprecated.SlotBlendModes#init","Spine.Unity.Deprecated.SlotBlendModes#Start","Spine.Unity.Deprecated.SlotBlendModes#OnDestroy","Spine.Unity.Deprecated.SlotBlendModes#Apply","Spine.Unity.Deprecated.SlotBlendModes#Remove","Spine.Unity.Deprecated.SlotBlendModes#GetTexture","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getDefaultValue","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#ctor","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getHashCode","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#equals","Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#$clone","Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#init","Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#ctor","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getDefaultValue","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$ctor1","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#ctor","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getHashCode","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#equals","Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$clone","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.FollowLocationRigidbody#Awake","Spine.Unity.FollowLocationRigidbody#FixedUpdate","Spine.Unity.FollowLocationRigidbody2D#Awake","Spine.Unity.FollowLocationRigidbody2D#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#Start","Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineTrackEntryEnd#init","Spine.Unity.WaitForSpineTrackEntryEnd#ctor","Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd","Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe","Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset","ThirdParties.Truongtv.SoundManager.BaseAudio#Awake","ThirdParties.Truongtv.SoundManager.BaseAudio#PlayOnceShot","ThirdParties.Truongtv.SoundManager.BaseAudio#PlayLoop","ThirdParties.Truongtv.SoundManager.BaseAudio#WaitToFinish","ThirdParties.Truongtv.SoundManager.BaseAudio#Pause","ThirdParties.Truongtv.SoundManager.BaseAudio#Resume","ThirdParties.Truongtv.SoundManager.BaseAudio#Stop","ThirdParties.Truongtv.SoundManager.BaseAudio#OnValidate","ThirdParties.Truongtv.SoundManager.SoundManager#Instance#get","ThirdParties.Truongtv.SoundManager.SoundManager#init","ThirdParties.Truongtv.SoundManager.SoundManager#IsBgm","ThirdParties.Truongtv.SoundManager.SoundManager#IsSfx","ThirdParties.Truongtv.SoundManager.SoundManager#SetSfx","ThirdParties.Truongtv.SoundManager.SoundManager#SetBgm","ThirdParties.Truongtv.SoundManager.SoundManager#Awake","ThirdParties.Truongtv.SoundManager.SoundManager#PlaySfx","ThirdParties.Truongtv.SoundManager.SoundManager#PlayBgm","ThirdParties.Truongtv.SoundManager.SoundManager#Pause","ThirdParties.Truongtv.SoundManager.SoundManager#GetSfxInstance","ThirdParties.Truongtv.SoundManager.SoundManager#PlayPopupOpenSound","ThirdParties.Truongtv.SoundManager.SoundManager#PlayPopupCloseSound","ThirdParties.Truongtv.SoundManager.SoundManager#PlayButtonSound","Truongtv.Utilities.DontDestroyOnLoad#Start","Truongtv.Utilities.Extended#IsInLayerMask","Truongtv.Utilities.Singleton$1#Instance#get","Truongtv.Utilities.Singleton$1#init","UICanvasManager#init","UICanvasManager#Awake","UICanvasManager#Start","UICanvasManager#Update","UICanvasManager#UpdateToolTip","UICanvasManager#ClearToolTip","UICanvasManager#SelectPreviousPE","UICanvasManager#SelectNextPE","UICanvasManager#SpawnCurrentParticleEffect","UICanvasManager#UIButtonClick","Spine.AnimationStateData.AnimationPairComparer#init","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2","Spine.Atlas#ReadValue","Spine.Atlas#ReadTuple","Spine.Atlas#Regions#get","Spine.Atlas#Pages#get","Spine.Atlas#init","Spine.Atlas#$ctor1","Spine.Atlas#ctor","Spine.Atlas#GetEnumerator","Spine.Atlas#System$Collections$IEnumerable$GetEnumerator","Spine.Atlas#Load","Spine.Atlas#FlipV","Spine.Atlas#FindRegion","Spine.Atlas#Dispose","Spine.AtlasAttachmentLoader#ctor","Spine.AtlasAttachmentLoader#NewRegionAttachment","Spine.AtlasAttachmentLoader#NewMeshAttachment","Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment","Spine.AtlasAttachmentLoader#NewPathAttachment","Spine.AtlasAttachmentLoader#NewPointAttachment","Spine.AtlasAttachmentLoader#NewClippingAttachment","Spine.AtlasAttachmentLoader#FindRegion","Spine.AttachmentTimeline#PropertyId#get","Spine.AttachmentTimeline#FrameCount#get","Spine.AttachmentTimeline#SlotIndex#get","Spine.AttachmentTimeline#SlotIndex#set","Spine.AttachmentTimeline#Frames#get","Spine.AttachmentTimeline#Frames#set","Spine.AttachmentTimeline#AttachmentNames#get","Spine.AttachmentTimeline#AttachmentNames#set","Spine.AttachmentTimeline#ctor","Spine.AttachmentTimeline#SetFrame","Spine.AttachmentTimeline#Apply","Spine.AttachmentTimeline#SetAttachment","Spine.Bone#Data#get","Spine.Bone#Skeleton#get","Spine.Bone#Parent#get","Spine.Bone#Children#get","Spine.Bone#Active#get","Spine.Bone#X#get","Spine.Bone#X#set","Spine.Bone#Y#get","Spine.Bone#Y#set","Spine.Bone#Rotation#get","Spine.Bone#Rotation#set","Spine.Bone#ScaleX#get","Spine.Bone#ScaleX#set","Spine.Bone#ScaleY#get","Spine.Bone#ScaleY#set","Spine.Bone#ShearX#get","Spine.Bone#ShearX#set","Spine.Bone#ShearY#get","Spine.Bone#ShearY#set","Spine.Bone#AppliedRotation#get","Spine.Bone#AppliedRotation#set","Spine.Bone#AX#get","Spine.Bone#AX#set","Spine.Bone#AY#get","Spine.Bone#AY#set","Spine.Bone#AScaleX#get","Spine.Bone#AScaleX#set","Spine.Bone#AScaleY#get","Spine.Bone#AScaleY#set","Spine.Bone#AShearX#get","Spine.Bone#AShearX#set","Spine.Bone#AShearY#get","Spine.Bone#AShearY#set","Spine.Bone#A#get","Spine.Bone#B#get","Spine.Bone#C#get","Spine.Bone#D#get","Spine.Bone#WorldX#get","Spine.Bone#WorldY#get","Spine.Bone#WorldRotationX#get","Spine.Bone#WorldRotationY#get","Spine.Bone#WorldScaleX#get","Spine.Bone#WorldScaleY#get","Spine.Bone#WorldToLocalRotationX#get","Spine.Bone#WorldToLocalRotationY#get","Spine.Bone#init","Spine.Bone#ctor","Spine.Bone#Update","Spine.Bone#UpdateWorldTransform","Spine.Bone#UpdateWorldTransform$1","Spine.Bone#SetToSetupPose","Spine.Bone#UpdateAppliedTransform","Spine.Bone#WorldToLocal","Spine.Bone#LocalToWorld","Spine.Bone#WorldToLocalRotation","Spine.Bone#LocalToWorldRotation","Spine.Bone#RotateWorld","Spine.Bone#toString","Spine.VertexAttachment#init","Spine.VertexAttachment#Id#get","Spine.VertexAttachment#Bones#get","Spine.VertexAttachment#Bones#set","Spine.VertexAttachment#Vertices#get","Spine.VertexAttachment#Vertices#set","Spine.VertexAttachment#WorldVerticesLength#get","Spine.VertexAttachment#WorldVerticesLength#set","Spine.VertexAttachment#DeformAttachment#get","Spine.VertexAttachment#DeformAttachment#set","Spine.VertexAttachment#ctor","Spine.VertexAttachment#ComputeWorldVertices$1","Spine.VertexAttachment#ComputeWorldVertices","Spine.VertexAttachment#CopyTo","Spine.CurveTimeline#init","Spine.CurveTimeline#FrameCount#get","Spine.CurveTimeline#ctor","Spine.CurveTimeline#SetLinear","Spine.CurveTimeline#SetStepped","Spine.CurveTimeline#GetCurveType","Spine.CurveTimeline#SetCurve","Spine.CurveTimeline#GetCurvePercent","Spine.DrawOrderTimeline#PropertyId#get","Spine.DrawOrderTimeline#FrameCount#get","Spine.DrawOrderTimeline#Frames#get","Spine.DrawOrderTimeline#Frames#set","Spine.DrawOrderTimeline#DrawOrders#get","Spine.DrawOrderTimeline#DrawOrders#set","Spine.DrawOrderTimeline#ctor","Spine.DrawOrderTimeline#SetFrame","Spine.DrawOrderTimeline#Apply","Spine.EventTimeline#PropertyId#get","Spine.EventTimeline#FrameCount#get","Spine.EventTimeline#Frames#get","Spine.EventTimeline#Frames#set","Spine.EventTimeline#Events#get","Spine.EventTimeline#Events#set","Spine.EventTimeline#ctor","Spine.EventTimeline#SetFrame","Spine.EventTimeline#Apply","Spine.IkConstraint#Apply$1","Spine.IkConstraint#Apply","Spine.IkConstraint#Bones#get","Spine.IkConstraint#Target#get","Spine.IkConstraint#Target#set","Spine.IkConstraint#Mix#get","Spine.IkConstraint#Mix#set","Spine.IkConstraint#Softness#get","Spine.IkConstraint#Softness#set","Spine.IkConstraint#BendDirection#get","Spine.IkConstraint#BendDirection#set","Spine.IkConstraint#Compress#get","Spine.IkConstraint#Compress#set","Spine.IkConstraint#Stretch#get","Spine.IkConstraint#Stretch#set","Spine.IkConstraint#Active#get","Spine.IkConstraint#Data#get","Spine.IkConstraint#init","Spine.IkConstraint#$ctor1","Spine.IkConstraint#ctor","Spine.IkConstraint#Apply","Spine.IkConstraint#Update","Spine.IkConstraint#toString","Spine.IkConstraintData#Bones#get","Spine.IkConstraintData#Target#get","Spine.IkConstraintData#Target#set","Spine.IkConstraintData#Mix#get","Spine.IkConstraintData#Mix#set","Spine.IkConstraintData#Softness#get","Spine.IkConstraintData#Softness#set","Spine.IkConstraintData#BendDirection#get","Spine.IkConstraintData#BendDirection#set","Spine.IkConstraintData#Compress#get","Spine.IkConstraintData#Compress#set","Spine.IkConstraintData#Stretch#get","Spine.IkConstraintData#Stretch#set","Spine.IkConstraintData#Uniform#get","Spine.IkConstraintData#Uniform#set","Spine.IkConstraintData#init","Spine.IkConstraintData#ctor","Spine.PathConstraint#init","Spine.PathConstraint#AddBeforePosition","Spine.PathConstraint#AddAfterPosition","Spine.PathConstraint#AddCurvePosition","Spine.PathConstraint#Position#get","Spine.PathConstraint#Position#set","Spine.PathConstraint#Spacing#get","Spine.PathConstraint#Spacing#set","Spine.PathConstraint#RotateMix#get","Spine.PathConstraint#RotateMix#set","Spine.PathConstraint#TranslateMix#get","Spine.PathConstraint#TranslateMix#set","Spine.PathConstraint#Bones#get","Spine.PathConstraint#Target#get","Spine.PathConstraint#Target#set","Spine.PathConstraint#Active#get","Spine.PathConstraint#Data#get","Spine.PathConstraint#init","Spine.PathConstraint#$ctor1","Spine.PathConstraint#ctor","Spine.PathConstraint#Apply","Spine.PathConstraint#Update","Spine.PathConstraint#ComputeWorldPositions","Spine.PathConstraintData#Bones#get","Spine.PathConstraintData#Target#get","Spine.PathConstraintData#Target#set","Spine.PathConstraintData#PositionMode#get","Spine.PathConstraintData#PositionMode#set","Spine.PathConstraintData#SpacingMode#get","Spine.PathConstraintData#SpacingMode#set","Spine.PathConstraintData#RotateMode#get","Spine.PathConstraintData#RotateMode#set","Spine.PathConstraintData#OffsetRotation#get","Spine.PathConstraintData#OffsetRotation#set","Spine.PathConstraintData#Position#get","Spine.PathConstraintData#Position#set","Spine.PathConstraintData#Spacing#get","Spine.PathConstraintData#Spacing#set","Spine.PathConstraintData#RotateMix#get","Spine.PathConstraintData#RotateMix#set","Spine.PathConstraintData#TranslateMix#get","Spine.PathConstraintData#TranslateMix#set","Spine.PathConstraintData#init","Spine.PathConstraintData#ctor","Spine.PointAttachment#X#get","Spine.PointAttachment#X#set","Spine.PointAttachment#Y#get","Spine.PointAttachment#Y#set","Spine.PointAttachment#Rotation#get","Spine.PointAttachment#Rotation#set","Spine.PointAttachment#ctor","Spine.PointAttachment#ComputeWorldPosition","Spine.PointAttachment#ComputeWorldRotation","Spine.PointAttachment#Copy","Spine.Pow#ctor","Spine.Pow#Apply$1","Spine.RegionAttachment#init","Spine.RegionAttachment#X#get","Spine.RegionAttachment#X#set","Spine.RegionAttachment#Y#get","Spine.RegionAttachment#Y#set","Spine.RegionAttachment#Rotation#get","Spine.RegionAttachment#Rotation#set","Spine.RegionAttachment#ScaleX#get","Spine.RegionAttachment#ScaleX#set","Spine.RegionAttachment#ScaleY#get","Spine.RegionAttachment#ScaleY#set","Spine.RegionAttachment#Width#get","Spine.RegionAttachment#Width#set","Spine.RegionAttachment#Height#get","Spine.RegionAttachment#Height#set","Spine.RegionAttachment#R#get","Spine.RegionAttachment#R#set","Spine.RegionAttachment#G#get","Spine.RegionAttachment#G#set","Spine.RegionAttachment#B#get","Spine.RegionAttachment#B#set","Spine.RegionAttachment#A#get","Spine.RegionAttachment#A#set","Spine.RegionAttachment#RegionOffsetX#get","Spine.RegionAttachment#RegionOffsetX#set","Spine.RegionAttachment#RegionOffsetY#get","Spine.RegionAttachment#RegionOffsetY#set","Spine.RegionAttachment#RegionWidth#get","Spine.RegionAttachment#RegionWidth#set","Spine.RegionAttachment#RegionHeight#get","Spine.RegionAttachment#RegionHeight#set","Spine.RegionAttachment#RegionOriginalWidth#get","Spine.RegionAttachment#RegionOriginalWidth#set","Spine.RegionAttachment#RegionOriginalHeight#get","Spine.RegionAttachment#RegionOriginalHeight#set","Spine.RegionAttachment#Offset#get","Spine.RegionAttachment#UVs#get","Spine.RegionAttachment#init","Spine.RegionAttachment#ctor","Spine.RegionAttachment#UpdateOffset","Spine.RegionAttachment#SetUVs","Spine.RegionAttachment#ComputeWorldVertices","Spine.RegionAttachment#Copy","Spine.Skin.SkinEntryComparer#init","Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2","Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2","Spine.TrackEntry#inherits","Spine.TrackEntry#TrackIndex#get","Spine.TrackEntry#Animation#get","Spine.TrackEntry#Loop#get","Spine.TrackEntry#Loop#set","Spine.TrackEntry#Delay#get","Spine.TrackEntry#Delay#set","Spine.TrackEntry#TrackTime#get","Spine.TrackEntry#TrackTime#set","Spine.TrackEntry#TrackEnd#get","Spine.TrackEntry#TrackEnd#set","Spine.TrackEntry#AnimationStart#get","Spine.TrackEntry#AnimationStart#set","Spine.TrackEntry#AnimationEnd#get","Spine.TrackEntry#AnimationEnd#set","Spine.TrackEntry#AnimationLast#get","Spine.TrackEntry#AnimationLast#set","Spine.TrackEntry#AnimationTime#get","Spine.TrackEntry#TimeScale#get","Spine.TrackEntry#TimeScale#set","Spine.TrackEntry#Alpha#get","Spine.TrackEntry#Alpha#set","Spine.TrackEntry#EventThreshold#get","Spine.TrackEntry#EventThreshold#set","Spine.TrackEntry#AttachmentThreshold#get","Spine.TrackEntry#AttachmentThreshold#set","Spine.TrackEntry#DrawOrderThreshold#get","Spine.TrackEntry#DrawOrderThreshold#set","Spine.TrackEntry#Next#get","Spine.TrackEntry#IsComplete#get","Spine.TrackEntry#MixTime#get","Spine.TrackEntry#MixTime#set","Spine.TrackEntry#MixDuration#get","Spine.TrackEntry#MixDuration#set","Spine.TrackEntry#MixBlend#get","Spine.TrackEntry#MixBlend#set","Spine.TrackEntry#MixingFrom#get","Spine.TrackEntry#MixingTo#get","Spine.TrackEntry#HoldPrevious#get","Spine.TrackEntry#HoldPrevious#set","Spine.TrackEntry#init","Spine.TrackEntry#OnStart","Spine.TrackEntry#OnInterrupt","Spine.TrackEntry#OnEnd","Spine.TrackEntry#OnDispose","Spine.TrackEntry#OnComplete","Spine.TrackEntry#OnEvent","Spine.TrackEntry#Reset","Spine.TrackEntry#ResetRotationDirections","Spine.TrackEntry#toString","Spine.TransformConstraint#Bones#get","Spine.TransformConstraint#Target#get","Spine.TransformConstraint#Target#set","Spine.TransformConstraint#RotateMix#get","Spine.TransformConstraint#RotateMix#set","Spine.TransformConstraint#TranslateMix#get","Spine.TransformConstraint#TranslateMix#set","Spine.TransformConstraint#ScaleMix#get","Spine.TransformConstraint#ScaleMix#set","Spine.TransformConstraint#ShearMix#get","Spine.TransformConstraint#ShearMix#set","Spine.TransformConstraint#Active#get","Spine.TransformConstraint#Data#get","Spine.TransformConstraint#$ctor1","Spine.TransformConstraint#ctor","Spine.TransformConstraint#Apply","Spine.TransformConstraint#Update","Spine.TransformConstraint#ApplyAbsoluteWorld","Spine.TransformConstraint#ApplyRelativeWorld","Spine.TransformConstraint#ApplyAbsoluteLocal","Spine.TransformConstraint#ApplyRelativeLocal","Spine.TransformConstraint#toString","Spine.TransformConstraintData#Bones#get","Spine.TransformConstraintData#Target#get","Spine.TransformConstraintData#Target#set","Spine.TransformConstraintData#RotateMix#get","Spine.TransformConstraintData#RotateMix#set","Spine.TransformConstraintData#TranslateMix#get","Spine.TransformConstraintData#TranslateMix#set","Spine.TransformConstraintData#ScaleMix#get","Spine.TransformConstraintData#ScaleMix#set","Spine.TransformConstraintData#ShearMix#get","Spine.TransformConstraintData#ShearMix#set","Spine.TransformConstraintData#OffsetRotation#get","Spine.TransformConstraintData#OffsetRotation#set","Spine.TransformConstraintData#OffsetX#get","Spine.TransformConstraintData#OffsetX#set","Spine.TransformConstraintData#OffsetY#get","Spine.TransformConstraintData#OffsetY#set","Spine.TransformConstraintData#OffsetScaleX#get","Spine.TransformConstraintData#OffsetScaleX#set","Spine.TransformConstraintData#OffsetScaleY#get","Spine.TransformConstraintData#OffsetScaleY#set","Spine.TransformConstraintData#OffsetShearY#get","Spine.TransformConstraintData#OffsetShearY#set","Spine.TransformConstraintData#Relative#get","Spine.TransformConstraintData#Relative#set","Spine.TransformConstraintData#Local#get","Spine.TransformConstraintData#Local#set","Spine.TransformConstraintData#init","Spine.TransformConstraintData#ctor","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#SyncRawImagesWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","ThirdParties.Truongtv.SoundManager.Bgm#Instance#get","ThirdParties.Truongtv.SoundManager.Bgm#Awake","ThirdParties.Truongtv.SoundManager.Bgm#Start","ThirdParties.Truongtv.SoundManager.Bgm#OnDestroy","ThirdParties.Truongtv.SoundManager.Bgm#OnSettingChange","ThirdParties.Truongtv.SoundManager.Bgm#IsPlaying","ThirdParties.Truongtv.SoundManager.Bgm#IsPlayingClip","ThirdParties.Truongtv.SoundManager.Bgm#Play","ThirdParties.Truongtv.SoundManager.Bgm#Stop$1","ThirdParties.Truongtv.SoundManager.Sfx#Start","ThirdParties.Truongtv.SoundManager.Sfx#OnDestroy","ThirdParties.Truongtv.SoundManager.Sfx#OnSettingChange","ThirdParties.Truongtv.SoundManager.Sfx#Play","ThirdParties.Truongtv.SoundManager.SimpleAudio#Start","ThirdParties.Truongtv.SoundManager.SimpleAudio#OnDestroy","ThirdParties.Truongtv.SoundManager.SimpleAudio#OnSettingChange","ThirdParties.Truongtv.SoundManager.SimpleAudio#Play","ThirdParties.Truongtv.SoundManager.SimpleAudio#Play$1","ThirdParties.Truongtv.SoundManager.SimpleAudio#SetLoop","ThirdParties.Truongtv.SoundManager.SimpleAudio#Stop$1","Spine.BoundingBoxAttachment#ctor","Spine.BoundingBoxAttachment#Copy","Spine.ClippingAttachment#EndSlot#get","Spine.ClippingAttachment#EndSlot#set","Spine.ClippingAttachment#ctor","Spine.ClippingAttachment#Copy","Spine.ColorTimeline#init","Spine.ColorTimeline#PropertyId#get","Spine.ColorTimeline#SlotIndex#get","Spine.ColorTimeline#SlotIndex#set","Spine.ColorTimeline#Frames#get","Spine.ColorTimeline#Frames#set","Spine.ColorTimeline#ctor","Spine.ColorTimeline#SetFrame","Spine.ColorTimeline#Apply","Spine.DeformTimeline#PropertyId#get","Spine.DeformTimeline#SlotIndex#get","Spine.DeformTimeline#SlotIndex#set","Spine.DeformTimeline#Attachment#get","Spine.DeformTimeline#Attachment#set","Spine.DeformTimeline#Frames#get","Spine.DeformTimeline#Frames#set","Spine.DeformTimeline#Vertices#get","Spine.DeformTimeline#Vertices#set","Spine.DeformTimeline#ctor","Spine.DeformTimeline#SetFrame","Spine.DeformTimeline#Apply","Spine.IkConstraintTimeline#init","Spine.IkConstraintTimeline#PropertyId#get","Spine.IkConstraintTimeline#IkConstraintIndex#get","Spine.IkConstraintTimeline#IkConstraintIndex#set","Spine.IkConstraintTimeline#Frames#get","Spine.IkConstraintTimeline#Frames#set","Spine.IkConstraintTimeline#ctor","Spine.IkConstraintTimeline#SetFrame","Spine.IkConstraintTimeline#Apply","Spine.MeshAttachment#HullLength#get","Spine.MeshAttachment#HullLength#set","Spine.MeshAttachment#RegionUVs#get","Spine.MeshAttachment#RegionUVs#set","Spine.MeshAttachment#UVs#get","Spine.MeshAttachment#UVs#set","Spine.MeshAttachment#Triangles#get","Spine.MeshAttachment#Triangles#set","Spine.MeshAttachment#R#get","Spine.MeshAttachment#R#set","Spine.MeshAttachment#G#get","Spine.MeshAttachment#G#set","Spine.MeshAttachment#B#get","Spine.MeshAttachment#B#set","Spine.MeshAttachment#A#get","Spine.MeshAttachment#A#set","Spine.MeshAttachment#RegionOffsetX#get","Spine.MeshAttachment#RegionOffsetX#set","Spine.MeshAttachment#RegionOffsetY#get","Spine.MeshAttachment#RegionOffsetY#set","Spine.MeshAttachment#RegionWidth#get","Spine.MeshAttachment#RegionWidth#set","Spine.MeshAttachment#RegionHeight#get","Spine.MeshAttachment#RegionHeight#set","Spine.MeshAttachment#RegionOriginalWidth#get","Spine.MeshAttachment#RegionOriginalWidth#set","Spine.MeshAttachment#RegionOriginalHeight#get","Spine.MeshAttachment#RegionOriginalHeight#set","Spine.MeshAttachment#ParentMesh#get","Spine.MeshAttachment#ParentMesh#set","Spine.MeshAttachment#init","Spine.MeshAttachment#ctor","Spine.MeshAttachment#UpdateUVs","Spine.MeshAttachment#Copy","Spine.MeshAttachment#NewLinkedMesh","Spine.PathAttachment#Lengths#get","Spine.PathAttachment#Lengths#set","Spine.PathAttachment#Closed#get","Spine.PathAttachment#Closed#set","Spine.PathAttachment#ConstantSpeed#get","Spine.PathAttachment#ConstantSpeed#set","Spine.PathAttachment#ctor","Spine.PathAttachment#Copy","Spine.PathConstraintMixTimeline#init","Spine.PathConstraintMixTimeline#PropertyId#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#set","Spine.PathConstraintMixTimeline#Frames#get","Spine.PathConstraintMixTimeline#Frames#set","Spine.PathConstraintMixTimeline#ctor","Spine.PathConstraintMixTimeline#SetFrame","Spine.PathConstraintMixTimeline#Apply","Spine.PathConstraintPositionTimeline#init","Spine.PathConstraintPositionTimeline#PropertyId#get","Spine.PathConstraintPositionTimeline#PathConstraintIndex#get","Spine.PathConstraintPositionTimeline#PathConstraintIndex#set","Spine.PathConstraintPositionTimeline#Frames#get","Spine.PathConstraintPositionTimeline#Frames#set","Spine.PathConstraintPositionTimeline#ctor","Spine.PathConstraintPositionTimeline#SetFrame","Spine.PathConstraintPositionTimeline#Apply","Spine.PowOut#ctor","Spine.PowOut#Apply$1","Spine.RotateTimeline#init","Spine.RotateTimeline#PropertyId#get","Spine.RotateTimeline#BoneIndex#get","Spine.RotateTimeline#BoneIndex#set","Spine.RotateTimeline#Frames#get","Spine.RotateTimeline#Frames#set","Spine.RotateTimeline#ctor","Spine.RotateTimeline#SetFrame","Spine.RotateTimeline#Apply","Spine.TranslateTimeline#init","Spine.TranslateTimeline#PropertyId#get","Spine.TranslateTimeline#BoneIndex#get","Spine.TranslateTimeline#BoneIndex#set","Spine.TranslateTimeline#Frames#get","Spine.TranslateTimeline#Frames#set","Spine.TranslateTimeline#ctor","Spine.TranslateTimeline#SetFrame","Spine.TranslateTimeline#Apply","Spine.TransformConstraintTimeline#init","Spine.TransformConstraintTimeline#PropertyId#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#set","Spine.TransformConstraintTimeline#Frames#get","Spine.TransformConstraintTimeline#Frames#set","Spine.TransformConstraintTimeline#ctor","Spine.TransformConstraintTimeline#SetFrame","Spine.TransformConstraintTimeline#Apply","Spine.TwoColorTimeline#init","Spine.TwoColorTimeline#PropertyId#get","Spine.TwoColorTimeline#SlotIndex#get","Spine.TwoColorTimeline#SlotIndex#set","Spine.TwoColorTimeline#Frames#get","Spine.TwoColorTimeline#ctor","Spine.TwoColorTimeline#SetFrame","Spine.TwoColorTimeline#Apply","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.PathConstraintSpacingTimeline#PropertyId#get","Spine.PathConstraintSpacingTimeline#ctor","Spine.PathConstraintSpacingTimeline#Apply","Spine.ScaleTimeline#PropertyId#get","Spine.ScaleTimeline#ctor","Spine.ScaleTimeline#Apply","Spine.ShearTimeline#PropertyId#get","Spine.ShearTimeline#ctor","Spine.ShearTimeline#Apply"]' ) ); }
/**
 * @version 1.0.8091.31086
 * @copyright anton
 * @compiler Bridge.NET 17.9.13-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*BrokenPlatform start.*/
    Bridge.define("BrokenPlatform", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            breakDelay: 0,
            respawnDelay: 0,
            breakEffect: null,
            breakDelayEffect: null,
            respawnEffect: null,
            shaking: false,
            platformBreakingSound: null,
            platformExplodeSound: null,
            platformAppearSound: null,
            sprite: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BrokenPlatform#init", this ); }

                this.shaking = false;
            }
        },
        methods: {
            /*BrokenPlatform.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "BrokenPlatform#Start", this ); }

                var breakDelayEmission = this.breakDelayEffect.emission;
                breakDelayEmission.rateOverTime = new pc.MinMaxCurve( 0 );
                var respawnEffectEmission = this.respawnEffect.emission;
                respawnEffectEmission.rateOverTime = new pc.MinMaxCurve( 0 );
            },
            /*BrokenPlatform.Start end.*/

            /*BrokenPlatform.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (coll) {
if ( TRACE ) { TRACE( "BrokenPlatform#OnCollisionEnter2D", this ); }

                var $t;
                if (!this.shaking) {
                    this.shaking = true;
                    var breakDelayEmission = this.breakDelayEffect.emission;
                    breakDelayEmission.rateOverTime = new pc.MinMaxCurve( 20 );
                    $t = Bridge.getEnumerator(this.sprite);
                    try {
                        while ($t.moveNext()) {
                            var spriteChild = Bridge.cast($t.Current, UnityEngine.Transform);
                            DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Tweener, DG.Tweening.ShortcutExtensions.DOShakeRotation$3(spriteChild, this.breakDelay, new pc.Vec3( 0, 0, 20 ), 30, 20, false), Bridge.fn.bind(this, function () {
                                // SoundManager.Instance.PlaySound3D(platformExplodeSound, transform.position, 20);
                                breakDelayEmission.rateOverTime = new pc.MinMaxCurve( 0 );
                                this.breakEffect.Play();
                                this.gameObject.SetActive(false);
                                this.transform.GetChild(0).eulerAngles = pc.Vec3.ZERO.clone();
                                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, 1, this.respawnDelay), Bridge.fn.bind(this, function () {
                                    // SoundManager.Instance.PlaySound3D(platformAppearSound, transform.position, 20);
                                    var respawnEffectEmission = this.respawnEffect.emission;
                                    respawnEffectEmission.rateOverTime = new pc.MinMaxCurve( 20 );
                                    this.gameObject.SetActive(true);
                                    this.transform.localScale = pc.Vec3.ZERO.clone();
                                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, 1, 1.0), function () {
                                        respawnEffectEmission.rateOverTime = new pc.MinMaxCurve( 0 );
                                    });
                                    this.shaking = false;
                                }));
                            }));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*BrokenPlatform.OnCollisionEnter2D end.*/


        }
    });
    /*BrokenPlatform end.*/

    /*ButtonTypes start.*/
    Bridge.define("ButtonTypes", {
        $kind: "enum",
        statics: {
            fields: {
                NotDefined: 0,
                Previous: 1,
                Next: 2
            }
        }
    });
    /*ButtonTypes end.*/

    /*CameraFollower start.*/
    Bridge.define("CameraFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            target: null,
            maxY: 0
        },
        methods: {
            /*CameraFollower.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "CameraFollower#FixedUpdate", this ); }

                var pos = this.target.transform.position.$clone();
                var nextPosition = new pc.Vec3( pos.x + 1.0, pos.y + 1.0, this.transform.position.z );
                if (nextPosition.y > this.maxY) {
                    nextPosition.y = this.maxY;
                }
                this.transform.position = new pc.Vec3().lerp( this.transform.position, nextPosition, UnityEngine.Time.fixedDeltaTime * 10.0 );
            },
            /*CameraFollower.FixedUpdate end.*/


        }
    });
    /*CameraFollower end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: "nested class",
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos.$clone());
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x.$clone());
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Gradient}          gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       strength      The shake strength
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {UnityEngine.Vector2}          strength      The shake strength on each axis
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: "nested class",
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position.$clone());
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Gradient}    gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color.$clone());
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: "nested class",
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t;
                    var rBody = tweenRigidbody ? target.GetComponent(UnityEngine.Rigidbody) : null;
                    if (tweenRigidbody && UnityEngine.Component.op_Inequality(rBody, null)) {
                        t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                    } else {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*EpicToonFX.ETFXButtonScript start.*/
    Bridge.define("EpicToonFX.ETFXButtonScript", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Button: null,
            MyButtonText: null,
            projectileParticleName: null,
            effectScript: null,
            projectileScript: null,
            buttonsX: 0,
            buttonsY: 0,
            buttonsSizeX: 0,
            buttonsSizeY: 0,
            buttonsDistance: 0
        },
        methods: {
            /*EpicToonFX.ETFXButtonScript.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXButtonScript#Start", this ); }

                this.effectScript = UnityEngine.GameObject.Find("ETFXFireProjectile").GetComponent(EpicToonFX.ETFXFireProjectile);
                this.getProjectileNames();
                this.MyButtonText = this.Button.transform.Find("Text").GetComponent(UnityEngine.UI.Text);
                this.MyButtonText.text = this.projectileParticleName;
            },
            /*EpicToonFX.ETFXButtonScript.Start end.*/

            /*EpicToonFX.ETFXButtonScript.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXButtonScript#Update", this ); }

                this.MyButtonText.text = this.projectileParticleName;
                //		print(projectileParticleName);
            },
            /*EpicToonFX.ETFXButtonScript.Update end.*/

            /*EpicToonFX.ETFXButtonScript.getProjectileNames start.*/
            getProjectileNames: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXButtonScript#getProjectileNames", this ); }

                var $t;
                // Access the currently selected projectile's 'ProjectileScript'
                this.projectileScript = ($t = this.effectScript.projectiles)[this.effectScript.currentProjectile].GetComponent(ETFXProjectileScript);
                this.projectileParticleName = this.projectileScript.projectileParticle.name; // Assign the name of the currently selected projectile to projectileParticleName
            },
            /*EpicToonFX.ETFXButtonScript.getProjectileNames end.*/

            /*EpicToonFX.ETFXButtonScript.overButton start.*/
            overButton: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXButtonScript#overButton", this ); }

                var button1 = new UnityEngine.Rect.$ctor1(this.buttonsX, this.buttonsY, this.buttonsSizeX, this.buttonsSizeY);
                var button2 = new UnityEngine.Rect.$ctor1(this.buttonsX + this.buttonsDistance, this.buttonsY, this.buttonsSizeX, this.buttonsSizeY);

                if (button1.Contains(new pc.Vec2( UnityEngine.Input.mousePosition.x, UnityEngine.Screen.height - UnityEngine.Input.mousePosition.y )) || button2.Contains(new pc.Vec2( UnityEngine.Input.mousePosition.x, UnityEngine.Screen.height - UnityEngine.Input.mousePosition.y ))) {
                    return true;
                } else {
                    return false;
                }
            },
            /*EpicToonFX.ETFXButtonScript.overButton end.*/


        }
    });
    /*EpicToonFX.ETFXButtonScript end.*/

    /*EpicToonFX.ETFXFireProjectile start.*/
    Bridge.define("EpicToonFX.ETFXFireProjectile", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            projectiles: null,
            spawnPosition: null,
            currentProjectile: 0,
            speed: 0,
            selectedProjectileButton: null,
            hit: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#init", this ); }

                this.hit = new UnityEngine.RaycastHit();
                this.currentProjectile = 0;
                this.speed = 500;
            }
        },
        methods: {
            /*EpicToonFX.ETFXFireProjectile.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#Start", this ); }

                this.selectedProjectileButton = UnityEngine.GameObject.Find("Button").GetComponent(EpicToonFX.ETFXButtonScript);
            },
            /*EpicToonFX.ETFXFireProjectile.Start end.*/

            /*EpicToonFX.ETFXFireProjectile.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#Update", this ); }

                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.RightArrow)) {
                    this.nextEffect();
                }

                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.D)) {
                    this.nextEffect();
                }

                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.A)) {
                    this.previousEffect();
                } else if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.LeftArrow)) {
                    this.previousEffect();
                }

                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.Mouse0)) {
                    if (!UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject()) {
                        if (UnityEngine.Physics.Raycast$1(UnityEngine.Camera.main.ScreenPointToRay(UnityEngine.Input.mousePosition.$clone()), Bridge.ref(this, "hit"), 100.0)) {
                            var projectile = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.projectiles[this.currentProjectile], this.spawnPosition.position.$clone(), pc.Quat.IDENTITY.clone()); //Spawns the selected projectile
                            projectile.transform.LookAt$2(this.hit.point.$clone()); //Sets the projectiles rotation to look at the point clicked
                            projectile.GetComponent(UnityEngine.Rigidbody).AddForce$1(projectile.transform.forward.$clone().scale( this.speed )); //Set the speed of the projectile by applying force to the rigidbody
                        }
                    }
                }
                UnityEngine.Debug.DrawRay$1(UnityEngine.Camera.main.ScreenPointToRay(UnityEngine.Input.mousePosition.$clone()).origin.$clone(), UnityEngine.Camera.main.ScreenPointToRay(UnityEngine.Input.mousePosition.$clone()).direction.$clone().scale( 100 ), new pc.Color( 1, 1, 0, 1 ));
            },
            /*EpicToonFX.ETFXFireProjectile.Update end.*/

            /*EpicToonFX.ETFXFireProjectile.nextEffect start.*/
            nextEffect: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#nextEffect", this ); }

                if (this.currentProjectile < ((this.projectiles.length - 1) | 0)) {
                    this.currentProjectile = (this.currentProjectile + 1) | 0;
                } else {
                    this.currentProjectile = 0;
                }
                this.selectedProjectileButton.getProjectileNames();
            },
            /*EpicToonFX.ETFXFireProjectile.nextEffect end.*/

            /*EpicToonFX.ETFXFireProjectile.previousEffect start.*/
            previousEffect: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#previousEffect", this ); }

                if (this.currentProjectile > 0) {
                    this.currentProjectile = (this.currentProjectile - 1) | 0;
                } else {
                    this.currentProjectile = (this.projectiles.length - 1) | 0;
                }
                this.selectedProjectileButton.getProjectileNames();
            },
            /*EpicToonFX.ETFXFireProjectile.previousEffect end.*/

            /*EpicToonFX.ETFXFireProjectile.AdjustSpeed start.*/
            AdjustSpeed: function (newSpeed) {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXFireProjectile#AdjustSpeed", this ); }

                this.speed = newSpeed;
            },
            /*EpicToonFX.ETFXFireProjectile.AdjustSpeed end.*/


        }
    });
    /*EpicToonFX.ETFXFireProjectile end.*/

    /*EpicToonFX.ETFXLightFade start.*/
    Bridge.define("EpicToonFX.ETFXLightFade", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            life: 0,
            killAfterLife: false,
            li: null,
            initIntensity: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLightFade#init", this ); }

                this.life = 0.2;
                this.killAfterLife = true;
            }
        },
        methods: {
            /*EpicToonFX.ETFXLightFade.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLightFade#Start", this ); }

                if (UnityEngine.Object.op_Implicit(this.gameObject.GetComponent(UnityEngine.Light))) {
                    this.li = this.gameObject.GetComponent(UnityEngine.Light);
                    this.initIntensity = this.li.intensity;
                } else {
                    UnityEngine.MonoBehaviour.print("No light object found on " + (this.gameObject.name || ""));
                }
            },
            /*EpicToonFX.ETFXLightFade.Start end.*/

            /*EpicToonFX.ETFXLightFade.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLightFade#Update", this ); }

                if (UnityEngine.Object.op_Implicit(this.gameObject.GetComponent(UnityEngine.Light))) {
                    this.li.intensity -= this.initIntensity * (UnityEngine.Time.deltaTime / this.life);
                    if (this.killAfterLife && this.li.intensity <= 0) {
                        UnityEngine.Object.Destroy(this.gameObject.GetComponent(UnityEngine.Light));
                    }
                }
            },
            /*EpicToonFX.ETFXLightFade.Update end.*/


        }
    });
    /*EpicToonFX.ETFXLightFade end.*/

    /*EpicToonFX.ETFXLoopScript start.*/
    Bridge.define("EpicToonFX.ETFXLoopScript", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            chosenEffect: null,
            loopTimeLimit: 0,
            spawnWithoutLight: false,
            spawnWithoutSound: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLoopScript#init", this ); }

                this.loopTimeLimit = 2.0;
                this.spawnWithoutLight = true;
                this.spawnWithoutSound = true;
            }
        },
        methods: {
            /*EpicToonFX.ETFXLoopScript.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLoopScript#Start", this ); }

                this.PlayEffect();
            },
            /*EpicToonFX.ETFXLoopScript.Start end.*/

            /*EpicToonFX.ETFXLoopScript.PlayEffect start.*/
            PlayEffect: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLoopScript#PlayEffect", this ); }

                this.StartCoroutine$2("EffectLoop");
            },
            /*EpicToonFX.ETFXLoopScript.PlayEffect end.*/

            /*EpicToonFX.ETFXLoopScript.EffectLoop start.*/
            EffectLoop: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXLoopScript#EffectLoop", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    effectPlayer,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    effectPlayer = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.chosenEffect, this.transform.position.$clone(), this.transform.rotation.$clone());

                                        if ((this.spawnWithoutLight = true && UnityEngine.Object.op_Implicit(effectPlayer.GetComponent(UnityEngine.Light)))) {
                                            effectPlayer.GetComponent(UnityEngine.Light).enabled = false;
                                            //Destroy(gameObject.GetComponent<Light>());

                                        }

                                        if ((this.spawnWithoutSound = true && UnityEngine.Object.op_Implicit(effectPlayer.GetComponent(UnityEngine.AudioSource)))) {
                                            effectPlayer.GetComponent(UnityEngine.AudioSource).enabled = false;
                                            //Destroy(gameObject.GetComponent<AudioSource>());
                                        }

                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.loopTimeLimit);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.MonoBehaviour.Destroy(effectPlayer);
                                        this.PlayEffect();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*EpicToonFX.ETFXLoopScript.EffectLoop end.*/


        }
    });
    /*EpicToonFX.ETFXLoopScript end.*/

    /*EpicToonFX.ETFXMouseOrbit start.*/
    Bridge.define("EpicToonFX.ETFXMouseOrbit", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*EpicToonFX.ETFXMouseOrbit.ClampAngle:static start.*/
                ClampAngle: function (angle, min, max) {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXMouseOrbit#ClampAngle", this ); }

                    if (angle < -360.0) {
                        angle += 360.0;
                    }
                    if (angle > 360.0) {
                        angle -= 360.0;
                    }
                    return Math.max(min, Math.min(angle, max));
                },
                /*EpicToonFX.ETFXMouseOrbit.ClampAngle:static end.*/


            }
        },
        fields: {
            target: null,
            distance: 0,
            xSpeed: 0,
            ySpeed: 0,
            yMinLimit: 0,
            yMaxLimit: 0,
            distanceMin: 0,
            distanceMax: 0,
            smoothTime: 0,
            rotationYAxis: 0,
            rotationXAxis: 0,
            velocityX: 0,
            velocityY: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXMouseOrbit#init", this ); }

                this.distance = 5.0;
                this.xSpeed = 120.0;
                this.ySpeed = 120.0;
                this.yMinLimit = -20.0;
                this.yMaxLimit = 80.0;
                this.distanceMin = 0.5;
                this.distanceMax = 15.0;
                this.smoothTime = 2.0;
                this.rotationYAxis = 0.0;
                this.rotationXAxis = 0.0;
                this.velocityX = 0.0;
                this.velocityY = 0.0;
            }
        },
        methods: {
            /*EpicToonFX.ETFXMouseOrbit.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXMouseOrbit#Start", this ); }

                var angles = this.transform.eulerAngles.$clone();
                this.rotationYAxis = angles.y;
                this.rotationXAxis = angles.x;
                // Make the rigid body not change rotation
                if (UnityEngine.Object.op_Implicit(this.GetComponent(UnityEngine.Rigidbody))) {
                    this.GetComponent(UnityEngine.Rigidbody).freezeRotation = true;
                }
            },
            /*EpicToonFX.ETFXMouseOrbit.Start end.*/

            /*EpicToonFX.ETFXMouseOrbit.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXMouseOrbit#LateUpdate", this ); }

                if (UnityEngine.Object.op_Implicit(this.target)) {
                    if (UnityEngine.Input.GetMouseButton(1)) {
                        this.velocityX += this.xSpeed * UnityEngine.Input.GetAxis("Mouse X") * this.distance * 0.02;
                        this.velocityY += this.ySpeed * UnityEngine.Input.GetAxis("Mouse Y") * 0.02;
                    }
                    this.rotationYAxis += this.velocityX;
                    this.rotationXAxis -= this.velocityY;
                    this.rotationXAxis = EpicToonFX.ETFXMouseOrbit.ClampAngle(this.rotationXAxis, this.yMinLimit, this.yMaxLimit);
                    //Quaternion fromRotation = Quaternion.Euler(transform.rotation.eulerAngles.x, transform.rotation.eulerAngles.y, 0);
                    var toRotation = new pc.Quat().setFromEulerAngles_Unity( this.rotationXAxis, this.rotationYAxis, 0 );
                    var rotation = toRotation.$clone();

                    this.distance = Math.max(this.distanceMin, Math.min(this.distance - UnityEngine.Input.GetAxis("Mouse ScrollWheel") * 5, this.distanceMax));
                    var hit = { v : new UnityEngine.RaycastHit() };
                    if (UnityEngine.Physics.Linecast$3(this.target.position.$clone(), this.transform.position.$clone(), hit)) {
                        this.distance -= hit.v.distance;
                    }
                    var negDistance = new pc.Vec3( 0.0, 0.0, -this.distance );
                    var position = rotation.transformVector( negDistance ).add( this.target.position );

                    this.transform.rotation = rotation.$clone();
                    this.transform.position = position.$clone();
                    this.velocityX = pc.math.lerp(this.velocityX, 0, UnityEngine.Time.deltaTime * this.smoothTime);
                    this.velocityY = pc.math.lerp(this.velocityY, 0, UnityEngine.Time.deltaTime * this.smoothTime);
                }
            },
            /*EpicToonFX.ETFXMouseOrbit.LateUpdate end.*/


        }
    });
    /*EpicToonFX.ETFXMouseOrbit end.*/

    /*EpicToonFX.ETFXPitchRandomizer start.*/
    Bridge.define("EpicToonFX.ETFXPitchRandomizer", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            randomPercent: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXPitchRandomizer#init", this ); }

                this.randomPercent = 10;
            }
        },
        methods: {
            /*EpicToonFX.ETFXPitchRandomizer.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXPitchRandomizer#Start", this ); }

                var $t;
                $t = this.transform.GetComponent(UnityEngine.AudioSource);
                $t.pitch *= 1 + UnityEngine.Random.Range$1(-this.randomPercent / 100, this.randomPercent / 100);
            },
            /*EpicToonFX.ETFXPitchRandomizer.Start end.*/


        }
    });
    /*EpicToonFX.ETFXPitchRandomizer end.*/

    /*EpicToonFX.ETFXRotation start.*/
    Bridge.define("EpicToonFX.ETFXRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rotateVector: null,
            rotateSpace: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXRotation#init", this ); }

                this.rotateVector = new UnityEngine.Vector3();
                this.rotateVector = pc.Vec3.ZERO.clone();
            }
        },
        methods: {
            /*EpicToonFX.ETFXRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXRotation#Start", this ); }


            },
            /*EpicToonFX.ETFXRotation.Start end.*/

            /*EpicToonFX.ETFXRotation.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXRotation#Update", this ); }

                if (this.rotateSpace === EpicToonFX.ETFXRotation.spaceEnum.Local) {
                    this.transform.Rotate$2(this.rotateVector.$clone().scale( UnityEngine.Time.deltaTime ));
                }
                if (this.rotateSpace === EpicToonFX.ETFXRotation.spaceEnum.World) {
                    this.transform.Rotate$2(this.rotateVector.$clone().scale( UnityEngine.Time.deltaTime ), UnityEngine.Space.World);
                }
            },
            /*EpicToonFX.ETFXRotation.Update end.*/


        }
    });
    /*EpicToonFX.ETFXRotation end.*/

    /*EpicToonFX.ETFXRotation+spaceEnum start.*/
    Bridge.define("EpicToonFX.ETFXRotation.spaceEnum", {
        $kind: "nested enum",
        statics: {
            fields: {
                Local: 0,
                World: 1
            }
        }
    });
    /*EpicToonFX.ETFXRotation+spaceEnum end.*/

    /*EpicToonFX.ETFXTarget start.*/
    Bridge.define("EpicToonFX.ETFXTarget", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            hitParticle: null,
            respawnParticle: null,
            targetRenderer: null,
            targetCollider: null
        },
        methods: {
            /*EpicToonFX.ETFXTarget.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXTarget#Start", this ); }

                this.targetRenderer = this.GetComponent(UnityEngine.Renderer);
                this.targetCollider = this.GetComponent(UnityEngine.Collider);
            },
            /*EpicToonFX.ETFXTarget.Start end.*/

            /*EpicToonFX.ETFXTarget.SpawnTarget start.*/
            SpawnTarget: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXTarget#SpawnTarget", this ); }

                this.targetRenderer.enabled = true; //Shows the target
                this.targetCollider.enabled = true; //Enables the collider
                var respawnEffect = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.respawnParticle, this.transform.position.$clone(), this.transform.rotation.$clone()); //Spawns attached respawn effect
                this.Destroy(respawnEffect, 3.5); //Removes attached respawn effect after x seconds
            },
            /*EpicToonFX.ETFXTarget.SpawnTarget end.*/

            /*EpicToonFX.ETFXTarget.OnTriggerEnter start.*/
            OnTriggerEnter: function (col) {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXTarget#OnTriggerEnter", this ); }

                if (Bridge.referenceEquals(col.tag, "Missile")) {
                    if (UnityEngine.Object.op_Implicit(this.hitParticle)) {
                        //Debug.Log("Target hit!");
                        var destructibleEffect = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.hitParticle, this.transform.position.$clone(), this.transform.rotation.$clone()); // Spawns attached hit effect
                        this.Destroy(destructibleEffect, 2.0); // Removes hit effect after x seconds
                        this.targetRenderer.enabled = false; // Hides the target
                        this.targetCollider.enabled = false; // Disables target collider
                        this.StartCoroutine$1(this.Respawn()); // Sets timer for respawning the target
                    }
                }
            },
            /*EpicToonFX.ETFXTarget.OnTriggerEnter end.*/

            /*EpicToonFX.ETFXTarget.Respawn start.*/
            Respawn: function () {
if ( TRACE ) { TRACE( "EpicToonFX.ETFXTarget#Respawn", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(3);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.SpawnTarget();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*EpicToonFX.ETFXTarget.Respawn end.*/


        }
    });
    /*EpicToonFX.ETFXTarget end.*/

    /*ETFXProjectileScript start.*/
    Bridge.define("ETFXProjectileScript", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            impactParticle: null,
            projectileParticle: null,
            muzzleParticle: null,
            colliderRadius: 0,
            collideOffset: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ETFXProjectileScript#init", this ); }

                this.colliderRadius = 1.0;
                this.collideOffset = 0.15;
            }
        },
        methods: {
            /*ETFXProjectileScript.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ETFXProjectileScript#Start", this ); }

                this.projectileParticle = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.projectileParticle, this.transform.position.$clone(), this.transform.rotation.$clone());
                this.projectileParticle.transform.parent = this.transform;
                if (UnityEngine.Object.op_Implicit(this.muzzleParticle)) {
                    this.muzzleParticle = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.muzzleParticle, this.transform.position.$clone(), this.transform.rotation.$clone());
                    this.Destroy(this.muzzleParticle, 1.5); // 2nd parameter is lifetime of effect in seconds
                }
            },
            /*ETFXProjectileScript.Start end.*/

            /*ETFXProjectileScript.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "ETFXProjectileScript#FixedUpdate", this ); }

                if (this.GetComponent(UnityEngine.Rigidbody).velocity.length() !== 0) {
                    this.transform.rotation = new pc.Quat().setLookAt( this.GetComponent(UnityEngine.Rigidbody).velocity, pc.Vec3.UP ); // Sets rotation to look at direction of movement
                }

                var hit = { v : new UnityEngine.RaycastHit() };

                var radius; // Sets the radius of the collision detection
                if (UnityEngine.Object.op_Implicit(this.transform.GetComponent(UnityEngine.SphereCollider))) {
                    radius = this.transform.GetComponent(UnityEngine.SphereCollider).radius;
                } else {
                    radius = this.colliderRadius;
                }

                var direction = this.transform.GetComponent(UnityEngine.Rigidbody).velocity.$clone(); // Gets the direction of the projectile, used for collision detection
                if (this.transform.GetComponent(UnityEngine.Rigidbody).useGravity) {
                    direction = direction.$clone().add( UnityEngine.Physics.gravity.$clone().scale( UnityEngine.Time.deltaTime ) );
                } // Accounts for gravity if enabled
                direction = direction.clone().normalize().$clone();

                var detectionDistance = this.transform.GetComponent(UnityEngine.Rigidbody).velocity.length() * UnityEngine.Time.deltaTime; // Distance of collision detection for this frame

                if (UnityEngine.Physics.SphereCast$2(this.transform.position, radius, direction, hit, detectionDistance)) {
                    this.transform.position = hit.v.point.$clone().add( (hit.v.normal.$clone().scale( this.collideOffset )) ); // Move projectile to point of collision

                    var impactP = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.impactParticle, this.transform.position.$clone(), new pc.Quat().fromTo( pc.Vec3.UP.clone(), hit.v.normal )); // Spawns impact effect

                    var trails = this.GetComponentsInChildren(UnityEngine.ParticleSystem); // Gets a list of particle systems, as we need to detach the trails
                    //Component at [0] is that of the parent i.e. this object (if there is any)
                    for (var i = 1; i < trails.length; i = (i + 1) | 0) {
                        var trail = trails[i];

                        if (System.String.contains(trail.gameObject.name,"Trail")) {
                            trail.transform.SetParent(null); // Detaches the trail from the projectile
                            this.Destroy(trail.gameObject, 2.0); // Removes the trail after seconds
                        }
                    }

                    this.Destroy(this.projectileParticle, 3.0); // Removes particle effect after delay
                    this.Destroy(impactP, 3.5); // Removes impact effect after delay
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject); // Removes the projectile
                }
            },
            /*ETFXProjectileScript.FixedUpdate end.*/


        }
    });
    /*ETFXProjectileScript end.*/

    /*ETFXSceneManager start.*/
    Bridge.define("ETFXSceneManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            GUIHide: false,
            GUIHide2: false,
            GUIHide3: false,
            GUIHide4: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#init", this ); }

                this.GUIHide = false;
                this.GUIHide2 = false;
                this.GUIHide3 = false;
                this.GUIHide4 = false;
            }
        },
        methods: {
            /*ETFXSceneManager.LoadScene2DDemo start.*/
            LoadScene2DDemo: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadScene2DDemo", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_2ddemo");
            },
            /*ETFXSceneManager.LoadScene2DDemo end.*/

            /*ETFXSceneManager.LoadSceneCards start.*/
            LoadSceneCards: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneCards", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_cards");
            },
            /*ETFXSceneManager.LoadSceneCards end.*/

            /*ETFXSceneManager.LoadSceneCombat start.*/
            LoadSceneCombat: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneCombat", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_combat");
            },
            /*ETFXSceneManager.LoadSceneCombat end.*/

            /*ETFXSceneManager.LoadSceneDecals start.*/
            LoadSceneDecals: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneDecals", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_decals");
            },
            /*ETFXSceneManager.LoadSceneDecals end.*/

            /*ETFXSceneManager.LoadSceneDecals2 start.*/
            LoadSceneDecals2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneDecals2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_decals2");
            },
            /*ETFXSceneManager.LoadSceneDecals2 end.*/

            /*ETFXSceneManager.LoadSceneEmojis start.*/
            LoadSceneEmojis: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneEmojis", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_emojis");
            },
            /*ETFXSceneManager.LoadSceneEmojis end.*/

            /*ETFXSceneManager.LoadSceneEmojis2 start.*/
            LoadSceneEmojis2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneEmojis2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_emojis2");
            },
            /*ETFXSceneManager.LoadSceneEmojis2 end.*/

            /*ETFXSceneManager.LoadSceneExplosions start.*/
            LoadSceneExplosions: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneExplosions", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_explosions");
            },
            /*ETFXSceneManager.LoadSceneExplosions end.*/

            /*ETFXSceneManager.LoadSceneExplosions2 start.*/
            LoadSceneExplosions2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneExplosions2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_explosions2");
            },
            /*ETFXSceneManager.LoadSceneExplosions2 end.*/

            /*ETFXSceneManager.LoadSceneFire start.*/
            LoadSceneFire: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneFire", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_fire");
            },
            /*ETFXSceneManager.LoadSceneFire end.*/

            /*ETFXSceneManager.LoadSceneFire2 start.*/
            LoadSceneFire2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneFire2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_fire2");
            },
            /*ETFXSceneManager.LoadSceneFire2 end.*/

            /*ETFXSceneManager.LoadSceneFire3 start.*/
            LoadSceneFire3: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneFire3", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_fire3");
            },
            /*ETFXSceneManager.LoadSceneFire3 end.*/

            /*ETFXSceneManager.LoadSceneFireworks start.*/
            LoadSceneFireworks: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneFireworks", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_fireworks");
            },
            /*ETFXSceneManager.LoadSceneFireworks end.*/

            /*ETFXSceneManager.LoadSceneFlares start.*/
            LoadSceneFlares: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneFlares", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_flares");
            },
            /*ETFXSceneManager.LoadSceneFlares end.*/

            /*ETFXSceneManager.LoadSceneMagic start.*/
            LoadSceneMagic: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMagic", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_magic");
            },
            /*ETFXSceneManager.LoadSceneMagic end.*/

            /*ETFXSceneManager.LoadSceneMagic2 start.*/
            LoadSceneMagic2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMagic2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_magic2");
            },
            /*ETFXSceneManager.LoadSceneMagic2 end.*/

            /*ETFXSceneManager.LoadSceneMagic3 start.*/
            LoadSceneMagic3: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMagic3", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_magic3");
            },
            /*ETFXSceneManager.LoadSceneMagic3 end.*/

            /*ETFXSceneManager.LoadSceneMainDemo start.*/
            LoadSceneMainDemo: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMainDemo", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_maindemo");
            },
            /*ETFXSceneManager.LoadSceneMainDemo end.*/

            /*ETFXSceneManager.LoadSceneMissiles start.*/
            LoadSceneMissiles: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMissiles", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_missiles");
            },
            /*ETFXSceneManager.LoadSceneMissiles end.*/

            /*ETFXSceneManager.LoadScenePortals start.*/
            LoadScenePortals: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadScenePortals", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_portals");
            },
            /*ETFXSceneManager.LoadScenePortals end.*/

            /*ETFXSceneManager.LoadScenePortals2 start.*/
            LoadScenePortals2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadScenePortals2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_portals2");
            },
            /*ETFXSceneManager.LoadScenePortals2 end.*/

            /*ETFXSceneManager.LoadScenePowerups start.*/
            LoadScenePowerups: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadScenePowerups", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_powerups");
            },
            /*ETFXSceneManager.LoadScenePowerups end.*/

            /*ETFXSceneManager.LoadScenePowerups2 start.*/
            LoadScenePowerups2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadScenePowerups2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_powerups2");
            },
            /*ETFXSceneManager.LoadScenePowerups2 end.*/

            /*ETFXSceneManager.LoadSceneSparkles start.*/
            LoadSceneSparkles: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneSparkles", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_sparkles");
            },
            /*ETFXSceneManager.LoadSceneSparkles end.*/

            /*ETFXSceneManager.LoadSceneSwordCombat start.*/
            LoadSceneSwordCombat: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneSwordCombat", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_swordcombat");
            },
            /*ETFXSceneManager.LoadSceneSwordCombat end.*/

            /*ETFXSceneManager.LoadSceneSwordCombat2 start.*/
            LoadSceneSwordCombat2: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneSwordCombat2", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_swordcombat2");
            },
            /*ETFXSceneManager.LoadSceneSwordCombat2 end.*/

            /*ETFXSceneManager.LoadSceneMoney start.*/
            LoadSceneMoney: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneMoney", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_money");
            },
            /*ETFXSceneManager.LoadSceneMoney end.*/

            /*ETFXSceneManager.LoadSceneHealing start.*/
            LoadSceneHealing: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneHealing", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_healing");
            },
            /*ETFXSceneManager.LoadSceneHealing end.*/

            /*ETFXSceneManager.LoadSceneWind start.*/
            LoadSceneWind: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#LoadSceneWind", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("etfx_wind");
            },
            /*ETFXSceneManager.LoadSceneWind end.*/

            /*ETFXSceneManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ETFXSceneManager#Update", this ); }


                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.L)) {
                    this.GUIHide = !this.GUIHide;

                    if (this.GUIHide) {
                        UnityEngine.GameObject.Find("CanvasSceneSelect").GetComponent(UnityEngine.Canvas).enabled = false;
                    } else {
                        UnityEngine.GameObject.Find("CanvasSceneSelect").GetComponent(UnityEngine.Canvas).enabled = true;
                    }
                }
                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.J)) {
                    this.GUIHide2 = !this.GUIHide2;

                    if (this.GUIHide2) {
                        UnityEngine.GameObject.Find("Canvas").GetComponent(UnityEngine.Canvas).enabled = false;
                    } else {
                        UnityEngine.GameObject.Find("Canvas").GetComponent(UnityEngine.Canvas).enabled = true;
                    }
                }
                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.H)) {
                    this.GUIHide3 = !this.GUIHide3;

                    if (this.GUIHide3) {
                        UnityEngine.GameObject.Find("ParticleSysDisplayCanvas").GetComponent(UnityEngine.Canvas).enabled = false;
                    } else {
                        UnityEngine.GameObject.Find("ParticleSysDisplayCanvas").GetComponent(UnityEngine.Canvas).enabled = true;
                    }
                }
                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.K)) {
                    this.GUIHide4 = !this.GUIHide4;

                    if (this.GUIHide3) {
                        UnityEngine.GameObject.Find("CanvasTips").GetComponent(UnityEngine.Canvas).enabled = false;
                    } else {
                        UnityEngine.GameObject.Find("CanvasTips").GetComponent(UnityEngine.Canvas).enabled = true;
                    }
                }
            },
            /*ETFXSceneManager.Update end.*/


        }
    });
    /*ETFXSceneManager end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*ParticleEffectsLibrary start.*/
    Bridge.define("ParticleEffectsLibrary", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                GlobalAccess: null
            }
        },
        fields: {
            TotalEffects: 0,
            CurrentParticleEffectIndex: 0,
            CurrentParticleEffectNum: 0,
            ParticleEffectSpawnOffsets: null,
            ParticleEffectLifetimes: null,
            ParticleEffectPrefabs: null,
            effectNameString: null,
            currentActivePEList: null,
            spawnPosition: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#init", this ); }

                this.spawnPosition = new UnityEngine.Vector3();
                this.TotalEffects = 0;
                this.CurrentParticleEffectIndex = 0;
                this.CurrentParticleEffectNum = 0;
                this.effectNameString = "";
                this.spawnPosition = pc.Vec3.ZERO.clone();
            }
        },
        methods: {
            /*ParticleEffectsLibrary.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#Awake", this ); }

                ParticleEffectsLibrary.GlobalAccess = this;

                this.currentActivePEList = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();

                this.TotalEffects = this.ParticleEffectPrefabs.length;

                this.CurrentParticleEffectNum = 1;

                // Warn About Lengths of Arrays not matching
                if (this.ParticleEffectSpawnOffsets.length !== this.TotalEffects) {
                    UnityEngine.Debug.LogError$2("ParticleEffectsLibrary-ParticleEffectSpawnOffset: Not all arrays match length, double check counts.");
                }
                if (this.ParticleEffectPrefabs.length !== this.TotalEffects) {
                    UnityEngine.Debug.LogError$2("ParticleEffectsLibrary-ParticleEffectPrefabs: Not all arrays match length, double check counts.");
                }

                // Setup Starting PE Name String
                this.effectNameString = (this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex].name || "") + " (" + (Bridge.toString(this.CurrentParticleEffectNum) || "") + " of " + (Bridge.toString(this.TotalEffects) || "") + ")";
            },
            /*ParticleEffectsLibrary.Awake end.*/

            /*ParticleEffectsLibrary.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#Start", this ); }
 },
            /*ParticleEffectsLibrary.Start end.*/

            /*ParticleEffectsLibrary.GetCurrentPENameString start.*/
            GetCurrentPENameString: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#GetCurrentPENameString", this ); }

                return (this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex].name || "") + " (" + (Bridge.toString(this.CurrentParticleEffectNum) || "") + " of " + (Bridge.toString(this.TotalEffects) || "") + ")";
            },
            /*ParticleEffectsLibrary.GetCurrentPENameString end.*/

            /*ParticleEffectsLibrary.PreviousParticleEffect start.*/
            PreviousParticleEffect: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#PreviousParticleEffect", this ); }

                // Destroy Looping Particle Effects
                if (this.ParticleEffectLifetimes[this.CurrentParticleEffectIndex] === 0) {
                    if (this.currentActivePEList.Count > 0) {
                        for (var i = 0; i < this.currentActivePEList.Count; i = (i + 1) | 0) {
                            if (UnityEngine.Component.op_Inequality(this.currentActivePEList.getItem(i), null)) {
                                UnityEngine.MonoBehaviour.Destroy(this.currentActivePEList.getItem(i).gameObject);
                            }
                        }
                        this.currentActivePEList.clear();
                    }
                }

                // Select Previous Particle Effect
                if (this.CurrentParticleEffectIndex > 0) {
                    this.CurrentParticleEffectIndex = (this.CurrentParticleEffectIndex - 1) | 0;
                } else {
                    this.CurrentParticleEffectIndex = (this.TotalEffects - 1) | 0;
                }
                this.CurrentParticleEffectNum = (this.CurrentParticleEffectIndex + 1) | 0;

                // Update PE Name String
                this.effectNameString = (this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex].name || "") + " (" + (Bridge.toString(this.CurrentParticleEffectNum) || "") + " of " + (Bridge.toString(this.TotalEffects) || "") + ")";
            },
            /*ParticleEffectsLibrary.PreviousParticleEffect end.*/

            /*ParticleEffectsLibrary.NextParticleEffect start.*/
            NextParticleEffect: function () {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#NextParticleEffect", this ); }

                // Destroy Looping Particle Effects
                if (this.ParticleEffectLifetimes[this.CurrentParticleEffectIndex] === 0) {
                    if (this.currentActivePEList.Count > 0) {
                        for (var i = 0; i < this.currentActivePEList.Count; i = (i + 1) | 0) {
                            if (UnityEngine.Component.op_Inequality(this.currentActivePEList.getItem(i), null)) {
                                UnityEngine.MonoBehaviour.Destroy(this.currentActivePEList.getItem(i).gameObject);
                            }
                        }
                        this.currentActivePEList.clear();
                    }
                }

                // Select Next Particle Effect
                if (this.CurrentParticleEffectIndex < ((this.TotalEffects - 1) | 0)) {
                    this.CurrentParticleEffectIndex = (this.CurrentParticleEffectIndex + 1) | 0;
                } else {
                    this.CurrentParticleEffectIndex = 0;
                }
                this.CurrentParticleEffectNum = (this.CurrentParticleEffectIndex + 1) | 0;

                // Update PE Name String
                this.effectNameString = (this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex].name || "") + " (" + (Bridge.toString(this.CurrentParticleEffectNum) || "") + " of " + (Bridge.toString(this.TotalEffects) || "") + ")";
            },
            /*ParticleEffectsLibrary.NextParticleEffect end.*/

            /*ParticleEffectsLibrary.SpawnParticleEffect start.*/
            SpawnParticleEffect: function (positionInWorldToSpawn) {
if ( TRACE ) { TRACE( "ParticleEffectsLibrary#SpawnParticleEffect", this ); }

                // Spawn Currently Selected Particle Effect
                this.spawnPosition = positionInWorldToSpawn.$clone().add( this.ParticleEffectSpawnOffsets[this.CurrentParticleEffectIndex] );
                var newParticleEffect = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex], this.spawnPosition.$clone(), this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex].transform.rotation.$clone());
                newParticleEffect.name = System.String.concat("PE_", this.ParticleEffectPrefabs[this.CurrentParticleEffectIndex]);
                // Store Looping Particle Effects Systems
                if (this.ParticleEffectLifetimes[this.CurrentParticleEffectIndex] === 0) {
                    this.currentActivePEList.add(newParticleEffect.transform);
                }
                this.currentActivePEList.add(newParticleEffect.transform);
                // Destroy Particle Effect After Lifetime expired
                if (this.ParticleEffectLifetimes[this.CurrentParticleEffectIndex] !== 0) {
                    this.Destroy(newParticleEffect, this.ParticleEffectLifetimes[this.CurrentParticleEffectIndex]);
                }
            },
            /*ParticleEffectsLibrary.SpawnParticleEffect end.*/


        }
    });
    /*ParticleEffectsLibrary end.*/

    /*PEButtonScript start.*/
    Bridge.define("PEButtonScript", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IEventSystemHandler,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.IPointerExitHandler],
        fields: {
            myButton: null,
            ButtonType: 0
        },
        alias: [
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PEButtonScript#init", this ); }

                this.ButtonType = ButtonTypes.NotDefined;
            }
        },
        methods: {
            /*PEButtonScript.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "PEButtonScript#Start", this ); }

                this.myButton = this.gameObject.GetComponent(UnityEngine.UI.Button);
            },
            /*PEButtonScript.Start end.*/

            /*PEButtonScript.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "PEButtonScript#OnPointerEnter", this ); }

                // Used for Tooltip
                UICanvasManager.GlobalAccess.MouseOverButton = true;
                UICanvasManager.GlobalAccess.UpdateToolTip(this.ButtonType);
            },
            /*PEButtonScript.OnPointerEnter end.*/

            /*PEButtonScript.OnPointerExit start.*/
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "PEButtonScript#OnPointerExit", this ); }

                // Used for Tooltip
                UICanvasManager.GlobalAccess.MouseOverButton = false;
                UICanvasManager.GlobalAccess.ClearToolTip();
            },
            /*PEButtonScript.OnPointerExit end.*/

            /*PEButtonScript.OnButtonClicked start.*/
            OnButtonClicked: function () {
if ( TRACE ) { TRACE( "PEButtonScript#OnButtonClicked", this ); }

                // Button Click Actions
                UICanvasManager.GlobalAccess.UIButtonClick(this.ButtonType);
            },
            /*PEButtonScript.OnButtonClicked end.*/


        }
    });
    /*PEButtonScript end.*/

    /*Projects.Scripts.GamePlay.Building.CheckPoint start.*/
    Bridge.define("Projects.Scripts.GamePlay.Building.CheckPoint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reviveEffect: null,
            animation: null,
            collider: null,
            playSound: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.CheckPoint#init", this ); }

                this.playSound = true;
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.Building.CheckPoint.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.CheckPoint#OnTriggerEnter2D", this ); }

                if (!other.CompareTag("Player")) {
                    return;
                }
                Projects.Scripts.UIController.GamePlayController.Instance.SetCheckPoint(this, this.playSound);
                this.collider.enabled = false;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.animation, null)) {
                    this.animation.AnimationState.SetAnimation$1(0, "checked", false);
                }
            },
            /*Projects.Scripts.GamePlay.Building.CheckPoint.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.Building.CheckPoint.ShowEffect start.*/
            ShowEffect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.CheckPoint#ShowEffect", this ); }

                UnityEngine.GameObject.op_Inequality(this.reviveEffect, null) ? this.reviveEffect.SetActive(true) : null;
            },
            /*Projects.Scripts.GamePlay.Building.CheckPoint.ShowEffect end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Building.CheckPoint end.*/

    /*Projects.Scripts.GamePlay.Building.StartLevel start.*/
    Bridge.define("Projects.Scripts.GamePlay.Building.StartLevel", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.StartLevel#Instance#get", this ); }

                        return Projects.Scripts.GamePlay.Building.StartLevel._instance;
                    }
                }
            }
        },
        fields: {
            checkPoint: null,
            levelText: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Building.StartLevel.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.StartLevel#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(Projects.Scripts.GamePlay.Building.StartLevel._instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(Projects.Scripts.GamePlay.Building.StartLevel._instance.gameObject);
                }

                Projects.Scripts.GamePlay.Building.StartLevel._instance = this;
            },
            /*Projects.Scripts.GamePlay.Building.StartLevel.Awake end.*/

            /*Projects.Scripts.GamePlay.Building.StartLevel.Init start.*/
            Init: function (level) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Building.StartLevel#Init", this ); }

                //levelText.text = level;
                return this.checkPoint;
            },
            /*Projects.Scripts.GamePlay.Building.StartLevel.Init end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Building.StartLevel end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallAnimation start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallAnimation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeleton: null,
            idle: null,
            die: null,
            getHurt: null,
            drowning: null,
            revive: null,
            smile: null,
            mix: null,
            _controller: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.Init start.*/
            Init: function (controller) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#Init", this ); }

                this._controller = controller;
                var skin = "Base";
                this.SetSkin(skin);
                this.PlayIdle();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.Init end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayIdle start.*/
            PlayIdle: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayIdle", this ); }

                if (this._controller.IsDie()) {
                    return;
                }
                this.skeleton.state.SetAnimation$1(0, this.idle, true);
                //PlayMix();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayIdle end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlaySmile start.*/
            PlaySmile: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlaySmile", this ); }

                if (this._controller.IsDie()) {
                    return;
                }
                this.skeleton.state.SetAnimation$1(0, this.smile, true);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlaySmile end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayHurt start.*/
            PlayHurt: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayHurt", this ); }

                if (this._controller.IsDie()) {
                    return;
                }
                this.skeleton.state.SetEmptyAnimation(1, 0);
                this.skeleton.state.SetAnimation$1(0, this.getHurt, true);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayHurt end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayDie start.*/
            PlayDie: function (damageType, complete) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayDie", this ); }

                if (complete === void 0) { complete = null; }
                if (damageType === Projects.Scripts.Models.DamageType.Water) {
                    this.skeleton.state.SetEmptyAnimation(1, 0);
                    var entry = this.skeleton.state.SetAnimation$1(0, this.drowning, false);
                    entry.addComplete(Bridge.fn.bind(this, function (et) {
                        this.skeleton.state.SetAnimation$1(0, this.die, false);
                        this.StartCoroutine$1(this.Die(1.0, complete));
                    }));
                } else if (damageType === Projects.Scripts.Models.DamageType.Object || damageType === Projects.Scripts.Models.DamageType.Enemy) {
                    this.skeleton.state.SetAnimation$1(0, this.die, false);
                    this.StartCoroutine$1(this.Die(1.0, complete));
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayDie end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayRevive start.*/
            PlayRevive: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayRevive", this ); }

                if (this._controller.IsDie()) {
                    return;
                }
                var trackEntry = this.skeleton.state.SetAnimation$1(0, this.revive, false);
                trackEntry.addComplete(Bridge.fn.bind(this, function (et) {
                    this.PlayIdle();
                }));
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayRevive end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.Die start.*/
            Die: function (duration, complete) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#Die", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSecondsRealtime(duration);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    !Bridge.staticEquals(complete, null) ? complete() : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.Die end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayMix start.*/
            PlayMix: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#PlayMix", this ); }

                var r = UnityEngine.Random.Range(0, this.mix.length);
                var entry = this.skeleton.state.SetAnimation$1(1, this.mix[r], false);
                entry.addComplete(Bridge.fn.bind(this, function (trackEntry) {
                    this.PlayMix();
                }));
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.PlayMix end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.SetSkin start.*/
            SetSkin: function (skin) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAnimation#SetSkin", this ); }

                this.skeleton.initialSkinName = skin;
                this.skeleton.Initialize(true);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAnimation.SetSkin end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallAnimation end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallAttack start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallAttack", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            pauseDuration: 0,
            timeScale: 0,
            attackLayer: null,
            attackForce: null,
            _controller: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAttack#init", this ); }

                this.attackLayer = new UnityEngine.LayerMask();
                this.attackForce = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.Init start.*/
            Init: function (controller) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAttack#Init", this ); }

                this._controller = controller;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.Init end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.OnAttackEnemy start.*/
            OnAttackEnemy: function (coll) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAttack#OnAttackEnemy", this ); }

                if (!Truongtv.Utilities.Extended.IsInLayerMask(coll.gameObject, this.attackLayer.$clone())) {
                    return;
                }
                this._controller.SetForce(this.attackForce.$clone(), false);
                this.StopAllCoroutines();
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallAttackSound();
                this.StartCoroutine$1(this.AfterDamage());

            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.OnAttackEnemy end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.AfterDamage start.*/
            AfterDamage: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallAttack#AfterDamage", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    UnityEngine.Time.timeScale = this.timeScale;
                                        $enumerator.current = new UnityEngine.WaitForSecondsRealtime(this.pauseDuration);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.Time.timeScale = 1.0;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallAttack.AfterDamage end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallAttack end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallController start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Instance#get", this ); }

                        return Projects.Scripts.GamePlay.CharacterController.BallController._instance;
                    }
                }
            }
        },
        fields: {
            magnetic: null,
            movement: null,
            health: null,
            animation: null,
            attack: null,
            attackTransform: null,
            heartEffect: null,
            _touchDirection: 0,
            _holdJump: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#init", this ); }

                this._touchDirection = Projects.Scripts.Models.MoveDirection.None;
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(Projects.Scripts.GamePlay.CharacterController.BallController._instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(Projects.Scripts.GamePlay.CharacterController.BallController._instance.gameObject);
                }

                Projects.Scripts.GamePlay.CharacterController.BallController._instance = this;

            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Awake end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Start", this ); }

                this.magnetic.Init(this);
                this.movement.Init(this);
                this.health.Init(this);
                this.attack.Init(this);
                this.animation.Init(this);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Start end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Update", this ); }


                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftArrow)) {
                    this._touchDirection = Projects.Scripts.Models.MoveDirection.Left;
                }
                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightArrow)) {
                    this._touchDirection = Projects.Scripts.Models.MoveDirection.Right;
                }
                if (UnityEngine.Input.GetKey(UnityEngine.KeyCode.UpArrow)) {
                    this._holdJump = true;
                }
                if (UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode.LeftArrow)) {
                    this._touchDirection = Projects.Scripts.Models.MoveDirection.None;
                }
                if (UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode.RightArrow)) {
                    this._touchDirection = Projects.Scripts.Models.MoveDirection.None;
                }
                if (UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode.UpArrow)) {
                    this._holdJump = false;
                }

                if (Projects.Scripts.UIController.GamePlayController.Instance.gameState !== Projects.Scripts.Models.GameState.Playing || this.IsDie()) {
                    this._touchDirection = Projects.Scripts.Models.MoveDirection.None;

                }
                switch (this._touchDirection) {
                    case Projects.Scripts.Models.MoveDirection.None: 
                        this.movement.TouchMoveLeft(true);
                        this.movement.TouchMoveRight(true);
                        break;
                    case Projects.Scripts.Models.MoveDirection.Left: 
                        this.movement.TouchMoveLeft();
                        break;
                    case Projects.Scripts.Models.MoveDirection.Right: 
                        this.movement.TouchMoveRight();
                        break;
                }
                if (Projects.Scripts.UIController.GamePlayController.Instance.gameState !== Projects.Scripts.Models.GameState.Playing || this.IsDie()) {
                    return;
                }
                this.movement.TouchJump(!this._holdJump);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Update end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.CollectingCoin start.*/
            CollectingCoin: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#CollectingCoin", this ); }

                this.magnetic.CollectingCoin();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.CollectingCoin end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Collected start.*/
            Collected: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Collected", this ); }

                this.magnetic.Collected();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Collected end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.ActiveMagnet start.*/
            ActiveMagnet: function (active) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#ActiveMagnet", this ); }

                this.magnetic.ActiveMagnet(active);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.ActiveMagnet end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Damage start.*/
            Damage: function (damageType, damage, damageObj) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Damage", this ); }

                this.health.Damage(damageType, damage, damageObj);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Damage end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.IsDie start.*/
            IsDie: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#IsDie", this ); }

                return this.health.isDie;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.IsDie end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Revive start.*/
            Revive: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Revive", this ); }

                this.health.Revive();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Revive end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetForce start.*/
            SetForce: function (force, special) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#SetForce", this ); }

                if (special === void 0) { special = false; }
                this.movement.SetForce(force.$clone(), special);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetForce end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetForceInstant start.*/
            SetForceInstant: function (force) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#SetForceInstant", this ); }

                this.movement.SetForceInstant(force.$clone());
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetForceInstant end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.ActiveHeartEffect start.*/
            ActiveHeartEffect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#ActiveHeartEffect", this ); }

                this.heartEffect.SetActive(true);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.ActiveHeartEffect end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Win start.*/
            Win: function (target) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Win", this ); }

                Projects.Scripts.UIController.GamePlayController.Instance.gameState = Projects.Scripts.Models.GameState.End;
                this._touchDirection = Projects.Scripts.Models.MoveDirection.None;
                this._holdJump = false;
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallWinSound();
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayWinSound(function () {
                    Projects.Scripts.UIController.GamePlayController.Instance.Win();
                });
                this.animation.PlaySmile();
                this.GetComponent(UnityEngine.Rigidbody2D).isKinematic = true;
                this.GetComponent(UnityEngine.Rigidbody2D).velocity = pc.Vec2.ZERO.clone();
                this.GetComponent(UnityEngine.Collider2D).enabled = false;
                var sequence = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveX(this.transform, target.position.x, 1.6), DG.Tweening.Ease.OutBack));
                DG.Tweening.TweenSettingsExtensions.Join(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.transform, target.position.y, 1.6), DG.Tweening.Ease.OutBack));
                DG.Tweening.TweenSettingsExtensions.Join(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, 0, 1.0), DG.Tweening.Ease.Linear));
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, sequence, function () {

                });
                DG.Tweening.TweenExtensions.Play(DG.Tweening.Sequence, sequence);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Win end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.MoveLeft start.*/
            MoveLeft: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#MoveLeft", this ); }

                if (release === void 0) { release = false; }
                this._touchDirection = release ? Projects.Scripts.Models.MoveDirection.None : Projects.Scripts.Models.MoveDirection.Left;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.MoveLeft end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.MoveRight start.*/
            MoveRight: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#MoveRight", this ); }

                if (release === void 0) { release = false; }
                this._touchDirection = release ? Projects.Scripts.Models.MoveDirection.None : Projects.Scripts.Models.MoveDirection.Right;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.MoveRight end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.Jump start.*/
            Jump: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#Jump", this ); }

                if (release === void 0) { release = false; }
                this._holdJump = !release;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.Jump end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.CancelAllMove start.*/
            CancelAllMove: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#CancelAllMove", this ); }

                this._touchDirection = Projects.Scripts.Models.MoveDirection.None;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.CancelAllMove end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetCanDamage start.*/
            SetCanDamage: function (value) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#SetCanDamage", this ); }

                this.attackTransform.SetActive(value);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.SetCanDamage end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallController.TrySkin start.*/
            TrySkin: function (skin) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallController#TrySkin", this ); }


            },
            /*Projects.Scripts.GamePlay.CharacterController.BallController.TrySkin end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallController end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallHealth start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallHealth", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            maxHp: 0,
            currentHp: 0,
            damageForce: null,
            waterForce: null,
            damageEffect: null,
            icon: null,
            dieEffect: null,
            isDie: false,
            _inviolable: false,
            _controller: null,
            _firstTimeDieWithType: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#init", this ); }

                this.damageForce = new UnityEngine.Vector2();
                this.waterForce = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Init start.*/
            Init: function (controller) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#Init", this ); }

                this._controller = controller;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Init end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#Start", this ); }

                this.currentHp = this.maxHp;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Start end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Damage start.*/
            Damage: function (damageType, damage, damageObj) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#Damage", this ); }

                if (this.isDie) {
                    return;
                }
                if (this._inviolable) {
                    return;
                }
                this.currentHp = (this.currentHp - damage) | 0;
                Projects.Scripts.UIController.GamePlayController.Instance.BallDamaged(this.currentHp);
                if (this.currentHp > 0) {

                    if (damageObj.position.x < this.transform.position.x) {
                        if (damageType !== Projects.Scripts.Models.DamageType.Water) {
                            this._controller.SetForce(new pc.Vec2( Math.abs(this.damageForce.x), this.damageForce.y ), true);
                        } else {
                            this._controller.SetForce(new pc.Vec2( Math.abs(this.waterForce.x), this.waterForce.y ), true);
                        }
                    } else {
                        var force = new pc.Vec2( -Math.abs(this.damageForce.x), this.damageForce.y );
                        this._controller.SetForce(force.$clone(), true);
                    }
                    Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallDamagedSound();
                    this.SetInviolable();
                } else {
                    this.Die(damageType);
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Damage end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Die start.*/
            Die: function (damageType) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#Die", this ); }

                this.isDie = true;
                Projects.Scripts.UIController.GamePlayController.Instance.PauseWhenBallDie();
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallDieSound();
                this._controller.animation.PlayDie(damageType, Bridge.fn.bind(this, function () {
                    this.icon.SetActive(false);
                    this.dieEffect.SetActive(true);
                    Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallExplode();
                    this.StartCoroutine$1(this.DieComplete());
                }));
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Die end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.DieComplete start.*/
            DieComplete: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#DieComplete", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( this.dieEffect.activeSelf ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    Projects.Scripts.UIController.GamePlayController.Instance.BallDie();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.DieComplete end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Revive start.*/
            Revive: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#Revive", this ); }

                this.isDie = false;
                this.currentHp = this.maxHp;
                this.icon.SetActive(true);
                this.dieEffect.SetActive(false);
                this._controller.animation.PlayRevive();
                this._inviolable = true;
                var result = 0;
                this._controller.SetCanDamage(false);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.DOTween.To$2(function () {
                    return 0;
                }, function (x) {
                    result = x;
                }, 16, 1.0), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                    this.damageEffect.SetActive(result % 2 !== 0);
                })), Bridge.fn.bind(this, function () {
                    this._inviolable = false;
                    this._controller.animation.PlayIdle();
                    this._controller.SetCanDamage(true);
                }));
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.Revive end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.SetInviolable start.*/
            SetInviolable: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallHealth#SetInviolable", this ); }

                this._inviolable = true;
                var result = 0;
                this._controller.animation.PlayHurt();
                this._controller.SetCanDamage(false);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.DOTween.To$2(function () {
                    return 0;
                }, function (x) {
                    result = x;
                }, 16, 1.0), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                    this.damageEffect.SetActive(result % 2 !== 0);
                })), Bridge.fn.bind(this, function () {
                    this._inviolable = false;
                    this._controller.animation.PlayIdle();
                    this._controller.SetCanDamage(true);
                }));
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallHealth.SetInviolable end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallHealth end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallMagnetic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            magnetic: null,
            magnetEffect: null,
            _coinCollectCount: 0,
            _controller: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.Init start.*/
            Init: function (controller) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMagnetic#Init", this ); }

                this._controller = controller;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.Init end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.ActiveMagnet start.*/
            ActiveMagnet: function (active) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMagnetic#ActiveMagnet", this ); }

                this.magnetic.SetActive(active);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.ActiveMagnet end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.CollectingCoin start.*/
            CollectingCoin: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMagnetic#CollectingCoin", this ); }

                this._coinCollectCount = (this._coinCollectCount + 1) | 0;
                this.magnetEffect.SetActive(true);
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.CollectingCoin end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.Collected start.*/
            Collected: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMagnetic#Collected", this ); }

                this._coinCollectCount = (this._coinCollectCount - 1) | 0;
                if (this._coinCollectCount === 0) {
                    this.magnetEffect.SetActive(false);
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic.Collected end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallMovement start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.BallMovement", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            moveSpeed: 0,
            acceleration: 0,
            decceleration: 0,
            deccelTime: 0,
            icon: null,
            totalDisplay: null,
            moveDirection: 0,
            jumpForce: 0,
            jumpCutMultiple: 0,
            gravityScale: 0,
            fallGravityMultiple: 0,
            rigidbody2D: null,
            groundLayer: null,
            wallLayer: null,
            boxLayer: null,
            groundCheckPoint: null,
            ballRadius: 0,
            JumpCoyoteTime: 0,
            jumpBufferTime: 0,
            forcePushBox: 0,
            landingEffect: null,
            moveEffect: null,
            effectByForceTime: 0,
            _roll: 0,
            lastGroundedTime: 0,
            lastJumpTime: 0,
            countDeccelTime: 0,
            isJumping: false,
            isJumpButtonRelease: false,
            effectByForce: false,
            effectByForceCountTime: 0,
            _moveEffectSpawnRunning: false,
            _collisionWithWall: false,
            _controller: null,
            isGround: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#init", this ); }

                this.groundLayer = new UnityEngine.LayerMask();
                this.wallLayer = new UnityEngine.LayerMask();
                this.boxLayer = new UnityEngine.LayerMask();
                this.effectByForceTime = 0.5;
                this.isJumpButtonRelease = true;
                this.effectByForceCountTime = 0.5;
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.Init start.*/
            Init: function (controller) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#Init", this ); }

                this._controller = controller;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.Init end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#Update", this ); }

                if (this.CheckIsGrounded()) {
                    if (this.lastGroundedTime < 0.0) {
                        var obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, this.landingEffect);
                        obj.transform.SetParent(this.transform.parent);
                        obj.transform.localPosition = this.transform.localPosition.$clone().add( new pc.Vec3( 0, -0.6, 0.0 ) );
                        Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallLandingSound();
                    }
                    this.lastGroundedTime = this.JumpCoyoteTime;
                    if (!this._moveEffectSpawnRunning) {
                        this._moveEffectSpawnRunning = true;
                        this.InvokeRepeating("RunEffect", 0.0, 0.2);
                    }
                    this.rigidbody2D.gravityScale = this.gravityScale;
                } else {
                    this.lastGroundedTime -= UnityEngine.Time.deltaTime;
                    this._moveEffectSpawnRunning = false;
                    this.CancelInvoke$1("RunEffect");
                }
                if (UnityEngine.Object.op_Implicit(UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2.FromVector3(this.groundCheckPoint.position.$clone().add( new pc.Vec3( this.ballRadius * this.moveDirection, 0, 0.0 ) )), UnityEngine.LayerMask.op_Implicit(this.wallLayer.$clone())))) {
                    this._collisionWithWall = true;
                } else {
                    this._collisionWithWall = false;
                }


                if (this.rigidbody2D.velocity.y < 0) {
                    this.rigidbody2D.gravityScale = this.gravityScale * this.fallGravityMultiple;
                } else {
                    this.rigidbody2D.gravityScale = this.gravityScale;
                }



                if (!this.isJumpButtonRelease) {
                    this.lastJumpTime = this.jumpBufferTime;
                } else {
                    this.lastJumpTime -= UnityEngine.Time.deltaTime;
                }

                if (!this.effectByForce) {
                    if (this.rigidbody2D.velocity.y > 0 && this.isJumping && this.isJumpButtonRelease) {
                        this.rigidbody2D.AddForce(new pc.Vec2( pc.Vec2.UP.x, -pc.Vec2.UP.y ).scale( this.rigidbody2D.velocity.y ).scale( this.jumpCutMultiple ), UnityEngine.ForceMode2D.Impulse);
                        this.lastJumpTime = 0;
                    } else if (this.rigidbody2D.velocity.y < 0 && this.isJumping) {
                        this.isJumping = false;
                    }
                }



                if (this.effectByForce) {
                    this.effectByForceCountTime -= UnityEngine.Time.deltaTime;
                    if (this.effectByForceCountTime <= 0) {
                        this.effectByForce = false;
                    }

                } else {
                    if (!this._collisionWithWall) {
                        if (this.moveDirection !== Projects.Scripts.Models.MoveDirection.None) {
                            this.countDeccelTime = this.deccelTime;
                            if (this.rigidbody2D.velocity.x * this.moveDirection < this.moveSpeed) {
                                var velocity = this.rigidbody2D.velocity.$clone();
                                velocity.x += this.moveDirection * this.acceleration * UnityEngine.Time.fixedDeltaTime;
                                this.rigidbody2D.velocity = velocity.$clone();
                            }
                        } else {
                            this.countDeccelTime -= UnityEngine.Time.deltaTime;
                            if (this.countDeccelTime > 0) {
                                var velocity1 = this.rigidbody2D.velocity.$clone();
                                if (velocity1.x < 0) {
                                    velocity1.x += this.decceleration * UnityEngine.Time.deltaTime;
                                    if (velocity1.x > 0) {
                                        velocity1.x = 0;
                                    }
                                } else if (velocity1.x > 0) {
                                    velocity1.x -= this.decceleration * UnityEngine.Time.deltaTime;
                                    if (velocity1.x < 0) {
                                        velocity1.x = 0;
                                    }
                                }
                                this.rigidbody2D.velocity = velocity1.$clone();
                            }
                        }
                    }
                }

                if (Math.abs(this.rigidbody2D.velocity.x) < 1.0) {
                    this.RollEffect();
                } else {
                    this._roll = Projects.Scripts.Models.MoveDirection.None;
                    DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.Update end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.CheckIsGrounded start.*/
            CheckIsGrounded: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#CheckIsGrounded", this ); }

                return this.isGround;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.CheckIsGrounded end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#OnCollisionEnter2D", this ); }

                this.isGround = Truongtv.Utilities.Extended.IsInLayerMask(other.gameObject, this.groundLayer.$clone());
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.OnCollisionEnter2D end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.OnCollisionExit2D start.*/
            OnCollisionExit2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#OnCollisionExit2D", this ); }

                this.isGround = !Truongtv.Utilities.Extended.IsInLayerMask(other.gameObject, this.groundLayer.$clone());
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.OnCollisionExit2D end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchMoveLeft start.*/
            TouchMoveLeft: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchMoveLeft", this ); }

                if (release === void 0) { release = false; }
                if (release) {
                    this.moveDirection = Projects.Scripts.Models.MoveDirection.None;
                } else {
                    this.moveDirection = Projects.Scripts.Models.MoveDirection.Left;
                    var scale = this.transform.localScale.$clone();
                    this.totalDisplay.localScale = new pc.Vec3( Math.abs(scale.x) * this.moveDirection, scale.y, scale.z );
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchMoveLeft end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchMoveRight start.*/
            TouchMoveRight: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchMoveRight", this ); }

                if (release === void 0) { release = false; }
                if (release) {
                    this.moveDirection = Projects.Scripts.Models.MoveDirection.None;
                } else {
                    this.moveDirection = Projects.Scripts.Models.MoveDirection.Right;
                    var scale = this.transform.localScale.$clone();
                    this.totalDisplay.localScale = new pc.Vec3( Math.abs(scale.x) * this.moveDirection, scale.y, scale.z );
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchMoveRight end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchJump start.*/
            TouchJump: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#TouchJump", this ); }

                if (release === void 0) { release = false; }
                if (release) {
                    this.isJumpButtonRelease = true;
                } else {
                    this.isJumpButtonRelease = false;
                    this.lastJumpTime = this.jumpBufferTime;
                    if (this.lastGroundedTime > 0 && this.lastJumpTime > 0 && !this.isJumping && this.rigidbody2D.velocity.y < 4.0) {
                        var velocity = this.rigidbody2D.velocity.$clone();
                        velocity.y = this.jumpForce;
                        this.rigidbody2D.velocity = velocity.$clone();
                        this.lastGroundedTime = 0;
                        this.lastJumpTime = 0;
                        this.isJumping = true;
                        Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallJumpSound();
                    }
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.TouchJump end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.SetForce start.*/
            SetForce: function (force, special) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#SetForce", this ); }

                if (special === void 0) { special = false; }
                this.SetForceInstant(force.$clone());
                if (!special) {
                    return;
                }
                this.effectByForce = true;
                this.effectByForceCountTime = this.effectByForceTime;
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.SetForce end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.SetForceInstant start.*/
            SetForceInstant: function (force) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#SetForceInstant", this ); }

                this.rigidbody2D.velocity = force.$clone();
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.SetForceInstant end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.RollEffect start.*/
            RollEffect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#RollEffect", this ); }

                if (this.moveDirection === Projects.Scripts.Models.MoveDirection.Left) {
                    if (this._roll !== Projects.Scripts.Models.MoveDirection.Left) {
                        this._roll = Projects.Scripts.Models.MoveDirection.Left;
                        DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.icon, new pc.Vec3( 0, 0, -180.0 ), 0.75, DG.Tweening.RotateMode.FastBeyond360), true), DG.Tweening.Ease.Linear), -1, DG.Tweening.LoopType.Incremental);
                    }
                } else if (this.moveDirection === Projects.Scripts.Models.MoveDirection.Right) {
                    if (this._roll !== Projects.Scripts.Models.MoveDirection.Right) {
                        this._roll = Projects.Scripts.Models.MoveDirection.Right;
                        DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.icon, new pc.Vec3( 0, 0, -180.0 ), 0.75, DG.Tweening.RotateMode.FastBeyond360), true), DG.Tweening.Ease.Linear), -1, DG.Tweening.LoopType.Incremental);
                    }
                } else {
                    this._roll = Projects.Scripts.Models.MoveDirection.None;
                    DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.RollEffect end.*/

            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.RunEffect start.*/
            RunEffect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.BallMovement#RunEffect", this ); }

                if (this.moveDirection !== Projects.Scripts.Models.MoveDirection.None) {
                    var obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, this.moveEffect);
                    obj.transform.position = this.transform.position.$clone().add( new pc.Vec3( 0, -0.6, 0.0 ) );
                }
            },
            /*Projects.Scripts.GamePlay.CharacterController.BallMovement.RunEffect end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.BallMovement end.*/

    /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter start.*/
    Bridge.define("Projects.Scripts.GamePlay.CharacterController.FollowCharacter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            followTransform: null,
            offset: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.FollowCharacter#init", this ); }

                this.offset = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.CharacterController.FollowCharacter#Update", this ); }

                this.transform.position = this.followTransform.position.$clone().add( UnityEngine.Vector3.FromVector2(this.offset) );
                this.transform.eulerAngles = pc.Vec3.ZERO.clone();

            },
            /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter.Update end.*/


        }
    });
    /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter end.*/

    /*Projects.Scripts.GamePlay.Damage.DamageToBall start.*/
    Bridge.define("Projects.Scripts.GamePlay.Damage.DamageToBall", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            damageType: 0,
            firstTimeNoDamage: false,
            damage: 0
        },
        methods: {
            /*Projects.Scripts.GamePlay.Damage.DamageToBall.TriggerEnter start.*/
            TriggerEnter: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Damage.DamageToBall#TriggerEnter", this ); }

                if (System.String.equals(other.gameObject.tag, "Player")) {
                    Projects.Scripts.UIController.GamePlayController.Instance.ball.Damage(this.damageType, this.firstTimeNoDamage ? 0 : this.damage, this.transform);
                    if (this.firstTimeNoDamage) {
                        this.firstTimeNoDamage = false;
                    }
                }
            },
            /*Projects.Scripts.GamePlay.Damage.DamageToBall.TriggerEnter end.*/

            /*Projects.Scripts.GamePlay.Damage.DamageToBall.OnCollide start.*/
            OnCollide: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Damage.DamageToBall#OnCollide", this ); }

                if (System.String.equals(other.gameObject.tag, "Player")) {
                    Projects.Scripts.UIController.GamePlayController.Instance.ball.Damage(this.damageType, this.firstTimeNoDamage ? 0 : this.damage, this.transform);
                    if (this.firstTimeNoDamage) {
                        this.firstTimeNoDamage = false;
                    }
                }
            },
            /*Projects.Scripts.GamePlay.Damage.DamageToBall.OnCollide end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Damage.DamageToBall end.*/

    /*Projects.Scripts.GamePlay.Enemy.EnemyController start.*/
    Bridge.define("Projects.Scripts.GamePlay.Enemy.EnemyController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            icon: null,
            health: null,
            attack: null,
            dieEffect: null,
            damageEffect: null,
            anim: null,
            idle: null,
            die: null,
            idle_fx: null,
            move: null,
            chasing: null,
            fixedMovement: false,
            isFallDead: false,
            isStar: false,
            detectCamera: null,
            dieSfx: null,
            movingSfx: null,
            idleSfx: null,
            maxHp: 0,
            currentHp: 0,
            starPrefab: null,
            delaySpawnStar: 0,
            spawnDir: null,
            forceSpawn: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#init", this ); }

                this.spawnDir = new UnityEngine.Vector2();
                this.spawnDir = new pc.Vec2( 0, 1 );
                this.forceSpawn = 1.0;
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#Start", this ); }

                this.currentHp = this.maxHp;
                this.Idle();
                if (!this.fixedMovement) {
                    this.StartCoroutine$1(this.CheckVisible());
                }
            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Start end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.CheckVisible start.*/
            CheckVisible: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#CheckVisible", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.Component.op_Equality(this.detectCamera, null)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    $enumerator.current = new UnityEngine.WaitUntil(Bridge.fn.bind(this, function () {
                                            return this.detectCamera.isVisible;
                                        }));
                                        $step = 3;
                                        return true;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.CheckVisible end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Idle start.*/
            Idle: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#Idle", this ); }




                this.anim.AnimationState.SetAnimation$1(0, this.idle, true);

                if (!System.String.isNullOrEmpty(this.idle_fx)) {
                    this.anim.AnimationState.SetAnimation$1(1, this.idle_fx, true);
                }

            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Idle end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Flip start.*/
            Flip: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#Flip", this ); }

                this.attack.transform.localScale = new pc.Vec3( -this.attack.transform.localScale.x, this.attack.transform.localScale.y, 0 );
                this.health.transform.localScale = new pc.Vec3( -this.health.transform.localScale.x, this.health.transform.localScale.y, 0 );
                this.anim.Skeleton.ScaleX = -this.anim.Skeleton.ScaleX;

            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Flip end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (coll) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#OnCollisionEnter2D", this ); }

                if (System.String.equals(coll.collider.tag, "Player")) {
                    // var healthCollider = health.GetComponent<Collider2D>();
                    // if (Physics2D.Raycast(coll.transform.position - new Vector3(0,GamePlayController.Instance.ball.GetBallRadius(),0),)
                    // {
                    if (UnityEngine.Component.op_Inequality(this.damageEffect, null)) {
                        this.damageEffect.gameObject.SetActive(true);
                    }

                    this.currentHp = (this.currentHp - 1) | 0;
                    if (this.currentHp === 0) {
                        this.Die();
                        this.GetComponent(UnityEngine.Collider2D).enabled = false;
                    }

                    // }
                }
            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.OnCollisionEnter2D end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.ReachPlayer start.*/
            ReachPlayer: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#ReachPlayer", this ); }
 },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.ReachPlayer end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Die start.*/
            Die: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#Die", this ); }


                // if (dieSfx)
                // {
                //     audio?.Play(dieSfx);
                // }
                this.attack.SetActive(false);
                this.health.SetActive(false);

                var body = this.GetComponentInChildren(UnityEngine.Rigidbody2D);
                if (UnityEngine.Object.op_Implicit(body)) {
                    body.gameObject.SetActive(false);
                }


                this.anim.AnimationState.ClearTrack(1);
                this.anim.AnimationState.SetAnimation$1(0, this.die, false).addComplete(Bridge.fn.bind(this, function (entry) {
                    if (this.isFallDead) {
                        if (this.isStar) {
                            this.StartCoroutine$1(this.SpawnStar());
                        }

                        var speed = 10;
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.icon.transform, -10, speed), true), DG.Tweening.Ease.InSine), Bridge.fn.bind(this, function () {
                            this.icon.SetActive(false);
                        }));
                    } else {
                        this.icon.SetActive(false);
                        if (this.isStar) {
                            this.StartCoroutine$1(this.SpawnStar());
                        }
                    }
                }));
                if (UnityEngine.Component.op_Inequality(this.dieEffect, null)) {
                    this.dieEffect.gameObject.SetActive(true);
                }
            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.Die end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.SpawnStar start.*/
            SpawnStar: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#SpawnStar", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    obj,
                    star,
                    rb,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(this.delaySpawnStar);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    obj = UnityEngine.Object.Instantiate$2(UnityEngine.GameObject, this.starPrefab, this.icon.transform.position.$clone().add( new pc.Vec3( 0, 2.0, 0 ) ), pc.Quat.IDENTITY.clone());
                                        $enumerator.current = new UnityEngine.WaitUntil(function () {
                                            return UnityEngine.Object.op_Implicit(obj);
                                        });
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    star = obj.GetComponent(Projects.Scripts.GamePlay.Item.Star);
                                        if (UnityEngine.Object.op_Implicit(star)) {
                                            star.collider.isTrigger = false;
                                            rb = star.collider.gameObject.AddComponent(UnityEngine.Rigidbody2D);
                                            rb.AddForce(this.spawnDir.$clone().scale( this.forceSpawn ), UnityEngine.ForceMode2D.Impulse);
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.SpawnStar end.*/

            /*Projects.Scripts.GamePlay.Enemy.EnemyController.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Enemy.EnemyController#OnDrawGizmos", this ); }
 },
            /*Projects.Scripts.GamePlay.Enemy.EnemyController.OnDrawGizmos end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Enemy.EnemyController end.*/

    /*Projects.Scripts.GamePlay.Item.Cage start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.Cage", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            ballImprisoned: null,
            startAnimation: null,
            rescueAnimation: null,
            trySkinName: null,
            cageSkeleton: null,
            cageBreakAnim: null,
            collider: null,
            triggerLayer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Cage#init", this ); }

                this.triggerLayer = new UnityEngine.LayerMask();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.Cage.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Cage#Start", this ); }

                this.OnValueChange();
            },
            /*Projects.Scripts.GamePlay.Item.Cage.Start end.*/

            /*Projects.Scripts.GamePlay.Item.Cage.OnValueChange start.*/
            OnValueChange: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Cage#OnValueChange", this ); }

                this.ballImprisoned.initialSkinName = this.trySkinName;
                this.ballImprisoned.Initialize(true);
                this.ballImprisoned.AnimationState.SetAnimation$1(0, this.startAnimation, true);
            },
            /*Projects.Scripts.GamePlay.Item.Cage.OnValueChange end.*/

            /*Projects.Scripts.GamePlay.Item.Cage.GetAllSkinName start.*/
            GetAllSkinName: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Cage#GetAllSkinName", this ); }

                var $t, $t1;
                var result = new (System.Collections.Generic.List$1(System.String)).ctor();
                var totalSkin = this.ballImprisoned.SkeletonDataAsset.GetSkeletonData(true).Skins.Items;
                $t = Bridge.getEnumerator(totalSkin);
                try {
                    while ($t.moveNext()) {
                        var skin = $t.Current;
                        result.add(($t1 = System.String.split(skin.Name, [95].map(function (i) {{ return String.fromCharCode(i); }})))[0]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                result.remove("default");
                return result;
            },
            /*Projects.Scripts.GamePlay.Item.Cage.GetAllSkinName end.*/

            /*Projects.Scripts.GamePlay.Item.Cage.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (collider2D) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Cage#OnTriggerEnter2D", this ); }

                if (!Truongtv.Utilities.Extended.IsInLayerMask(collider2D.gameObject, this.triggerLayer.$clone())) {
                    return;
                }
                this.collider.enabled = false;
                this.cageSkeleton.state.SetAnimation$1(0, this.cageBreakAnim, false);
                this.ballImprisoned.state.SetAnimation$1(0, this.rescueAnimation, true);
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayRescueSound();
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayCageBreakSound();

            },
            /*Projects.Scripts.GamePlay.Item.Cage.OnTriggerEnter2D end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.Cage end.*/

    /*Projects.Scripts.GamePlay.Item.Coin start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.Coin", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            icon: null,
            effect: null,
            collider: null,
            mask: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#init", this ); }

                this.mask = new UnityEngine.LayerMask();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.Coin.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#Start", this ); }

                this.collider = this.GetComponent(UnityEngine.Collider2D);
            },
            /*Projects.Scripts.GamePlay.Item.Coin.Start end.*/

            /*Projects.Scripts.GamePlay.Item.Coin.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#OnTriggerEnter2D", this ); }

                this.TriggerEnter(other);
            },
            /*Projects.Scripts.GamePlay.Item.Coin.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.Item.Coin.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#Update", this ); }

                if (Projects.Scripts.UIController.GamePlayController.Instance.IsMagnetActive()) {
                    var distance = UnityEngine.Vector2.FromVector3(Projects.Scripts.UIController.GamePlayController.Instance.ball.transform.position.$clone()).sub( UnityEngine.Vector2.FromVector3(this.transform.position) ).length();
                    if (distance <= 4 && this.collider.enabled) {
                        this.collider.enabled = false;
                        var duration = 0.5;
                        var tween = DG.Tweening.ShortcutExtensions.DOMove(this.transform, Projects.Scripts.UIController.GamePlayController.Instance.ball.transform.position.$clone(), duration);
                        Projects.Scripts.UIController.GamePlayController.Instance.SetCollectingCurrency();
                        DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), tween, function () {
                            duration -= DG.Tweening.TweenExtensions.Elapsed(tween);
                            if (duration > 0) {
                                tween.ChangeEndValue$3(Projects.Scripts.UIController.GamePlayController.Instance.ball.transform.position.$clone(), duration, true);
                            }

                        });
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), tween, Bridge.fn.bind(this, function () {
                            Projects.Scripts.UIController.GamePlayController.Instance.SetCollectedCurrency();
                            this.OnCollect();
                        }));
                    }
                }
            },
            /*Projects.Scripts.GamePlay.Item.Coin.Update end.*/

            /*Projects.Scripts.GamePlay.Item.Coin.TriggerEnter start.*/
            TriggerEnter: function (collider2D) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#TriggerEnter", this ); }

                if (!Truongtv.Utilities.Extended.IsInLayerMask(collider2D.gameObject, this.mask.$clone())) {
                    return;
                }
                this.collider.enabled = false;
                if (Projects.Scripts.UIController.GamePlayController.Instance.IsMagnetActive()) {
                    var duration = 0.5;
                    var tween = DG.Tweening.ShortcutExtensions.DOMove(this.transform, collider2D.transform.position.$clone(), duration);
                    Projects.Scripts.UIController.GamePlayController.Instance.SetCollectingCurrency();
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), tween, function () {
                        duration -= DG.Tweening.TweenExtensions.Elapsed(tween);
                        if (duration > 0) {
                            tween.ChangeEndValue$3(collider2D.transform.position.$clone(), duration, true);
                        }

                    });
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), tween, Bridge.fn.bind(this, function () {
                        Projects.Scripts.UIController.GamePlayController.Instance.SetCollectedCurrency();
                        this.OnCollect();
                    }));
                } else {
                    this.OnCollect();
                }


            },
            /*Projects.Scripts.GamePlay.Item.Coin.TriggerEnter end.*/

            /*Projects.Scripts.GamePlay.Item.Coin.OnCollect start.*/
            OnCollect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Coin#OnCollect", this ); }

                var value = 100;
                Projects.Scripts.UIController.GamePlayController.Instance.CollectCoin(value, this.icon.transform);
                this.effect.transform.position = this.icon.transform.position.$clone();
                this.effect.SetActive(true);
                this.icon.SetActive(false);
            },
            /*Projects.Scripts.GamePlay.Item.Coin.OnCollect end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.Coin end.*/

    /*Projects.Scripts.GamePlay.Item.HeartItem start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.HeartItem", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            watchAd: false,
            icon: null,
            adsIcon: null,
            container: null,
            effect: null,
            skeleton: null,
            idleAnim: null,
            triggerAnim: null,
            collider: null,
            audio: null,
            stay: null,
            move: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.HeartItem.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.HeartItem#Start", this ); }

                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.icon, 0.5, 1.0), true), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);
                this.skeleton.state.SetAnimation$1(0, this.idleAnim, true);
                this.audio.Play$1(this.stay, true);
            },
            /*Projects.Scripts.GamePlay.Item.HeartItem.Start end.*/

            /*Projects.Scripts.GamePlay.Item.HeartItem.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (coll) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.HeartItem#OnTriggerEnter2D", this ); }

                Projects.Scripts.UIController.GamePlayController.Instance.CollectLife(1, this.icon);
                this.container.gameObject.SetActive(false);
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallCollectHeart();
                this.skeleton.state.SetAnimation$1(0, this.triggerAnim, true);
                this.collider.enabled = false;
                this.effect.SetActive(true);
                DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.icon, 100.0, 5.0), 1.0), true), true), DG.Tweening.Ease.OutSine), Bridge.fn.bind(this, function () {
                    this.audio.Play$1(this.move);
                }));
            },
            /*Projects.Scripts.GamePlay.Item.HeartItem.OnTriggerEnter2D end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.HeartItem end.*/

    /*Projects.Scripts.GamePlay.Item.MagnetItem start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.MagnetItem", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            icon: null,
            adsIcon: null,
            container: null,
            effect: null,
            skeleton: null,
            idleAnim: null,
            triggerAnim: null,
            collider: null,
            audio: null,
            stay: null,
            move: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.MagnetItem.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.MagnetItem#Start", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.icon, 0.5, 1.0), true), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);

                this.skeleton.state.SetAnimation$1(0, this.idleAnim, true);
                this.audio.Play$1(this.stay, true);
                this.collider = this.GetComponent(UnityEngine.Collider2D);
            },
            /*Projects.Scripts.GamePlay.Item.MagnetItem.Start end.*/

            /*Projects.Scripts.GamePlay.Item.MagnetItem.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.MagnetItem#OnTriggerEnter2D", this ); }

                this.TriggerEnter(other);
            },
            /*Projects.Scripts.GamePlay.Item.MagnetItem.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.Item.MagnetItem.TriggerEnter start.*/
            TriggerEnter: function (coll) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.MagnetItem#TriggerEnter", this ); }

                Projects.Scripts.UIController.GamePlayController.Instance.CollectMagnet(this.icon);
                this.skeleton.state.SetAnimation$1(0, this.triggerAnim, true);
                this.collider.enabled = false;
                this.effect.SetActive(true);
                this.container.gameObject.SetActive(false);
                DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.icon, 100.0, 5.0), 1.0), true), true), DG.Tweening.Ease.OutSine), Bridge.fn.bind(this, function () {
                    this.audio.Play$1(this.move);
                }));
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallCollectMagnet();
            },
            /*Projects.Scripts.GamePlay.Item.MagnetItem.TriggerEnter end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.MagnetItem end.*/

    /*Projects.Scripts.GamePlay.Item.Star start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.Star", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            icon: null,
            effect: null,
            collider: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.Star.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Star#Start", this ); }

                this.collider = this.GetComponent(UnityEngine.Collider2D);
            },
            /*Projects.Scripts.GamePlay.Item.Star.Start end.*/

            /*Projects.Scripts.GamePlay.Item.Star.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Star#OnTriggerEnter2D", this ); }

                this.TriggerEnter(other);
            },
            /*Projects.Scripts.GamePlay.Item.Star.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.Item.Star.TriggerEnter start.*/
            TriggerEnter: function (collider2D) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Star#TriggerEnter", this ); }

                if (collider2D.gameObject.layer === 9) {
                    return;
                }
                this.collider.enabled = false;
                this.OnCollect();
            },
            /*Projects.Scripts.GamePlay.Item.Star.TriggerEnter end.*/

            /*Projects.Scripts.GamePlay.Item.Star.OnCollect start.*/
            OnCollect: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Star#OnCollect", this ); }

                Projects.Scripts.UIController.GamePlayController.Instance.CollectStar(this.icon.transform);
                this.effect.transform.position = this.icon.transform.position.$clone();
                this.effect.SetActive(true);
                this.icon.SetActive(false);
            },
            /*Projects.Scripts.GamePlay.Item.Star.OnCollect end.*/

            /*Projects.Scripts.GamePlay.Item.Star.OnCollide start.*/
            OnCollide: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.Star#OnCollide", this ); }

                if (other.gameObject.layer !== 9 && other.transform.CompareTag("Player")) {
                    this.collider.enabled = false;
                    this.OnCollect();
                }
            },
            /*Projects.Scripts.GamePlay.Item.Star.OnCollide end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.Star end.*/

    /*Projects.Scripts.GamePlay.Item.TrySkinItem start.*/
    Bridge.define("Projects.Scripts.GamePlay.Item.TrySkinItem", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            icon: null,
            skin: null,
            adsIcon: null,
            container: null,
            effect: null,
            _trySkinName: null,
            collider: null,
            audio: null,
            stay: null,
            move: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.OnValueChange start.*/
            OnValueChange: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.TrySkinItem#OnValueChange", this ); }

                if (!System.String.isNullOrEmpty(this._trySkinName)) {
                    this.skin.initialSkinName = this._trySkinName;
                    this.skin.Initialize(true);

                }
            },
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.OnValueChange end.*/

            /*Projects.Scripts.GamePlay.Item.TrySkinItem.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.TrySkinItem#Start", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.icon, 0.5, 1.0), true), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);
                this.OnValueChange();
                this.audio.Play$1(this.stay, true);
                this.collider = this.GetComponent(UnityEngine.Collider2D);
            },
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.Start end.*/

            /*Projects.Scripts.GamePlay.Item.TrySkinItem.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.TrySkinItem#OnTriggerEnter2D", this ); }

                this.TrySkin();
            },
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.Item.TrySkinItem.TrySkin start.*/
            TrySkin: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.TrySkinItem#TrySkin", this ); }

                this.Active();
            },
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.TrySkin end.*/

            /*Projects.Scripts.GamePlay.Item.TrySkinItem.Active start.*/
            Active: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Item.TrySkinItem#Active", this ); }

                this.effect.SetActive(true);
                UnityEngine.Object.Destroy(this.collider);
                this.container.gameObject.SetActive(false);
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallTrySkin();
                Projects.Scripts.UIController.GamePlayController.Instance.ball.animation.SetSkin(this._trySkinName);
                Projects.Scripts.UIController.GamePlayController.Instance.SetSkin(this._trySkinName);

                DG.Tweening.ShortcutExtensions.DOKill(this.icon);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.icon, 100.0, 5.0), 1.0), true), true), DG.Tweening.Ease.OutSine), Bridge.fn.bind(this, function () {
                    this.audio.Play$1(this.move);
                })), Bridge.fn.bind(this, function () {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }));
            },
            /*Projects.Scripts.GamePlay.Item.TrySkinItem.Active end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Item.TrySkinItem end.*/

    /*Projects.Scripts.GamePlay.ObjectCollision start.*/
    Bridge.define("Projects.Scripts.GamePlay.ObjectCollision", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            collisionEnter2DEvent: null,
            collisionStay2DEvent: null,
            collisionExit2DEvent: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectCollision#OnCollisionEnter2D", this ); }

                this.collisionEnter2DEvent != null ? this.collisionEnter2DEvent.Invoke(other) : null;
            },
            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionEnter2D end.*/

            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionExit2D start.*/
            OnCollisionExit2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectCollision#OnCollisionExit2D", this ); }

                this.collisionExit2DEvent != null ? this.collisionExit2DEvent.Invoke(other) : null;
            },
            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionExit2D end.*/

            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionStay2D start.*/
            OnCollisionStay2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectCollision#OnCollisionStay2D", this ); }

                this.collisionStay2DEvent != null ? this.collisionStay2DEvent.Invoke(other) : null;
            },
            /*Projects.Scripts.GamePlay.ObjectCollision.OnCollisionStay2D end.*/


        }
    });
    /*Projects.Scripts.GamePlay.ObjectCollision end.*/

    /*Projects.Scripts.GamePlay.ObjectTrigger start.*/
    Bridge.define("Projects.Scripts.GamePlay.ObjectTrigger", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            triggerEnter2DEvent: null,
            triggerStay2DEvent: null,
            triggerExit2DEvent: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerEnter2D", this ); }

                this.triggerEnter2DEvent.Invoke(other);
            },
            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerEnter2D end.*/

            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerExit2D start.*/
            OnTriggerExit2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerExit2D", this ); }

                this.triggerExit2DEvent.Invoke(other);
            },
            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerExit2D end.*/

            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerStay2D start.*/
            OnTriggerStay2D: function (other) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ObjectTrigger#OnTriggerStay2D", this ); }

                this.triggerStay2DEvent.Invoke(other);
            },
            /*Projects.Scripts.GamePlay.ObjectTrigger.OnTriggerStay2D end.*/


        }
    });
    /*Projects.Scripts.GamePlay.ObjectTrigger end.*/

    /*Projects.Scripts.GamePlay.ParticleCallback start.*/
    Bridge.define("Projects.Scripts.GamePlay.ParticleCallback", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            completeEvent: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.ParticleCallback.OnParticleSystemStopped start.*/
            OnParticleSystemStopped: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.ParticleCallback#OnParticleSystemStopped", this ); }

                this.completeEvent.Invoke();
            },
            /*Projects.Scripts.GamePlay.ParticleCallback.OnParticleSystemStopped end.*/


        }
    });
    /*Projects.Scripts.GamePlay.ParticleCallback end.*/

    /*Projects.Scripts.GamePlay.Platform.Gate start.*/
    Bridge.define("Projects.Scripts.GamePlay.Platform.Gate", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            target: null,
            gateLight: null,
            collider: null,
            ballLayer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Platform.Gate#init", this ); }

                this.ballLayer = new UnityEngine.LayerMask();
            }
        },
        methods: {
            /*Projects.Scripts.GamePlay.Platform.Gate.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (collider2D) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Platform.Gate#OnTriggerEnter2D", this ); }

                if (!Truongtv.Utilities.Extended.IsInLayerMask(collider2D.gameObject, this.ballLayer.$clone())) {
                    return;
                }
                this.collider.enabled = false;
                if (UnityEngine.Object.op_Implicit(this.gateLight)) {
                    this.gateLight.SetActive(true);
                }
                Projects.Scripts.UIController.GamePlayController.Instance.ball.Win(this.target);
            },
            /*Projects.Scripts.GamePlay.Platform.Gate.OnTriggerEnter2D end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Platform.Gate end.*/

    /*Projects.Scripts.GamePlay.Sound.SoundInGameManager start.*/
    Bridge.define("Projects.Scripts.GamePlay.Sound.SoundInGameManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#Instance#get", this ); }

                        return Projects.Scripts.GamePlay.Sound.SoundInGameManager._instance;
                    }
                }
            }
        },
        fields: {
            soundManager: null,
            win: null,
            lose: null,
            bgm: null,
            bossFight: null,
            ballTrySkin: null,
            ballLanding: null,
            ballHurt: null,
            ballAttack: null,
            ballDie: null,
            ballCollectCoin: null,
            ballCollectStar: null,
            ballCollectHeart: null,
            ballCollectMagnet: null,
            ballWin: null,
            ballExplode: null,
            ballInCheckPoint: null,
            ballRevive: null,
            jumpClips: null,
            spring: null,
            cageBreakSound: null,
            ballRescueSound: null
        },
        methods: {
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(Projects.Scripts.GamePlay.Sound.SoundInGameManager._instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(Projects.Scripts.GamePlay.Sound.SoundInGameManager._instance.gameObject);
                }

                Projects.Scripts.GamePlay.Sound.SoundInGameManager._instance = this;
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.Awake end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallJumpSound start.*/
            PlayBallJumpSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallJumpSound", this ); }

                var r = UnityEngine.Random.Range(0, this.jumpClips.length);
                this.soundManager.PlaySfx(this.jumpClips[r]);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallJumpSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallLandingSound start.*/
            PlayBallLandingSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallLandingSound", this ); }

                this.soundManager.PlaySfx(this.ballLanding);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallLandingSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallDamagedSound start.*/
            PlayBallDamagedSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallDamagedSound", this ); }

                this.soundManager.PlaySfx(this.ballHurt);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallDamagedSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallAttackSound start.*/
            PlayBallAttackSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallAttackSound", this ); }

                this.soundManager.PlaySfx(this.ballAttack);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallAttackSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallDieSound start.*/
            PlayBallDieSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallDieSound", this ); }

                this.soundManager.PlaySfx(this.ballDie);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallDieSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectCoin start.*/
            PlayBallCollectCoin: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectCoin", this ); }

                this.soundManager.PlaySfx(this.ballCollectCoin);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectCoin end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectStar start.*/
            PlayBallCollectStar: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectStar", this ); }

                this.soundManager.PlaySfx(this.ballCollectStar);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectStar end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectHeart start.*/
            PlayBallCollectHeart: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectHeart", this ); }

                this.soundManager.PlaySfx(this.ballCollectHeart);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectHeart end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectMagnet start.*/
            PlayBallCollectMagnet: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallCollectMagnet", this ); }

                this.soundManager.PlaySfx(this.ballCollectMagnet);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallCollectMagnet end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallTrySkin start.*/
            PlayBallTrySkin: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallTrySkin", this ); }

                this.soundManager.PlaySfx(this.ballTrySkin);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallTrySkin end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallWinSound start.*/
            PlayBallWinSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallWinSound", this ); }

                this.soundManager.PlaySfx(this.ballWin);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallWinSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallExplode start.*/
            PlayBallExplode: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallExplode", this ); }

                this.soundManager.PlaySfx(this.ballExplode);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallExplode end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallInCheckPoint start.*/
            PlayBallInCheckPoint: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallInCheckPoint", this ); }

                this.soundManager.PlaySfx(this.ballInCheckPoint);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallInCheckPoint end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallRevive start.*/
            PlayBallRevive: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBallRevive", this ); }

                this.soundManager.PlaySfx(this.ballRevive);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBallRevive end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBgmSound start.*/
            PlayBgmSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBgmSound", this ); }

                var r = UnityEngine.Random.Range(0, this.bgm.length);
                if (UnityEngine.Object.op_Implicit(ThirdParties.Truongtv.SoundManager.Bgm.Instance)) {
                    ThirdParties.Truongtv.SoundManager.Bgm.Instance.Play(this.bgm[r]);
                }
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBgmSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBossFightSound start.*/
            PlayBossFightSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayBossFightSound", this ); }

                var r = UnityEngine.Random.Range(0, this.bossFight.length);
                if (UnityEngine.Object.op_Implicit(ThirdParties.Truongtv.SoundManager.Bgm.Instance)) {
                    ThirdParties.Truongtv.SoundManager.Bgm.Instance.Play(this.bossFight[r]);
                }
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayBossFightSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayLoseSound start.*/
            PlayLoseSound: function (complete) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayLoseSound", this ); }

                ThirdParties.Truongtv.SoundManager.Bgm.Instance.Stop$1();
                this.soundManager.PlaySfx(this.lose, false, 0.0, complete);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayLoseSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayWinSound start.*/
            PlayWinSound: function (complete) {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayWinSound", this ); }

                ThirdParties.Truongtv.SoundManager.Bgm.Instance.Stop$1();
                this.soundManager.PlaySfx(this.win, false, 0.0, complete);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayWinSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlaySpringSound start.*/
            PlaySpringSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlaySpringSound", this ); }

                this.soundManager.PlaySfx(this.spring);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlaySpringSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayCageBreakSound start.*/
            PlayCageBreakSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayCageBreakSound", this ); }

                this.soundManager.PlaySfx(this.cageBreakSound);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayCageBreakSound end.*/

            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayRescueSound start.*/
            PlayRescueSound: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.GamePlay.Sound.SoundInGameManager#PlayRescueSound", this ); }

                this.soundManager.PlaySfx(this.ballRescueSound);
            },
            /*Projects.Scripts.GamePlay.Sound.SoundInGameManager.PlayRescueSound end.*/


        }
    });
    /*Projects.Scripts.GamePlay.Sound.SoundInGameManager end.*/

    /*Projects.Scripts.Models.DamageType start.*/
    Bridge.define("Projects.Scripts.Models.DamageType", {
        $kind: "enum",
        statics: {
            fields: {
                Object: 0,
                Water: 1,
                Fire: 2,
                Enemy: 3
            }
        }
    });
    /*Projects.Scripts.Models.DamageType end.*/

    /*Projects.Scripts.Models.GameState start.*/
    Bridge.define("Projects.Scripts.Models.GameState", {
        $kind: "enum",
        statics: {
            fields: {
                Prepare: 0,
                Playing: 1,
                Pause: 2,
                End: 3
            }
        }
    });
    /*Projects.Scripts.Models.GameState end.*/

    /*Projects.Scripts.Models.ItemType start.*/
    Bridge.define("Projects.Scripts.Models.ItemType", {
        $kind: "enum",
        statics: {
            fields: {
                Coin: 0,
                Heart: 1,
                Skin: 2
            }
        }
    });
    /*Projects.Scripts.Models.ItemType end.*/

    /*Projects.Scripts.Models.MoveDirection start.*/
    Bridge.define("Projects.Scripts.Models.MoveDirection", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Left: -1,
                Right: 1
            }
        }
    });
    /*Projects.Scripts.Models.MoveDirection end.*/

    /*Projects.Scripts.UIController.ButtonEffect start.*/
    Bridge.define("Projects.Scripts.UIController.ButtonEffect", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.IPointerExitHandler,UnityEngine.EventSystems.IPointerUpHandler],
        fields: {
            _button: null,
            _isEnter: false
        },
        alias: [
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp"
        ],
        methods: {
            /*Projects.Scripts.UIController.ButtonEffect.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#Awake", this ); }

                this._button = this.GetComponent(UnityEngine.UI.Button);
            },
            /*Projects.Scripts.UIController.ButtonEffect.Awake end.*/

            /*Projects.Scripts.UIController.ButtonEffect.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#OnPointerDown", this ); }

                if (!this._button.IsInteractable()) {
                    return;
                }
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 0.95, 0.95, 0.95 ), 0.1), DG.Tweening.Ease.InQuad), DG.Tweening.UpdateType.Normal, true);
            },
            /*Projects.Scripts.UIController.ButtonEffect.OnPointerDown end.*/

            /*Projects.Scripts.UIController.ButtonEffect.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#OnPointerEnter", this ); }

                if (!this._button.IsInteractable()) {
                    return;
                }
                if (this._isEnter) {
                    return;
                }
                this._isEnter = true;
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 0.95, 0.95, 0.95 ), 0.1), DG.Tweening.Ease.InQuad), DG.Tweening.UpdateType.Normal, true);
            },
            /*Projects.Scripts.UIController.ButtonEffect.OnPointerEnter end.*/

            /*Projects.Scripts.UIController.ButtonEffect.OnPointerExit start.*/
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#OnPointerExit", this ); }

                this._isEnter = false;
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 1, 1, 1 ), 0.1), DG.Tweening.Ease.InQuad), DG.Tweening.UpdateType.Normal, true);
            },
            /*Projects.Scripts.UIController.ButtonEffect.OnPointerExit end.*/

            /*Projects.Scripts.UIController.ButtonEffect.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#OnPointerUp", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 1, 1, 1 ), 0.1), DG.Tweening.Ease.InQuad), DG.Tweening.UpdateType.Normal, true);
            },
            /*Projects.Scripts.UIController.ButtonEffect.OnPointerUp end.*/

            /*Projects.Scripts.UIController.ButtonEffect.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ButtonEffect#OnValidate", this ); }

                this.GetComponent(UnityEngine.UI.Button).transition = UnityEngine.UI.Selectable.Transition.None;
            },
            /*Projects.Scripts.UIController.ButtonEffect.OnValidate end.*/


        }
    });
    /*Projects.Scripts.UIController.ButtonEffect end.*/

    /*Projects.Scripts.UIController.CoinValueText start.*/
    Bridge.define("Projects.Scripts.UIController.CoinValueText", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            coinValueText: null,
            curve: null
        },
        methods: {
            /*Projects.Scripts.UIController.CoinValueText.SetValue start.*/
            SetValue: function (value) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CoinValueText#SetValue", this ); }

                this.coinValueText.text = "+" + value;
                DG.Tweening.TweenSettingsExtensions.SetEase(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.coinValueText.transform$1, 100, 1.5), true), this.curve);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$1(this.coinValueText, 0, 0.3), 1.5), DG.Tweening.Ease.OutQuad), Bridge.fn.cacheBind(this, this.Complete));
            },
            /*Projects.Scripts.UIController.CoinValueText.SetValue end.*/

            /*Projects.Scripts.UIController.CoinValueText.Complete start.*/
            Complete: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CoinValueText#Complete", this ); }

                UnityEngine.Object.DestroyImmediate(this.gameObject);
            },
            /*Projects.Scripts.UIController.CoinValueText.Complete end.*/


        }
    });
    /*Projects.Scripts.UIController.CoinValueText end.*/

    /*Projects.Scripts.UIController.CustomButton start.*/
    Bridge.define("Projects.Scripts.UIController.CustomButton", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.IPointerExitHandler],
        fields: {
            interactive: false,
            targetGraphic: null,
            onClick: null,
            onEnter: null,
            onExit: null,
            _isEnter: false
        },
        alias: [
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CustomButton#init", this ); }

                this.interactive = true;
            }
        },
        methods: {
            /*Projects.Scripts.UIController.CustomButton.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CustomButton#OnPointerDown", this ); }

                if (!this.interactive) {
                    return;
                }
                DG.Tweening.ShortcutExtensions.DOKill(this.targetGraphic);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.targetGraphic, new pc.Vec3( 0.95, 0.95, 0.95 ), 0.1), DG.Tweening.Ease.InOutSine), DG.Tweening.UpdateType.Normal, true);

                this.onClick.Invoke();
            },
            /*Projects.Scripts.UIController.CustomButton.OnPointerDown end.*/

            /*Projects.Scripts.UIController.CustomButton.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CustomButton#OnPointerEnter", this ); }

                if (!this.interactive) {
                    return;
                }
                this.onEnter.Invoke();
                if (this._isEnter) {
                    return;
                }
                this._isEnter = true;
                // MMVibrationManager.Haptic (HapticTypes.Selection );
                DG.Tweening.ShortcutExtensions.DOKill(this.targetGraphic);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.targetGraphic, new pc.Vec3( 0.95, 0.95, 0.95 ), 0.1), DG.Tweening.Ease.InOutSine), DG.Tweening.UpdateType.Normal, true);

            },
            /*Projects.Scripts.UIController.CustomButton.OnPointerEnter end.*/

            /*Projects.Scripts.UIController.CustomButton.OnPointerExit start.*/
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.CustomButton#OnPointerExit", this ); }

                if (!this.interactive) {
                    return;
                }
                this.onExit.Invoke();
                this._isEnter = false;
                DG.Tweening.ShortcutExtensions.DOKill(this.targetGraphic);
                DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.targetGraphic, new pc.Vec3( 1, 1, 1 ), 0.1), DG.Tweening.Ease.InOutSine), DG.Tweening.UpdateType.Normal, true);


            },
            /*Projects.Scripts.UIController.CustomButton.OnPointerExit end.*/


        }
    });
    /*Projects.Scripts.UIController.CustomButton end.*/

    /*Projects.Scripts.UIController.GamePlayController start.*/
    Bridge.define("Projects.Scripts.UIController.GamePlayController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#Instance#get", this ); }

                        return Projects.Scripts.UIController.GamePlayController._instance;
                    }
                }
            }
        },
        fields: {
            ball: null,
            currentCheckPoint: null,
            ballUI: null,
            magnetIcon: null,
            magnetActive: false,
            totalCoin: 0,
            coinValuePrefab: null,
            level: 0,
            gameState: 0,
            starList: null,
            totalStars: 0,
            currentHp: 0,
            hpList: null,
            hpPrefabs: null,
            lifeText: null,
            lifeIcon: null,
            pauseButton: null,
            bossGroup: null,
            bossHp: null,
            bossWarning: null,
            bossSkeleton: null,
            tapToContinue: null,
            onRevive: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#init", this ); }

                this.gameState = Projects.Scripts.Models.GameState.Prepare;
            }
        },
        methods: {
            /*Projects.Scripts.UIController.GamePlayController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(Projects.Scripts.UIController.GamePlayController._instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(Projects.Scripts.UIController.GamePlayController._instance.gameObject);
                }

                Projects.Scripts.UIController.GamePlayController._instance = this;
                var sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
                var levelString = System.String.replaceAll(sceneName, "Level ", "");
                if (System.Int32.tryParse(levelString, Bridge.ref(this, "level"))) {

                }

            },
            /*Projects.Scripts.UIController.GamePlayController.Awake end.*/

            /*Projects.Scripts.UIController.GamePlayController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#Start", this ); }

                var $t;
                this.ball = Projects.Scripts.GamePlay.CharacterController.BallController.Instance;

                this.tapToContinue.gameObject.SetActive(true);
                this.tapToContinue.raycastTarget = false;
                this.pauseButton.onClick.AddListener(function () {
                    ThirdParties.Truongtv.SoundManager.SoundManager.Instance.PlayButtonSound();
                });
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBgmSound();
                var sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
                this.currentCheckPoint = Projects.Scripts.GamePlay.Building.StartLevel.Instance.Init(sceneName);
                this.currentHp = 3;
                $t = Bridge.getEnumerator(this.starList);
                try {
                    while ($t.moveNext()) {
                        var star = $t.Current;
                        star.gameObject.SetActive(false);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                for (var i = 0; i < this.currentHp; i = (i + 1) | 0) {
                    this.hpList[i].gameObject.SetActive(true);
                }

                this.lifeText.text = "3";
                this.StartGame();
                this.SetSkin("Base");
            },
            /*Projects.Scripts.UIController.GamePlayController.Start end.*/

            /*Projects.Scripts.UIController.GamePlayController.StartGame start.*/
            StartGame: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#StartGame", this ); }

                this.gameState = Projects.Scripts.Models.GameState.Playing;
            },
            /*Projects.Scripts.UIController.GamePlayController.StartGame end.*/

            /*Projects.Scripts.UIController.GamePlayController.CollectCoin start.*/
            CollectCoin: function (value, coinTransform) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#CollectCoin", this ); }

                this.totalCoin = (this.totalCoin + value) | 0;
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallCollectCoin();
                var item = UnityEngine.Object.Instantiate(Projects.Scripts.UIController.CoinValueText, this.coinValuePrefab);
                item.transform.position = coinTransform.position.$clone();
                item.SetValue(value);
            },
            /*Projects.Scripts.UIController.GamePlayController.CollectCoin end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetCollectingCurrency start.*/
            SetCollectingCurrency: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetCollectingCurrency", this ); }

                this.ball.CollectingCoin();
            },
            /*Projects.Scripts.UIController.GamePlayController.SetCollectingCurrency end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetCollectedCurrency start.*/
            SetCollectedCurrency: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetCollectedCurrency", this ); }

                this.ball.Collected();
            },
            /*Projects.Scripts.UIController.GamePlayController.SetCollectedCurrency end.*/

            /*Projects.Scripts.UIController.GamePlayController.CollectStar start.*/
            CollectStar: function (starTransform) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#CollectStar", this ); }

                this.totalStars = (this.totalStars + 1) | 0;
                Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallCollectStar();
                this.starList.getItem(((this.totalStars - 1) | 0)).position = starTransform.position.$clone();
                this.starList.getItem(((this.totalStars - 1) | 0)).gameObject.SetActive(true);
                var sequence = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenExtensions.Play(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.ShortcutExtensions.DOLocalMoveX(this.starList.getItem(((this.totalStars - 1) | 0)), 0, 0.5)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.starList.getItem(((this.totalStars - 1) | 0)), 0, 0.5), DG.Tweening.Ease.InCirc)));
            },
            /*Projects.Scripts.UIController.GamePlayController.CollectStar end.*/

            /*Projects.Scripts.UIController.GamePlayController.CollectHp start.*/
            CollectHp: function (hpTransform) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#CollectHp", this ); }


                this.currentHp = (this.currentHp + 1) | 0;
                if (this.currentHp >= 3) {
                    this.currentHp = 3;
                }
                var item = UnityEngine.Object.Instantiate(UnityEngine.GameObject, this.hpPrefabs, this.hpList[0].parent);
                item.transform.position = hpTransform.position.$clone();
                var sequence = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenExtensions.Play(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.ShortcutExtensions.DOLocalMoveX(item.transform, 0, 0.5)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(item.transform, 0, 0.5), DG.Tweening.Ease.InCirc)), Bridge.fn.bind(this, function () {
                    this.hpList[((this.currentHp - 1) | 0)].gameObject.SetActive(true);
                    UnityEngine.Object.DestroyImmediate(item);
                })));
            },
            /*Projects.Scripts.UIController.GamePlayController.CollectHp end.*/

            /*Projects.Scripts.UIController.GamePlayController.CollectMagnet start.*/
            CollectMagnet: function (magnetItem) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#CollectMagnet", this ); }

                this.magnetIcon.transform.position = magnetItem.position.$clone();
                this.magnetIcon.gameObject.SetActive(true);
                var sequence = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.ShortcutExtensions.DOLocalMoveX(this.magnetIcon.transform, 0, 0.5));
                DG.Tweening.TweenSettingsExtensions.Join(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.magnetIcon.transform, 0, 0.5), DG.Tweening.Ease.InCirc));
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, sequence, Bridge.fn.bind(this, function () {
                    this.ball.ActiveMagnet(true);
                    this.magnetActive = true;
                }));
                DG.Tweening.TweenExtensions.Play(DG.Tweening.Sequence, sequence);

            },
            /*Projects.Scripts.UIController.GamePlayController.CollectMagnet end.*/

            /*Projects.Scripts.UIController.GamePlayController.IsMagnetActive start.*/
            IsMagnetActive: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#IsMagnetActive", this ); }

                return this.magnetActive;
            },
            /*Projects.Scripts.UIController.GamePlayController.IsMagnetActive end.*/

            /*Projects.Scripts.UIController.GamePlayController.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#OnDestroy", this ); }

                this.StopAllCoroutines();
            },
            /*Projects.Scripts.UIController.GamePlayController.OnDestroy end.*/

            /*Projects.Scripts.UIController.GamePlayController.CollectLife start.*/
            CollectLife: function (value, target) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#CollectLife", this ); }

                this.ball.ActiveHeartEffect();
            },
            /*Projects.Scripts.UIController.GamePlayController.CollectLife end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetSkin start.*/
            SetSkin: function (skin) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetSkin", this ); }

                this.ballUI.initialSkinName = skin;
                this.ballUI.Initialize(true);
            },
            /*Projects.Scripts.UIController.GamePlayController.SetSkin end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetCheckPoint start.*/
            SetCheckPoint: function (checkPoint, playSound) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetCheckPoint", this ); }

                if (playSound === void 0) { playSound = true; }
                this.currentCheckPoint = checkPoint;
                if (playSound) {
                    Projects.Scripts.GamePlay.Sound.SoundInGameManager.Instance.PlayBallInCheckPoint();
                }
            },
            /*Projects.Scripts.UIController.GamePlayController.SetCheckPoint end.*/

            /*Projects.Scripts.UIController.GamePlayController.BallDamaged start.*/
            BallDamaged: function (value) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#BallDamaged", this ); }

                for (var i = 0; i < this.hpList.length; i = (i + 1) | 0) {
                    this.hpList[i].gameObject.SetActive(i < value);
                }
            },
            /*Projects.Scripts.UIController.GamePlayController.BallDamaged end.*/

            /*Projects.Scripts.UIController.GamePlayController.BallDie start.*/
            BallDie: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#BallDie", this ); }


                this.ShowContinue();
            },
            /*Projects.Scripts.UIController.GamePlayController.BallDie end.*/

            /*Projects.Scripts.UIController.GamePlayController.PauseWhenBallDie start.*/
            PauseWhenBallDie: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#PauseWhenBallDie", this ); }

                this.gameState = Projects.Scripts.Models.GameState.Pause;
            },
            /*Projects.Scripts.UIController.GamePlayController.PauseWhenBallDie end.*/

            /*Projects.Scripts.UIController.GamePlayController.Win start.*/
            Win: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#Win", this ); }

                this.ShowContinue();
            },
            /*Projects.Scripts.UIController.GamePlayController.Win end.*/

            /*Projects.Scripts.UIController.GamePlayController.ShowContinue start.*/
            ShowContinue: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#ShowContinue", this ); }

                this.tapToContinue.gameObject.SetActive(true);
                this.tapToContinue.raycastTarget = true;
            },
            /*Projects.Scripts.UIController.GamePlayController.ShowContinue end.*/

            /*Projects.Scripts.UIController.GamePlayController.GoToStore start.*/
            GoToStore: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#GoToStore", this ); }


            },
            /*Projects.Scripts.UIController.GamePlayController.GoToStore end.*/

            /*Projects.Scripts.UIController.GamePlayController.TouchMoveLeft start.*/
            TouchMoveLeft: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#TouchMoveLeft", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ball, null) && this.gameState !== Projects.Scripts.Models.GameState.Playing && !this.ball.IsDie()) {
                    return;
                }
                if (!release) {
                    if (!this.tapToContinue.raycastTarget) {
                        this.tapToContinue.gameObject.SetActive(false);
                    } else {
                        this.GoToStore();
                    }
                }

                this.ball.MoveLeft(release);
            },
            /*Projects.Scripts.UIController.GamePlayController.TouchMoveLeft end.*/

            /*Projects.Scripts.UIController.GamePlayController.TouchMoveRight start.*/
            TouchMoveRight: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#TouchMoveRight", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ball, null) && this.gameState !== Projects.Scripts.Models.GameState.Playing && !this.ball.IsDie()) {
                    return;
                }
                if (!release) {
                    if (!this.tapToContinue.raycastTarget) {
                        this.tapToContinue.gameObject.SetActive(false);
                    } else {
                        this.GoToStore();
                    }
                }

                this.ball.MoveRight(release);
            },
            /*Projects.Scripts.UIController.GamePlayController.TouchMoveRight end.*/

            /*Projects.Scripts.UIController.GamePlayController.TouchJump start.*/
            TouchJump: function (release) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#TouchJump", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ball, null) && this.gameState !== Projects.Scripts.Models.GameState.Playing && !this.ball.IsDie()) {
                    return;
                }
                if (!release) {
                    if (!this.tapToContinue.raycastTarget) {
                        this.tapToContinue.gameObject.SetActive(false);
                    } else {
                        this.GoToStore();
                    }
                }

                this.ball.Jump(release);
            },
            /*Projects.Scripts.UIController.GamePlayController.TouchJump end.*/

            /*Projects.Scripts.UIController.GamePlayController.ExitRoom start.*/
            ExitRoom: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#ExitRoom", this ); }
 },
            /*Projects.Scripts.UIController.GamePlayController.ExitRoom end.*/

            /*Projects.Scripts.UIController.GamePlayController.ActiveWarning start.*/
            ActiveWarning: function (complete) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#ActiveWarning", this ); }

                if (complete === void 0) { complete = null; }
                this.bossWarning.gameObject.SetActive(true);
                this.bossWarning.alpha = 1;
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetLoops(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.bossWarning, 0, 0.75), DG.Tweening.Ease.InOutSine), 5), Bridge.fn.bind(this, function () {
                    this.gameState = Projects.Scripts.Models.GameState.Playing;
                    this.bossWarning.gameObject.SetActive(false);
                    !Bridge.staticEquals(complete, null) ? complete() : null;
                    this.bossGroup.SetActive(true);
                }));
            },
            /*Projects.Scripts.UIController.GamePlayController.ActiveWarning end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetBossHealth start.*/
            SetBossHealth: function (percent) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetBossHealth", this ); }

                this.bossHp.fillAmount = percent;
                if (percent <= 0) {
                    this.bossGroup.SetActive(false);
                    this.ExitRoom();
                }
            },
            /*Projects.Scripts.UIController.GamePlayController.SetBossHealth end.*/

            /*Projects.Scripts.UIController.GamePlayController.SetBossSkin start.*/
            SetBossSkin: function (asset) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.GamePlayController#SetBossSkin", this ); }

                this.bossSkeleton.skeletonDataAsset = asset;
                this.bossSkeleton.Initialize(true);
            },
            /*Projects.Scripts.UIController.GamePlayController.SetBossSkin end.*/


        }
    });
    /*Projects.Scripts.UIController.GamePlayController end.*/

    /*Projects.Scripts.UIController.ToggleHelper start.*/
    Bridge.define("Projects.Scripts.UIController.ToggleHelper", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            onObjects: null,
            offObjects: null,
            _toggle: null
        },
        methods: {
            /*Projects.Scripts.UIController.ToggleHelper.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ToggleHelper#Awake", this ); }

                this._toggle = this.GetComponent(UnityEngine.UI.Toggle);
                this._toggle.onValueChanged.AddListener(Bridge.fn.bind(this, function (value) {
                    this.OnValueChange(value, 0.1);
                }));
                this._toggle.onValueChanged.Invoke(this._toggle.isOn);
            },
            /*Projects.Scripts.UIController.ToggleHelper.Awake end.*/

            /*Projects.Scripts.UIController.ToggleHelper.OnValueChange start.*/
            OnValueChange: function (value, duration) {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ToggleHelper#OnValueChange", this ); }

                var $t, $t1;

                if (System.Nullable.gt((this.onObjects != null ? this.onObjects.length : null), 0)) {
                    $t = Bridge.getEnumerator(this.onObjects);
                    try {
                        while ($t.moveNext()) {
                            var obj = $t.Current;
                            if (duration === 0) {
                                var color = obj.color.$clone();
                                color.a = value ? 1.0 : 0.0;
                                obj.color = color.$clone();
                            } else {
                                obj.CrossFadeAlpha(value ? 1.0 : 0.0, duration, true);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (System.Nullable.gt((this.offObjects != null ? this.offObjects.length : null), 0)) {
                    $t1 = Bridge.getEnumerator(this.offObjects);
                    try {
                        while ($t1.moveNext()) {
                            var obj1 = $t1.Current;
                            if (duration === 0) {
                                var color1 = obj1.color.$clone();
                                color1.a = value ? 0.0 : 1.0;
                                obj1.color = color1.$clone();
                            } else {
                                obj1.CrossFadeAlpha(value ? 0.0 : 1.0, duration, true);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Projects.Scripts.UIController.ToggleHelper.OnValueChange end.*/

            /*Projects.Scripts.UIController.ToggleHelper.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "Projects.Scripts.UIController.ToggleHelper#OnDrawGizmos", this ); }

                var $t, $t1;
                if (UnityEngine.Application.isPlaying) {
                    return;
                }
                this._toggle = this.GetComponent(UnityEngine.UI.Toggle);
                if (System.Nullable.gt((this.onObjects != null ? this.onObjects.length : null), 0)) {
                    $t = Bridge.getEnumerator(this.onObjects);
                    try {
                        while ($t.moveNext()) {
                            var obj = $t.Current;
                            obj.CrossFadeAlpha(this._toggle.isOn ? 1.0 : 0.0, 0.1, true);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (System.Nullable.gt((this.offObjects != null ? this.offObjects.length : null), 0)) {
                    $t1 = Bridge.getEnumerator(this.offObjects);
                    try {
                        while ($t1.moveNext()) {
                            var obj1 = $t1.Current;
                            obj1.CrossFadeAlpha(this._toggle.isOn ? 0.0 : 1.0, 0.1, true);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Projects.Scripts.UIController.ToggleHelper.OnDrawGizmos end.*/


        }
    });
    /*Projects.Scripts.UIController.ToggleHelper end.*/

    /*SharpJson.JsonDecoder start.*/
    Bridge.define("SharpJson.JsonDecoder", {
        statics: {
            methods: {
                /*SharpJson.JsonDecoder.DecodeText:static start.*/
                DecodeText: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#DecodeText", this ); }

                    var builder = new SharpJson.JsonDecoder();
                    return builder.Decode(text);
                },
                /*SharpJson.JsonDecoder.DecodeText:static end.*/


            }
        },
        fields: {
            errorMessage: null,
            parseNumbersAsFloat: false,
            lexer: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ctor", this ); }

                this.$initialize();
                this.errorMessage = null;
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.JsonDecoder.Decode start.*/
            Decode: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#Decode", this ); }

                this.errorMessage = null;

                this.lexer = new SharpJson.Lexer(text);
                this.lexer.parseNumbersAsFloat = this.parseNumbersAsFloat;

                return this.ParseValue();
            },
            /*SharpJson.JsonDecoder.Decode end.*/

            /*SharpJson.JsonDecoder.ParseObject start.*/
            ParseObject: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseObject", this ); }

                var table = new (System.Collections.Generic.Dictionary$2(System.String,System.Object)).ctor();

                // {
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.CurlyClose: 
                            this.lexer.NextToken();
                            return table;
                        default: 
                            // name
                            var name = this.EvalLexer(System.String, this.lexer.ParseString());
                            if (this.errorMessage != null) {
                                return null;
                            }
                            // :
                            token = this.lexer.NextToken();
                            if (token !== SharpJson.Lexer.Token.Colon) {
                                this.TriggerError("Invalid token; expected ':'");
                                return null;
                            }
                            // value
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            table.setItem(name, value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseObject end.*/

            /*SharpJson.JsonDecoder.ParseArray start.*/
            ParseArray: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseArray", this ); }

                var array = new (System.Collections.Generic.List$1(System.Object)).ctor();

                // [
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.SquaredClose: 
                            this.lexer.NextToken();
                            return array;
                        default: 
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            array.add(value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseArray end.*/

            /*SharpJson.JsonDecoder.ParseValue start.*/
            ParseValue: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseValue", this ); }

                switch (this.lexer.LookAhead()) {
                    case SharpJson.Lexer.Token.String: 
                        return this.EvalLexer(System.String, this.lexer.ParseString());
                    case SharpJson.Lexer.Token.Number: 
                        if (this.parseNumbersAsFloat) {
                            return Bridge.box(this.EvalLexer(System.Single, this.lexer.ParseFloatNumber()), System.Single, System.Single.format, System.Single.getHashCode);
                        } else {
                            return Bridge.box(this.EvalLexer(System.Double, this.lexer.ParseDoubleNumber()), System.Double, System.Double.format, System.Double.getHashCode);
                        }
                    case SharpJson.Lexer.Token.CurlyOpen: 
                        return this.ParseObject();
                    case SharpJson.Lexer.Token.SquaredOpen: 
                        return this.ParseArray();
                    case SharpJson.Lexer.Token.True: 
                        this.lexer.NextToken();
                        return Bridge.box(true, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.False: 
                        this.lexer.NextToken();
                        return Bridge.box(false, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.Null: 
                        this.lexer.NextToken();
                        return null;
                    case SharpJson.Lexer.Token.None: 
                        break;
                }

                this.TriggerError("Unable to parse value");
                return null;
            },
            /*SharpJson.JsonDecoder.ParseValue end.*/

            /*SharpJson.JsonDecoder.TriggerError start.*/
            TriggerError: function (message) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#TriggerError", this ); }

                this.errorMessage = System.String.format("Error: '{0}' at line {1}", message, Bridge.box(this.lexer.lineNumber, System.Int32));
            },
            /*SharpJson.JsonDecoder.TriggerError end.*/

            /*SharpJson.JsonDecoder.EvalLexer start.*/
            EvalLexer: function (T, value) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#EvalLexer", this ); }

                if (this.lexer.hasError) {
                    this.TriggerError("Lexical error ocurred");
                }

                return Bridge.rValue(value);
            },
            /*SharpJson.JsonDecoder.EvalLexer end.*/


        }
    });
    /*SharpJson.JsonDecoder end.*/

    /*SharpJson.Lexer start.*/
    Bridge.define("SharpJson.Lexer", {
        statics: {
            methods: {
                /*SharpJson.Lexer.NextToken:static start.*/
                NextToken: function (json, index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                    if (index.v === json.length) {
                        return SharpJson.Lexer.Token.None;
                    }

                    var c = json[Bridge.identity(index.v, ((index.v = (index.v + 1) | 0)))];

                    switch (c) {
                        case 123: 
                            return SharpJson.Lexer.Token.CurlyOpen;
                        case 125: 
                            return SharpJson.Lexer.Token.CurlyClose;
                        case 91: 
                            return SharpJson.Lexer.Token.SquaredOpen;
                        case 93: 
                            return SharpJson.Lexer.Token.SquaredClose;
                        case 44: 
                            return SharpJson.Lexer.Token.Comma;
                        case 34: 
                            return SharpJson.Lexer.Token.String;
                        case 48: 
                        case 49: 
                        case 50: 
                        case 51: 
                        case 52: 
                        case 53: 
                        case 54: 
                        case 55: 
                        case 56: 
                        case 57: 
                        case 45: 
                            return SharpJson.Lexer.Token.Number;
                        case 58: 
                            return SharpJson.Lexer.Token.Colon;
                    }

                    index.v = (index.v - 1) | 0;

                    var remainingLength = (json.length - index.v) | 0;

                    // false
                    if (remainingLength >= 5) {
                        if (json[index.v] === 102 && json[((index.v + 1) | 0)] === 97 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 115 && json[((index.v + 4) | 0)] === 101) {
                            index.v = (index.v + 5) | 0;
                            return SharpJson.Lexer.Token.False;
                        }
                    }

                    // true
                    if (remainingLength >= 4) {
                        if (json[index.v] === 116 && json[((index.v + 1) | 0)] === 114 && json[((index.v + 2) | 0)] === 117 && json[((index.v + 3) | 0)] === 101) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.True;
                        }
                    }

                    // null
                    if (remainingLength >= 4) {
                        if (json[index.v] === 110 && json[((index.v + 1) | 0)] === 117 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 108) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.Null;
                        }
                    }

                    return SharpJson.Lexer.Token.None;
                },
                /*SharpJson.Lexer.NextToken:static end.*/


            }
        },
        fields: {
            lineNumber: 0,
            parseNumbersAsFloat: false,
            json: null,
            index: 0,
            success: false,
            stringBuffer: null
        },
        props: {
            hasError: {
                get: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#hasError#get", this ); }

                    return !this.success;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#init", this ); }

                this.index = 0;
                this.success = true;
                this.stringBuffer = System.Array.init(4096, 0, System.Char);
            },
            ctor: function (text) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ctor", this ); }

                this.$initialize();
                this.Reset();

                this.json = System.String.toCharArray(text, 0, text.length);
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.Lexer.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#Reset", this ); }

                this.index = 0;
                this.lineNumber = 1;
                this.success = true;
            },
            /*SharpJson.Lexer.Reset end.*/

            /*SharpJson.Lexer.ParseString start.*/
            ParseString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseString", this ); }

                var idx = 0;
                var builder = null;

                this.SkipWhiteSpaces();

                // "
                var c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                var failed = false;
                var complete = false;

                while (!complete && !failed) {
                    if (this.index === this.json.length) {
                        break;
                    }

                    c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];
                    if (c === 34) {
                        complete = true;
                        break;
                    } else if (c === 92) {
                        if (this.index === this.json.length) {
                            break;
                        }

                        c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                        switch (c) {
                            case 34: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 34;
                                break;
                            case 92: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 92;
                                break;
                            case 47: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 47;
                                break;
                            case 98: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 8;
                                break;
                            case 102: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 12;
                                break;
                            case 110: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 10;
                                break;
                            case 114: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 13;
                                break;
                            case 116: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 9;
                                break;
                            case 117: 
                                var remainingLength = (this.json.length - this.index) | 0;
                                if (remainingLength >= 4) {
                                    var hex = System.String.fromCharArray(this.json, this.index, 4);

                                    // XXX: handle UTF
                                    this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = (System.Convert.toNumberInBase(hex, 16, 9)) & 65535;

                                    // skip 4 chars
                                    this.index = (this.index + 4) | 0;
                                } else {
                                    failed = true;
                                }
                                break;
                        }
                    } else {
                        this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = c;
                    }

                    if (idx >= this.stringBuffer.length) {
                        if (builder == null) {
                            builder = new System.Text.StringBuilder();
                        }

                        builder.append(System.String.fromCharArray(this.stringBuffer), 0, idx);
                        idx = 0;
                    }
                }

                if (!complete) {
                    this.success = false;
                    return null;
                }

                if (builder != null) {
                    return builder.toString();
                } else {
                    return System.String.fromCharArray(this.stringBuffer, 0, idx);
                }
            },
            /*SharpJson.Lexer.ParseString end.*/

            /*SharpJson.Lexer.GetNumberString start.*/
            GetNumberString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetNumberString", this ); }

                this.SkipWhiteSpaces();

                var lastIndex = this.GetLastIndexOfNumber(this.index);
                var charLength = ((((lastIndex - this.index) | 0)) + 1) | 0;

                var result = System.String.fromCharArray(this.json, this.index, charLength);

                this.index = (lastIndex + 1) | 0;

                return result;
            },
            /*SharpJson.Lexer.GetNumberString end.*/

            /*SharpJson.Lexer.ParseFloatNumber start.*/
            ParseFloatNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseFloatNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Single.tryParse(str, null, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseFloatNumber end.*/

            /*SharpJson.Lexer.ParseDoubleNumber start.*/
            ParseDoubleNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseDoubleNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Double.tryParse(str, null, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseDoubleNumber end.*/

            /*SharpJson.Lexer.GetLastIndexOfNumber start.*/
            GetLastIndexOfNumber: function (index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetLastIndexOfNumber", this ); }

                var lastIndex;

                for (lastIndex = index; lastIndex < this.json.length; lastIndex = (lastIndex + 1) | 0) {
                    var ch = this.json[lastIndex];

                    if ((ch < 48 || ch > 57) && ch !== 43 && ch !== 45 && ch !== 46 && ch !== 101 && ch !== 69) {
                        break;
                    }
                }

                return ((lastIndex - 1) | 0);
            },
            /*SharpJson.Lexer.GetLastIndexOfNumber end.*/

            /*SharpJson.Lexer.SkipWhiteSpaces start.*/
            SkipWhiteSpaces: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#SkipWhiteSpaces", this ); }

                for (; this.index < this.json.length; this.index = (this.index + 1) | 0) {
                    var ch = this.json[this.index];

                    if (ch === 10) {
                        this.lineNumber = (this.lineNumber + 1) | 0;
                    }

                    if (!System.Char.isWhiteSpace(String.fromCharCode(this.json[this.index]))) {
                        break;
                    }
                }
            },
            /*SharpJson.Lexer.SkipWhiteSpaces end.*/

            /*SharpJson.Lexer.LookAhead start.*/
            LookAhead: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#LookAhead", this ); }

                this.SkipWhiteSpaces();

                var savedIndex = { v : this.index };
                return SharpJson.Lexer.NextToken(this.json, savedIndex);
            },
            /*SharpJson.Lexer.LookAhead end.*/

            /*SharpJson.Lexer.NextToken start.*/
            NextToken: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                this.SkipWhiteSpaces();
                return SharpJson.Lexer.NextToken(this.json, Bridge.ref(this, "index"));
            },
            /*SharpJson.Lexer.NextToken end.*/


        }
    });
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    Bridge.define("SharpJson.Lexer.Token", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                Null: 1,
                True: 2,
                False: 3,
                Colon: 4,
                Comma: 5,
                String: 6,
                Number: 7,
                CurlyOpen: 8,
                CurlyClose: 9,
                SquaredOpen: 10,
                SquaredClose: 11
            }
        }
    });
    /*SharpJson.Lexer+Token end.*/

    /*Spine.Animation start.*/
    /** @namespace Spine */

    /**
     * A simple container for a list of timelines and a name.
     *
     * @public
     * @class Spine.Animation
     */
    Bridge.define("Spine.Animation", {
        statics: {
            methods: {
                /*Spine.Animation.BinarySearch$1:static start.*/
                /**
                 * @static
                 * @this Spine.Animation
                 * @memberof Spine.Animation
                 * @param   {Array.<number>}    values    
                 * @param   {number}            target    After the first and before the last entry.
                 * @param   {number}            step
                 * @return  {number}                      Index of first value greater than the target.
                 */
                BinarySearch$1: function (values, target, step) {
if ( TRACE ) { TRACE( "Spine.Animation#BinarySearch$1", this ); }

                    var low = 0;
                    var high = (((Bridge.Int.div(values.length, step)) | 0) - 2) | 0;
                    if (high === 0) {
                        return step;
                    }
                    var current = ((high >>> 0) >>> 1) | 0;
                    while (true) {
                        if (values[Bridge.Int.mul((((current + 1) | 0)), step)] <= target) {
                            low = (current + 1) | 0;
                        } else {
                            high = current;
                        }
                        if (low === high) {
                            return Bridge.Int.mul((((low + 1) | 0)), step);
                        }
                        current = ((((((low + high) | 0))) >>> 0) >>> 1) | 0;
                    }
                },
                /*Spine.Animation.BinarySearch$1:static end.*/

                /*Spine.Animation.BinarySearch:static start.*/
                /**
                 * @static
                 * @this Spine.Animation
                 * @memberof Spine.Animation
                 * @param   {Array.<number>}    values    
                 * @param   {number}            target    After the first and before the last entry.
                 * @return  {number}
                 */
                BinarySearch: function (values, target) {
if ( TRACE ) { TRACE( "Spine.Animation#BinarySearch", this ); }

                    var low = 0;
                    var high = (values.length - 2) | 0;
                    if (high === 0) {
                        return 1;
                    }
                    var current = ((high >>> 0) >>> 1) | 0;
                    while (true) {
                        if (values[((current + 1) | 0)] <= target) {
                            low = (current + 1) | 0;
                        } else {
                            high = current;
                        }
                        if (low === high) {
                            return (((low + 1) | 0));
                        }
                        current = ((((((low + high) | 0))) >>> 0) >>> 1) | 0;
                    }
                },
                /*Spine.Animation.BinarySearch:static end.*/

                /*Spine.Animation.LinearSearch:static start.*/
                LinearSearch: function (values, target, step) {
if ( TRACE ) { TRACE( "Spine.Animation#LinearSearch", this ); }

                    for (var i = 0, last = (values.length - step) | 0; i <= last; i = (i + step) | 0) {
                        if (values[i] > target) {
                            return i;
                        }
                    }
                    return -1;
                },
                /*Spine.Animation.LinearSearch:static end.*/


            }
        },
        fields: {
            name: null,
            timelines: null,
            timelineIds: null,
            duration: 0
        },
        props: {
            Timelines: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#get", this ); }

                    return this.timelines;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#set", this ); }

                    this.timelines = value;
                }
            },
            /**
             * The duration of the animation in seconds, which is the highest time of all keys in the timeline.
             *
             * @instance
             * @public
             * @memberof Spine.Animation
             * @function Duration
             * @type number
             */
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#get", this ); }

                    return this.duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#set", this ); }

                    this.duration = value;
                }
            },
            /**
             * The animation's name, which is unique across all animations in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Animation
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name, timelines, duration) {
if ( TRACE ) { TRACE( "Spine.Animation#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (timelines == null) {
                    throw new System.ArgumentNullException.$ctor3("timelines", "timelines cannot be null.");
                }
                // Note: avoiding reallocations by adding all hash set entries at
                // once (EnsureCapacity() is only available in newer .Net versions).
                var propertyIDs = System.Array.init(timelines.Count, 0, System.Int32);
                for (var i = 0; i < timelines.Count; i = (i + 1) | 0) {
                    propertyIDs[i] = timelines.Items[i].Spine$Timeline$PropertyId;
                }
                this.timelineIds = new (System.Collections.Generic.HashSet$1(System.Int32)).$ctor1(propertyIDs);
                this.name = name;
                this.timelines = timelines;
                this.duration = duration;
            }
        },
        methods: {
            /*Spine.Animation.HasTimeline start.*/
            /**
             * Whether the timeline with the property id is contained in this animation.
             *
             * @instance
             * @public
             * @this Spine.Animation
             * @memberof Spine.Animation
             * @param   {number}     id
             * @return  {boolean}
             */
            HasTimeline: function (id) {
if ( TRACE ) { TRACE( "Spine.Animation#HasTimeline", this ); }

                return this.timelineIds.contains(id);
            },
            /*Spine.Animation.HasTimeline end.*/

            /*Spine.Animation.Apply start.*/
            /**
             * Applies all the animation's timelines to the specified skeleton.
             *
             * @instance
             * @public
             * @this Spine.Animation
             * @memberof Spine.Animation
             * @param   {Spine.Skeleton}         skeleton     
             * @param   {number}                 lastTime     
             * @param   {number}                 time         
             * @param   {boolean}                loop         
             * @param   {Spine.ExposedList$1}    events       
             * @param   {number}                 alpha        
             * @param   {Spine.MixBlend}         blend        
             * @param   {Spine.MixDirection}     direction
             * @return  {void}
             * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
             */
            Apply: function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.Animation#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                if (loop && this.duration !== 0) {
                    time %= this.duration;
                    if (lastTime > 0) {
                        lastTime %= this.duration;
                    }
                }

                var timelines = this.timelines;
                for (var i = 0, n = timelines.Count; i < n; i = (i + 1) | 0) {
                    timelines.Items[i].Spine$Timeline$Apply(skeleton, lastTime, time, events, alpha, blend, direction);
                }
            },
            /*Spine.Animation.Apply end.*/

            /*Spine.Animation.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Animation#toString", this ); }

                return this.name;
            },
            /*Spine.Animation.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Animation end.*/

    /*Spine.AnimationState start.*/
    /**
     * <p>Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies
     multiple animations on top of each other (layering).</p><p>See <a href="http://esotericsoftware.com/spine-applying-animations/">Applying Animations</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.AnimationState
     */
    Bridge.define("Spine.AnimationState", {
        statics: {
            fields: {
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 0
                 * @type number
                 */
                Subsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 1
                 * @type number
                 */
                First: 0,
                
                HoldSubsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 3
                 * @type number
                 */
                HoldFirst: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 4
                 * @type number
                 */
                HoldMix: 0,
                Setup: 0,
                Current: 0,
                EmptyAnimation: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                    this.Subsequent = 0;
                    this.First = 1;
                    this.HoldSubsequent = 2;
                    this.HoldFirst = 3;
                    this.HoldMix = 4;
                    this.Setup = 1;
                    this.Current = 2;
                    this.EmptyAnimation = new Spine.Animation("<empty>", new (Spine.ExposedList$1(Spine.Timeline)).ctor(), 0);
                }
            },
            methods: {
                /*Spine.AnimationState.ApplyRotateTimeline:static start.*/
                /**
                 * Applies the rotate timeline, mixing with the current pose while keeping the same rotation direction chosen as the shortest
                 the first time the mixing was applied.
                 *
                 * @static
                 * @private
                 * @this Spine.AnimationState
                 * @memberof Spine.AnimationState
                 * @param   {Spine.RotateTimeline}    timeline             
                 * @param   {Spine.Skeleton}          skeleton             
                 * @param   {number}                  time                 
                 * @param   {number}                  alpha                
                 * @param   {Spine.MixBlend}          blend                
                 * @param   {Array.<number>}          timelinesRotation    
                 * @param   {number}                  i                    
                 * @param   {boolean}                 firstFrame
                 * @return  {void}
                 */
                ApplyRotateTimeline: function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyRotateTimeline", this ); }

                    var $t;

                    if (firstFrame) {
                        timelinesRotation[i] = 0;
                    }

                    if (alpha === 1) {
                        timeline.Apply(skeleton, 0, time, null, 1, blend, Spine.MixDirection.In);
                        return;
                    }

                    var bone = ($t = skeleton.bones.Items)[timeline.boneIndex];
                    if (!bone.active) {
                        return;
                    }

                    var frames = timeline.frames;
                    var r1, r2;
                    if (time < frames[0]) { // Time is before first frame.
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bone.rotation = bone.data.rotation;
                                return;
                            default: 
                                return;
                            case Spine.MixBlend.First: 
                                r1 = bone.rotation;
                                r2 = bone.data.rotation;
                                break;
                        }
                    } else {
                        r1 = blend === Spine.MixBlend.Setup ? bone.data.rotation : bone.rotation;
                        if (time >= frames[((frames.length - Spine.RotateTimeline.ENTRIES) | 0)]) {
                            r2 = bone.data.rotation + frames[((frames.length + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                        } else {
                            // Interpolate between the previous frame and the current frame.
                            var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.RotateTimeline.ENTRIES);
                            var prevRotation = frames[((frame + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                            var frameTime = frames[frame];
                            var percent = timeline.GetCurvePercent((((frame >> 1) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.RotateTimeline.PREV_TIME) | 0)] - frameTime));

                            r2 = frames[((frame + Spine.RotateTimeline.ROTATION) | 0)] - prevRotation;
                            r2 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360);
                            r2 = prevRotation + r2 * percent + bone.data.rotation;
                            r2 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360);
                        }
                    }

                    // Mix between rotations using the direction of the shortest route on the first frame.
                    var total, diff = r2 - r1;
                    diff -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - diff / 360))) | 0)), 360);
                    if (diff === 0) {
                        total = timelinesRotation[i];
                    } else {
                        var lastTotal, lastDiff;
                        if (firstFrame) {
                            lastTotal = 0;
                            lastDiff = diff;
                        } else {
                            lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.
                            lastDiff = timelinesRotation[((i + 1) | 0)]; // Difference between bones.
                        }
                        var current = diff > 0, dir = lastTotal >= 0;
                        // Detect cross at 0 (not 180).
                        if (Bridge.Int.sign(lastDiff) !== Bridge.Int.sign(diff) && Math.abs(lastDiff) <= 90) {
                            // A cross after a 360 rotation is a loop.
                            if (Math.abs(lastTotal) > 180) {
                                lastTotal += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                            }
                            dir = current;
                        }
                        total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.
                        if (dir !== current) {
                            total += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                        }
                        timelinesRotation[i] = total;
                    }
                    timelinesRotation[((i + 1) | 0)] = diff;
                    r1 += total * alpha;
                    bone.rotation = r1 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                },
                /*Spine.AnimationState.ApplyRotateTimeline:static end.*/


            }
        },
        fields: {
            data: null,
            tracks: null,
            events: null,
            queue: null,
            propertyIDs: null,
            animationsChanged: false,
            timeScale: 0,
            unkeyedState: 0,
            trackEntryPool: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            /**
             * <p>Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
             or faster. Defaults to 1.</p><p>See TrackEntry {@link } for affecting a single animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function TimeScale
             * @type number
             */
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            /**
             * The AnimationStateData to look up mix durations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function Data
             * @type Spine.AnimationStateData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#get", this ); }

                    return this.data;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#set", this ); }

                    if (this.data == null) {
                        throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                    }
                    this.data = value;
                }
            },
            /**
             * A list of tracks that have animations, which may contain nulls.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationState
             * @function Tracks
             * @type Spine.ExposedList$1
             */
            Tracks: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Tracks#get", this ); }

                    return this.tracks;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                this.tracks = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.Event)).ctor();
                this.propertyIDs = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.timeScale = 1;
                this.trackEntryPool = new (Spine.Pool$1(Spine.TrackEntry))();
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;
                this.queue = new Spine.EventQueue(this, Bridge.fn.bind(this, function () {
                    this.animationsChanged = true;
                }), this.trackEntryPool);
            }
        },
        methods: {
            /*Spine.AnimationState.OnStart start.*/
            OnStart: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(entry);
                }
            },
            /*Spine.AnimationState.OnStart end.*/

            /*Spine.AnimationState.OnInterrupt start.*/
            OnInterrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(entry);
                }
            },
            /*Spine.AnimationState.OnInterrupt end.*/

            /*Spine.AnimationState.OnEnd start.*/
            OnEnd: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(entry);
                }
            },
            /*Spine.AnimationState.OnEnd end.*/

            /*Spine.AnimationState.OnDispose start.*/
            OnDispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(entry);
                }
            },
            /*Spine.AnimationState.OnDispose end.*/

            /*Spine.AnimationState.OnComplete start.*/
            OnComplete: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(entry);
                }
            },
            /*Spine.AnimationState.OnComplete end.*/

            /*Spine.AnimationState.OnEvent start.*/
            OnEvent: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(entry, e);
                }
            },
            /*Spine.AnimationState.OnEvent end.*/

            /*Spine.AnimationState.AssignEventSubscribersFrom start.*/
            AssignEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AssignEventSubscribersFrom", this ); }

                this.Event = src.Event;
                this.Start = src.Start;
                this.Interrupt = src.Interrupt;
                this.End = src.End;
                this.Dispose = src.Dispose;
                this.Complete = src.Complete;
            },
            /*Spine.AnimationState.AssignEventSubscribersFrom end.*/

            /*Spine.AnimationState.AddEventSubscribersFrom start.*/
            AddEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEventSubscribersFrom", this ); }

                this.addEvent(src.Event);
                this.addStart(src.Start);
                this.addInterrupt(src.Interrupt);
                this.addEnd(src.End);
                this.addDispose(src.Dispose);
                this.addComplete(src.Complete);
            },
            /*Spine.AnimationState.AddEventSubscribersFrom end.*/

            /*Spine.AnimationState.Update start.*/
            /**
             * Increments the track entry {@link }, setting queued animations as current if needed.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    delta    delta time
             * @return  {void}
             */
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Update", this ); }

                delta *= this.timeScale;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null) {
                        continue;
                    }

                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;

                    var currentDelta = delta * current.timeScale;

                    if (current.delay > 0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0) {
                            continue;
                        }
                        currentDelta = -current.delay;
                        current.delay = 0;
                    }

                    var next = current.next;
                    if (next != null) {
                        // When the next entry's delay is passed, change to the next entry, preserving leftover time.
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0) {
                            next.delay = 0;
                            next.trackTime += current.timeScale === 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
                            current.trackTime += currentDelta;
                            this.SetCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += delta;
                                next = next.mixingFrom;
                            }
                            continue;
                        }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        // Clear the track when there is no next entry, the track end time is reached, and there is no mixingFrom.
                        tracksItems[i] = null;
                        this.queue.End(current);
                        this.DisposeNext(current);
                        continue;
                    }
                    if (current.mixingFrom != null && this.UpdateMixingFrom(current, delta)) {
                        // End mixing from entries once all have completed.
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        if (from != null) {
                            from.mixingTo = null;
                        }
                        while (from != null) {
                            this.queue.End(from);
                            from = from.mixingFrom;
                        }
                    }

                    current.trackTime += currentDelta;
                }

                this.queue.Drain();
            },
            /*Spine.AnimationState.Update end.*/

            /*Spine.AnimationState.UpdateMixingFrom start.*/
            /**
             * Returns true when all mixing from entries are complete.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to       
             * @param   {number}              delta
             * @return  {boolean}
             */
            UpdateMixingFrom: function (to, delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#UpdateMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from == null) {
                    return true;
                }

                var finished = this.UpdateMixingFrom(from, delta);

                from.animationLast = from.nextAnimationLast;
                from.trackLast = from.nextTrackLast;

                // Require mixTime > 0 to ensure the mixing from entry was applied at least once.
                if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
                    // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).
                    if (from.totalAlpha === 0 || to.mixDuration === 0) {
                        to.mixingFrom = from.mixingFrom;
                        if (from.mixingFrom != null) {
                            from.mixingFrom.mixingTo = to;
                        }
                        to.interruptAlpha = from.interruptAlpha;
                        this.queue.End(from);
                    }
                    return finished;
                }

                from.trackTime += delta * from.timeScale;
                to.mixTime += delta;
                return false;
            },
            /*Spine.AnimationState.UpdateMixingFrom end.*/

            /*Spine.AnimationState.Apply start.*/
            /**
             * Poses the skeleton using the track entry animations.  The animation state is not changed, so can be applied to multiple
             skeletons to pose them identically.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton
             * @return  {boolean}                       True if any animations were applied.
             */
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                if (this.animationsChanged) {
                    this.AnimationsChanged();
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Track 0 animations aren't for layering, so do not show the previously applied animations before the first key.
                    var blend = i === 0 ? Spine.MixBlend.First : current.mixBlend;

                    // Apply mixing from entries first.
                    var mix = current.alpha;
                    if (current.mixingFrom != null) {
                        mix *= this.ApplyMixingFrom(current, skeleton, blend);
                    } else {
                        if (current.trackTime >= current.trackEnd && current.next == null) {
                            mix = 0;
                        }
                    } // Set to setup pose the last time the entry will be applied.

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime;
                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines;
                    var timelinesItems = timelines.Items;
                    if ((i === 0 && mix === 1) || blend === Spine.MixBlend.Add) {
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelinesItems[ii];
                            if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                                this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, animationTime, blend, true);
                            } else {
                                timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, mix, blend, Spine.MixDirection.In);
                            }
                        }
                    } else {
                        var timelineMode = current.timelineMode.Items;

                        var firstFrame = current.timelinesRotation.Count !== timelineCount << 1;
                        if (firstFrame) {
                            current.timelinesRotation.Resize(timelines.Count << 1);
                        }
                        var timelinesRotation = current.timelinesRotation.Items;

                        for (var ii1 = 0; ii1 < timelineCount; ii1 = (ii1 + 1) | 0) {
                            var timeline1 = timelinesItems[ii1];
                            var timelineBlend = timelineMode[ii1] === Spine.AnimationState.Subsequent ? blend : Spine.MixBlend.Setup;
                            var rotateTimeline = Bridge.as(timeline1, Spine.RotateTimeline);
                            if (rotateTimeline != null) {
                                Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii1 << 1, firstFrame);
                            } else {
                                if (Bridge.is(timeline1, Spine.AttachmentTimeline)) {
                                    this.ApplyAttachmentTimeline(Bridge.cast(timeline1, Spine.AttachmentTimeline), skeleton, animationTime, blend, true);
                                } else {
                                    timeline1.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, Spine.MixDirection.In);
                                }
                            }
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so
                // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or
                // the time is before the first key).
                var setupState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                var slots = skeleton.slots.Items;
                for (var i1 = 0, n1 = skeleton.slots.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var slot = slots[i1];
                    if (slot.attachmentState === setupState) {
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = (attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName));
                    }
                }
                this.unkeyedState = (this.unkeyedState + 2) | 0; // Increasing after each use avoids the need to reset attachmentState for every slot.

                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.Apply end.*/

            /*Spine.AnimationState.ApplyEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton
             * @return  {boolean}
             */
            ApplyEventTimelinesOnly: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyEventTimelinesOnly", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Apply mixing from entries first.
                    if (current.mixingFrom != null) {
                        this.ApplyMixingFromEventTimelinesOnly(current, skeleton);
                    }

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime;
                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines;
                    var timelinesItems = timelines.Items;
                    for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                        var timeline = timelinesItems[ii];
                        if (Bridge.is(timeline, Spine.EventTimeline)) {
                            timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, events, 1.0, Spine.MixBlend.Setup, Spine.MixDirection.In);
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.ApplyEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyMixingFrom start.*/
            ApplyMixingFrom: function (to, skeleton, blend) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFrom(from, skeleton, blend);
                }

                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                    if (blend === Spine.MixBlend.First) {
                        blend = Spine.MixBlend.Setup;
                    } // Tracks > 0 are transparent and can't reset to setup pose.
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                    if (blend !== Spine.MixBlend.First) {
                        blend = from.mixBlend;
                    } // Track 0 ignores track mix blend.
                }

                var eventBuffer = mix < from.eventThreshold ? this.events : null;
                var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
                var animationLast = from.animationLast, animationTime = from.AnimationTime;
                var timelines = from.animation.timelines;
                var timelineCount = timelines.Count;
                var timelinesItems = timelines.Items;
                var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);

                if (blend === Spine.MixBlend.Add) {
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        timelinesItems[i].Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, alphaMix, blend, Spine.MixDirection.Out);
                    }
                } else {
                    var timelineMode = from.timelineMode.Items;
                    var timelineHoldMix = from.timelineHoldMix.Items;

                    var firstFrame = from.timelinesRotation.Count !== timelineCount << 1;
                    if (firstFrame) {
                        from.timelinesRotation.Resize(timelines.Count << 1);
                    } // from.timelinesRotation.setSize
                    var timelinesRotation = from.timelinesRotation.Items;

                    from.totalAlpha = 0;
                    for (var i1 = 0; i1 < timelineCount; i1 = (i1 + 1) | 0) {
                        var timeline = timelinesItems[i1];
                        var direction = Spine.MixDirection.Out;
                        var timelineBlend = new Spine.MixBlend();
                        var alpha;
                        switch (timelineMode[i1]) {
                            case Spine.AnimationState.Subsequent: 
                                if (!drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline)) {
                                    continue;
                                }
                                timelineBlend = blend;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.First: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.HoldSubsequent: 
                                timelineBlend = blend;
                                alpha = alphaHold;
                                break;
                            case Spine.AnimationState.HoldFirst: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaHold;
                                break;
                            default:  // HoldMix
                                timelineBlend = Spine.MixBlend.Setup;
                                var holdMix = timelineHoldMix[i1];
                                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
                                break;
                        }
                        from.totalAlpha += alpha;
                        var rotateTimeline = Bridge.as(timeline, Spine.RotateTimeline);
                        if (rotateTimeline != null) {
                            Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i1 << 1, firstFrame);
                        } else if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                            this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, animationTime, timelineBlend, attachments);
                        } else {
                            if (drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline) && timelineBlend === Spine.MixBlend.Setup) {
                                direction = Spine.MixDirection.In;
                            }
                            timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, alpha, timelineBlend, direction);
                        }
                    }
                }

                if (to.mixDuration > 0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFrom end.*/

            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to          
             * @param   {Spine.Skeleton}      skeleton
             * @return  {number}
             */
            ApplyMixingFromEventTimelinesOnly: function (to, skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFromEventTimelinesOnly", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFromEventTimelinesOnly(from, skeleton);
                }

                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                }

                var eventBuffer = mix < from.eventThreshold ? this.events : null;
                if (eventBuffer == null) {
                    return mix;
                }

                var animationLast = from.animationLast, animationTime = from.AnimationTime;
                var timelines = from.animation.timelines;
                var timelineCount = timelines.Count;
                var timelinesItems = timelines.Items;
                for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                    var timeline = timelinesItems[i];
                    if (Bridge.is(timeline, Spine.EventTimeline)) {
                        timeline.Spine$Timeline$Apply(skeleton, animationLast, animationTime, eventBuffer, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                    }
                }

                if (to.mixDuration > 0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyAttachmentTimeline start.*/
            
            ApplyAttachmentTimeline: function (timeline, skeleton, time, blend, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyAttachmentTimeline", this ); }

                var $t;

                var slot = ($t = skeleton.slots.Items)[timeline.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = timeline.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName, attachments);
                    }
                } else {
                    var frameIndex;
                    if (time >= frames[((frames.length - 1) | 0)]) {
                        frameIndex = (frames.length - 1) | 0;
                    } else {
                        frameIndex = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                    }
                    this.SetAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
                }

                // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.
                if (slot.attachmentState <= this.unkeyedState) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                }
            },
            /*Spine.AnimationState.ApplyAttachmentTimeline end.*/

            /*Spine.AnimationState.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName);
                if (attachments) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Current) | 0;
                }
            },
            /*Spine.AnimationState.SetAttachment end.*/

            /*Spine.AnimationState.QueueEvents start.*/
            QueueEvents: function (entry, animationTime) {
if ( TRACE ) { TRACE( "Spine.AnimationState#QueueEvents", this ); }

                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;

                // Queue events before complete.
                var events = this.events;
                var eventsItems = events.Items;
                var i = 0, n = events.Count;
                for (; i < n; i = (i + 1) | 0) {
                    var e = eventsItems[i];
                    if (e.time < trackLastWrapped) {
                        break;
                    }
                    if (e.time > animationEnd) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, e);
                }

                // Queue complete if completed a loop iteration or the animation.
                var complete = false;
                if (entry.loop) {
                    complete = duration === 0 || (trackLastWrapped > entry.trackTime % duration);
                } else {
                    complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
                }
                if (complete) {
                    this.queue.Complete(entry);
                }

                // Queue events after complete.
                for (; i < n; i = (i + 1) | 0) {
                    var e1 = eventsItems[i];
                    if (e1.time < animationStart) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, eventsItems[i]);
                }
            },
            /*Spine.AnimationState.QueueEvents end.*/

            /*Spine.AnimationState.ClearTracks start.*/
            /**
             * <p>Removes all animations from all tracks, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @return  {void}
             */
            ClearTracks: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTracks", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    this.ClearTrack(i);
                }
                this.tracks.Clear();
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTracks end.*/

            /*Spine.AnimationState.ClearTrack start.*/
            /**
             * <p>Removes all animations from the track, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    trackIndex
             * @return  {void}
             */
            ClearTrack: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTrack", this ); }

                var $t, $t1;
                if (trackIndex >= this.tracks.Count) {
                    return;
                }
                var current = ($t = this.tracks.Items)[trackIndex];
                if (current == null) {
                    return;
                }

                this.queue.End(current);

                this.DisposeNext(current);

                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) {
                        break;
                    }
                    this.queue.End(from);
                    entry.mixingFrom = null;
                    entry.mixingTo = null;
                    entry = from;
                }

                ($t1 = this.tracks.Items)[current.trackIndex] = null;

                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTrack end.*/

            /*Spine.AnimationState.SetCurrent start.*/
            /**
             * Sets the active TrackEntry for a given track number.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              index        
             * @param   {Spine.TrackEntry}    current      
             * @param   {boolean}             interrupt
             * @return  {void}
             */
            SetCurrent: function (index, current, interrupt) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetCurrent", this ); }

                var $t;
                var from = this.ExpandToIndex(index);
                ($t = this.tracks.Items)[index] = current;

                if (from != null) {
                    if (interrupt) {
                        this.queue.Interrupt(from);
                    }
                    current.mixingFrom = from;
                    from.mixingTo = current;
                    current.mixTime = 0;

                    // Store the interrupted mix percentage.
                    if (from.mixingFrom != null && from.mixDuration > 0) {
                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    }

                    from.timelinesRotation.Clear(); // Reset rotation for mixing out, in case entry was mixed in.
                }

                this.queue.Start(current); // triggers AnimationsChanged
            },
            /*Spine.AnimationState.SetCurrent end.*/

            /*Spine.AnimationState.SetAnimation$1 start.*/
            /**
             * Sets an animation by name. <seealso cref="SetAnimation(int, Animation, bool)" />
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop
             * @return  {Spine.TrackEntry}
             * @see {@link SetAnimation(int, Animation, bool)}
             */
            SetAnimation$1: function (trackIndex, animationName, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.SetAnimation(trackIndex, animation, loop);
            },
            /*Spine.AnimationState.SetAnimation$1 end.*/

            /*Spine.AnimationState.SetAnimation start.*/
            /**
             * Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
             applied to a skeleton, it is replaced (not mixed from).
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
                      duration. In either case{@link } determines when the track is cleared.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
                      after the {@link } event occurs.
             */
            SetAnimation: function (trackIndex, animation, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation", this ); }

                var $t;
                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }
                var interrupt = true;
                var current = this.ExpandToIndex(trackIndex);
                if (current != null) {
                    if (current.nextTrackLast === -1) {
                        // Don't mix from an entry that was never applied.
                        ($t = this.tracks.Items)[trackIndex] = current.mixingFrom;
                        this.queue.Interrupt(current);
                        this.queue.End(current);
                        this.DisposeNext(current);
                        current = current.mixingFrom;
                        interrupt = false; // mixingFrom is current again, but don't interrupt it twice.
                    } else {
                        this.DisposeNext(current);
                    }
                }
                var entry = this.NewTrackEntry(trackIndex, animation, loop, current);
                this.SetCurrent(trackIndex, entry, interrupt);
                this.queue.Drain();
                return entry;
            },
            /*Spine.AnimationState.SetAnimation end.*/

            /*Spine.AnimationState.AddAnimation$1 start.*/
            /**
             * Queues an animation by name.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop             
             * @param   {number}              delay
             * @return  {Spine.TrackEntry}
             * @see {@link AddAnimation(int, Animation, bool, float)}
             */
            AddAnimation$1: function (trackIndex, animationName, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.AddAnimation(trackIndex, animation, loop, delay);
            },
            /*Spine.AnimationState.AddAnimation$1 end.*/

            /*Spine.AnimationState.AddAnimation start.*/
            /**
             * Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
             equivalent to calling {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {number}              delay         If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration (from the {@link AnimationStateData}) plus the specified <pre><code>Delay</code></pre> (ie the mix
             ends at (<pre><code>Delay</code></pre> = 0) or before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the
             previous entry is looping, its next loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             */
            AddAnimation: function (trackIndex, animation, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation", this ); }

                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }

                var last = this.ExpandToIndex(trackIndex);
                if (last != null) {
                    while (last.next != null) {
                        last = last.next;
                    }
                }

                var entry = this.NewTrackEntry(trackIndex, animation, loop, last);

                if (last == null) {
                    this.SetCurrent(trackIndex, entry, true);
                    this.queue.Drain();
                } else {
                    last.next = entry;
                    if (delay <= 0) {
                        var duration = last.animationEnd - last.animationStart;
                        if (duration !== 0) {
                            if (last.loop) {
                                delay += duration * (((1 + Bridge.Int.clip32((last.trackTime / duration))) | 0)); // Completion of next loop.
                            } else {
                                delay += Math.max(duration, last.trackTime); // After duration, else next update.
                            }
                            delay -= this.data.GetMix(last.animation, animation);
                        } else {
                            delay = last.trackTime;
                        } // Next update.
                    }
                }

                entry.delay = delay;
                return entry;
            },
            /*Spine.AnimationState.AddAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimation start.*/
            /**
             * <p>Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
             {@link }. An empty animation has no timelines and serves as a placeholder for mixing in or out.</p><p>Mixing out is done by setting an empty animation with a mix duration using either {@link },
             {@link }, or {@link }. Mixing to an empty animation causes
             the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
             transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
             0 still mixes out over one frame.</p><p>Mixing in is done by first setting an empty animation, then adding an animation using
             {@link } and on the returned track entry, set the
             {@link }. Mixing from an empty animation causes the new animation to be applied more and
             more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
             setup pose value if no lower tracks key the property to the value keyed in the new animation.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     
             * @param   {number}              mixDuration
             * @return  {Spine.TrackEntry}
             */
            SetEmptyAnimation: function (trackIndex, mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimation", this ); }

                var entry = this.SetAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.SetEmptyAnimation end.*/

            /*Spine.AnimationState.AddEmptyAnimation start.*/
            /**
             * Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
             {@link }. If the track is empty, it is equivalent to calling
             {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     Track number.
             * @param   {number}              mixDuration    Mix duration.
             * @param   {number}              delay          If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration plus the specified <pre><code>Delay</code></pre> (ie the mix ends at (<pre><code>Delay</code></pre> = 0) or
             before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the previous entry is looping, its next
             loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                   A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             * @see {@link AnimationState.SetEmptyAnimation(int, float)}
             */
            AddEmptyAnimation: function (trackIndex, mixDuration, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEmptyAnimation", this ); }

                if (delay <= 0) {
                    delay -= mixDuration;
                }
                var entry = this.AddAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false, delay);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.AddEmptyAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimations start.*/
            /**
             * Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
             duration.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    mixDuration
             * @return  {void}
             */
            SetEmptyAnimations: function (mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimations", this ); }

                var $t;
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = ($t = this.tracks.Items)[i];
                    if (current != null) {
                        this.SetEmptyAnimation(current.trackIndex, mixDuration);
                    }
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.SetEmptyAnimations end.*/

            /*Spine.AnimationState.ExpandToIndex start.*/
            ExpandToIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ExpandToIndex", this ); }

                var $t;
                if (index < this.tracks.Count) {
                    return ($t = this.tracks.Items)[index];
                }
                this.tracks.Resize(((index + 1) | 0));
                return null;
            },
            /*Spine.AnimationState.ExpandToIndex end.*/

            /*Spine.AnimationState.NewTrackEntry start.*/
            /**
             * Object-pooling version of new TrackEntry. Obtain an unused TrackEntry from the pool and clear/initialize its values.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {Spine.TrackEntry}    last          May be null.
             * @return  {Spine.TrackEntry}
             */
            NewTrackEntry: function (trackIndex, animation, loop, last) {
if ( TRACE ) { TRACE( "Spine.AnimationState#NewTrackEntry", this ); }

                var entry = this.trackEntryPool.Obtain(); // Pooling
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.holdPrevious = false;

                entry.eventThreshold = 0;
                entry.attachmentThreshold = 0;
                entry.drawOrderThreshold = 0;

                entry.animationStart = 0;
                entry.animationEnd = animation.Duration;
                entry.animationLast = -1;
                entry.nextAnimationLast = -1;

                entry.delay = 0;
                entry.trackTime = 0;
                entry.trackLast = -1;
                entry.nextTrackLast = -1; // nextTrackLast == -1 signifies a TrackEntry that wasn't applied yet.
                entry.trackEnd = 3.40282347E+38; // loop ? float.MaxValue : animation.Duration;
                entry.timeScale = 1;

                entry.alpha = 1;
                entry.interruptAlpha = 1;
                entry.mixTime = 0;
                entry.mixDuration = (last == null) ? 0 : this.data.GetMix(last.animation, animation);
                return entry;
            },
            /*Spine.AnimationState.NewTrackEntry end.*/

            /*Spine.AnimationState.DisposeNext start.*/
            /**
             * Dispose all track entries queued after the given TrackEntry.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    entry
             * @return  {void}
             */
            DisposeNext: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#DisposeNext", this ); }

                var next = entry.next;
                while (next != null) {
                    this.queue.Dispose(next);
                    next = next.next;
                }
                entry.next = null;
            },
            /*Spine.AnimationState.DisposeNext end.*/

            /*Spine.AnimationState.AnimationsChanged start.*/
            AnimationsChanged: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#AnimationsChanged", this ); }

                this.animationsChanged = false;

                // Process in the order that animations are applied.
                this.propertyIDs.clear();

                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry == null) {
                        continue;
                    }
                    while (entry.mixingFrom != null) {
                        entry = entry.mixingFrom;
                    }

                    do {
                        if (entry.mixingTo == null || entry.mixBlend !== Spine.MixBlend.Add) {
                            this.ComputeHold(entry);
                        }
                        entry = entry.mixingTo;
                    } while (entry != null);
                }
            },
            /*Spine.AnimationState.AnimationsChanged end.*/

            /*Spine.AnimationState.ComputeHold start.*/
            ComputeHold: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ComputeHold", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    to, 
                    timelines, 
                    timelinesCount, 
                    timelineMode, 
                    timelineHoldMix, 
                    propertyIDs, 
                    i1, 
                    timeline, 
                    id, 
                    next, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,12,14,16,17], $step);
                            switch ($step) {
                                case 0: {
                                    to = entry.mixingTo;
                                    timelines = entry.animation.timelines.Items;
                                    timelinesCount = entry.animation.timelines.Count;
                                    timelineMode = entry.timelineMode.Resize(timelinesCount).Items; //timelineMode.setSize(timelinesCount);
                                    entry.timelineHoldMix.Clear();
                                    timelineHoldMix = entry.timelineHoldMix.Resize(timelinesCount).Items; //timelineHoldMix.setSize(timelinesCount);
                                    propertyIDs = this.propertyIDs;

                                    if (to != null && to.holdPrevious) {
                                        for (var i = 0; i < timelinesCount; i = (i + 1) | 0) {
                                            timelineMode[i] = propertyIDs.add(timelines[i].Spine$Timeline$PropertyId) ? Spine.AnimationState.HoldFirst : Spine.AnimationState.HoldSubsequent;
                                        }

                                        return;
                                    }

                                    // outer:
                                    i1 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i1 < timelinesCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 17;
                                    continue;
                                }
                                case 2: {
                                    timeline = timelines[i1];
                                    id = timeline.Spine$Timeline$PropertyId;
                                    if (!propertyIDs.add(id)) {
                                        $step = 3;
                                        continue;
                                    } else  {
                                        $step = 4;
                                        continue;
                                    }
                                }
                                case 3: {
                                    timelineMode[i1] = Spine.AnimationState.Subsequent;
                                    $step = 14;
                                    continue;
                                }
                                case 4: {
                                    if (to == null || Bridge.is(timeline, Spine.AttachmentTimeline) || Bridge.is(timeline, Spine.DrawOrderTimeline) || Bridge.is(timeline, Spine.EventTimeline) || !to.animation.HasTimeline(id)) {
                                        $step = 5;
                                        continue;
                                    } else  {
                                        $step = 6;
                                        continue;
                                    }
                                }
                                case 5: {
                                    timelineMode[i1] = Spine.AnimationState.First;
                                    $step = 13;
                                    continue;
                                }
                                case 6: {
                                    next = to.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    if ( next != null ) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 12;
                                    continue;
                                }
                                case 8: {
                                    if (next.animation.HasTimeline(id)) {
                                        $step = 11;
                                        continue;
                                    }
                                    if (next.mixDuration > 0) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 10;
                                    continue;
                                }
                                case 9: {
                                    timelineMode[i1] = Spine.AnimationState.HoldMix;
                                    timelineHoldMix[i1] = next;
                                    $step = 15;
                                    continue;// continue outer;
                                    $step = 10;
                                    continue;
                                }
                                case 10: {
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    next = next.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 12: {
                                    timelineMode[i1] = Spine.AnimationState.HoldFirst;
                                    $step = 13;
                                    continue;
                                }

                                case 14: {

                                }

                                case 16: {
                                    i1 = (i1 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 17: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.AnimationState.ComputeHold end.*/

            /*Spine.AnimationState.GetCurrent start.*/
            /**
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex
             * @return  {Spine.TrackEntry}                  The track entry for the animation currently playing on the track, or null if no animation is currently playing.
             */
            GetCurrent: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#GetCurrent", this ); }

                var $t;
                if (trackIndex >= this.tracks.Count) {
                    return null;
                }
                return ($t = this.tracks.Items)[trackIndex];
            },
            /*Spine.AnimationState.GetCurrent end.*/

            /*Spine.AnimationState.ClearListenerNotifications start.*/
            
            ClearListenerNotifications: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearListenerNotifications", this ); }

                this.queue.Clear();
            },
            /*Spine.AnimationState.ClearListenerNotifications end.*/

            /*Spine.AnimationState.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#toString", this ); }

                var $t;
                var buffer = new System.Text.StringBuilder();
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var entry = ($t = this.tracks.Items)[i];
                    if (entry == null) {
                        continue;
                    }
                    if (buffer.getLength() > 0) {
                        buffer.append(", ");
                    }
                    buffer.append(entry.toString());
                }
                if (buffer.getLength() === 0) {
                    return "<none>";
                }
                return buffer.toString();
            },
            /*Spine.AnimationState.toString end.*/


        },
        overloads: {
            "SetAnimation(int, string, bool)": "SetAnimation$1",
            "AddAnimation(int, string, bool, float)": "AddAnimation$1",
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationState end.*/

    /*Spine.AnimationStateData start.*/
    /**
     * Stores mix (crossfade) durations to be applied when AnimationState animations are changed.
     *
     * @public
     * @class Spine.AnimationStateData
     */
    Bridge.define("Spine.AnimationStateData", {
        fields: {
            skeletonData: null,
            animationToMixTime: null,
            defaultMix: 0
        },
        props: {
            /**
             * The SkeletonData to look up animations when they are specified by name.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationStateData
             * @function SkeletonData
             * @type Spine.SkeletonData
             */
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SkeletonData#get", this ); }

                    return this.skeletonData;
                }
            },
            /**
             * The mix duration to use when no mix duration has been specifically defined between two animations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationStateData
             * @function DefaultMix
             * @type number
             */
            DefaultMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#get", this ); }

                    return this.defaultMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#set", this ); }

                    this.defaultMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#init", this ); }

                this.animationToMixTime = new (System.Collections.Generic.Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single)).$ctor3(Spine.AnimationStateData.AnimationPairComparer.Instance);
            },
            ctor: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#ctor", this ); }

                this.$initialize();
                if (skeletonData == null) {
                    throw new System.ArgumentException.$ctor3("skeletonData cannot be null.", "skeletonData");
                }
                this.skeletonData = skeletonData;
            }
        },
        methods: {
            /*Spine.AnimationStateData.SetMix$1 start.*/
            /**
             * Sets a mix duration by animation names.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {string}    fromName    
             * @param   {string}    toName      
             * @param   {number}    duration
             * @return  {void}
             */
            SetMix$1: function (fromName, toName, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix$1", this ); }

                var from = this.skeletonData.FindAnimation(fromName);
                if (from == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (fromName || ""), "fromName");
                }
                var to = this.skeletonData.FindAnimation(toName);
                if (to == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (toName || ""), "toName");
                }
                this.SetMix(from, to, duration);
            },
            /*Spine.AnimationStateData.SetMix$1 end.*/

            /*Spine.AnimationStateData.SetMix start.*/
            /**
             * Sets a mix duration when changing from the specified animation to the other.
             See TrackEntry.MixDuration.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from        
             * @param   {Spine.Animation}    to          
             * @param   {number}             duration
             * @return  {void}
             */
            SetMix: function (from, to, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                this.animationToMixTime.remove(key);
                this.animationToMixTime.add(key, duration);
            },
            /*Spine.AnimationStateData.SetMix end.*/

            /*Spine.AnimationStateData.GetMix start.*/
            /**
             * The mix duration to use when changing from the specified animation to the other,
             or the DefaultMix if no mix duration has been set.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from    
             * @param   {Spine.Animation}    to
             * @return  {number}
             */
            GetMix: function (from, to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#GetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                var duration = { };
                if (this.animationToMixTime.tryGetValue(key, duration)) {
                    return duration.v;
                }
                return this.defaultMix;
            },
            /*Spine.AnimationStateData.GetMix end.*/


        },
        overloads: {
            "SetMix(string, string, float)": "SetMix$1"
        }
    });
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPair", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getDefaultValue", this ); }
 return new Spine.AnimationStateData.AnimationPair(); }
            }
        },
        fields: {
            a1: null,
            a2: null
        },
        ctors: {
            $ctor1: function (a1, a2) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$ctor1", this ); }

                this.$initialize();
                this.a1 = a1;
                this.a2 = a2;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.AnimationStateData+AnimationPair.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#toString", this ); }

                return (this.a1.name || "") + "->" + (this.a2.name || "");
            },
            /*Spine.AnimationStateData+AnimationPair.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getHashCode", this ); }

                var h = Bridge.addHash([5472793474, this.a1, this.a2]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#equals", this ); }

                if (!Bridge.is(o, Spine.AnimationStateData.AnimationPair)) {
                    return false;
                }
                return Bridge.equals(this.a1, o.a1) && Bridge.equals(this.a2, o.a2);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$clone", this ); }

                var s = to || new Spine.AnimationStateData.AnimationPair();
                s.a1 = this.a1;
                s.a2 = this.a2;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AtlasRegion start.*/
    Bridge.define("Spine.AtlasRegion", {
        fields: {
            page: null,
            name: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            u: 0,
            v: 0,
            u2: 0,
            v2: 0,
            offsetX: 0,
            offsetY: 0,
            originalWidth: 0,
            originalHeight: 0,
            index: 0,
            rotate: false,
            degrees: 0,
            splits: null,
            pads: null
        },
        methods: {
            /*Spine.AtlasRegion.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasRegion);
            },
            /*Spine.AtlasRegion.Clone end.*/


        }
    });
    /*Spine.AtlasRegion end.*/

    /*Spine.AttachmentLoader start.*/
    Bridge.define("Spine.AttachmentLoader", {
        $kind: "interface"
    });
    /*Spine.AttachmentLoader end.*/

    /*Spine.AtlasPage start.*/
    Bridge.define("Spine.AtlasPage", {
        fields: {
            name: null,
            format: 0,
            minFilter: 0,
            magFilter: 0,
            uWrap: 0,
            vWrap: 0,
            rendererObject: null,
            width: 0,
            height: 0
        },
        methods: {
            /*Spine.AtlasPage.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasPage);
            },
            /*Spine.AtlasPage.Clone end.*/


        }
    });
    /*Spine.AtlasPage end.*/

    /*Spine.Attachment start.*/
    Bridge.define("Spine.Attachment", {
        fields: {
            Name: null
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Attachment#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.Name = name;
            }
        },
        methods: {
            /*Spine.Attachment.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Attachment#toString", this ); }

                return this.Name;
            },
            /*Spine.Attachment.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Attachment end.*/

    /*Spine.ISlotTimeline start.*/
    /**
     * An interface for timelines which change the property of a slot.
     *
     * @abstract
     * @public
     * @class Spine.ISlotTimeline
     */
    Bridge.define("Spine.ISlotTimeline", {
        $kind: "interface"
    });
    /*Spine.ISlotTimeline end.*/

    /*Spine.Timeline start.*/
    /**
     * The interface for all timelines.
     *
     * @abstract
     * @public
     * @class Spine.Timeline
     */
    Bridge.define("Spine.Timeline", {
        $kind: "interface"
    });
    /*Spine.Timeline end.*/

    /*Spine.AttachmentType start.*/
    Bridge.define("Spine.AttachmentType", {
        $kind: "enum",
        statics: {
            fields: {
                Region: 0,
                Boundingbox: 1,
                Mesh: 2,
                Linkedmesh: 3,
                Path: 4,
                Point: 5,
                Clipping: 6
            }
        }
    });
    /*Spine.AttachmentType end.*/

    /*Spine.BlendMode start.*/
    Bridge.define("Spine.BlendMode", {
        $kind: "enum",
        statics: {
            fields: {
                Normal: 0,
                Additive: 1,
                Multiply: 2,
                Screen: 3
            }
        }
    });
    /*Spine.BlendMode end.*/

    /*Spine.IUpdatable start.*/
    /**
     * The interface for items updated by {@link }.
     *
     * @abstract
     * @public
     * @class Spine.IUpdatable
     */
    Bridge.define("Spine.IUpdatable", {
        $kind: "interface"
    });
    /*Spine.IUpdatable end.*/

    /*Spine.BoneData start.*/
    Bridge.define("Spine.BoneData", {
        fields: {
            index: 0,
            name: null,
            parent: null,
            length: 0,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            transformMode: 0,
            skinRequired: false
        },
        props: {
            /**
             * The index of the bone in Skeleton.Bones
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the bone, which is unique across all bones in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * May be null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Parent
             * @type Spine.BoneData
             */
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Parent#get", this ); }

                    return this.parent;
                }
            },
            Length: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#get", this ); }

                    return this.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#set", this ); }

                    this.length = value;
                }
            },
            /**
             * Local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * Local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * Local rotation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * Local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * Local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * Local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * Local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * The transform mode for how parent world transforms affect this bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function TransformMode
             * @type Spine.TransformMode
             */
            TransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#get", this ); }

                    return this.transformMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#set", this ); }

                    this.transformMode = value;
                }
            },
            /**
             * When true, {@link } only updates this bone if the {@link } contains this
             bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Bones}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.transformMode = Spine.TransformMode.Normal;
            },
            /**
             * @instance
             * @public
             * @this Spine.BoneData
             * @memberof Spine.BoneData
             * @param   {number}            index     
             * @param   {string}            name      
             * @param   {Spine.BoneData}    parent    May be null.
             * @return  {void}
             */
            ctor: function (index, name, parent) {
if ( TRACE ) { TRACE( "Spine.BoneData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.parent = parent;
            }
        },
        methods: {
            /*Spine.BoneData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#toString", this ); }

                return this.name;
            },
            /*Spine.BoneData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.BoneData end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: "struct",
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {Spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case Spine.TransformMode.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case Spine.TransformMode.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case Spine.TransformMode.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case Spine.TransformMode.NoScale: 
                        case Spine.TransformMode.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== Spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {TSource}    arg
     * @return  {TKey}
     */


    /*Spine.Collections.CollectionExtensions start.*/
    /** @namespace Spine.Collections */

    /**
     * Provides extensions methods for constructing instances of {@link }.
     *
     * @static
     * @abstract
     * @public
     * @class Spine.Collections.CollectionExtensions
     */
    Bridge.define("Spine.Collections.CollectionExtensions", {
        statics: {
            methods: {
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary:static start.*/
                /**
                 * Creates a new OrderedDictionary from the given collection, using the key selector to extract the key.
                 *
                 * @static
                 * @public
                 * @this Spine.Collections.CollectionExtensions
                 * @memberof Spine.Collections.CollectionExtensions
                 * @param   {Function}                                    TSource        The type of the items in the collection.
                 * @param   {Function}                                    TKey           The type of the key.
                 * @param   {System.Collections.Generic.IEnumerable$1}    source         The items to created the OrderedDictionary from.
                 * @param   {System.Func}                                 keySelector    A delegate that can extract a key from an item in the collection.
                 * @return  {Spine.Collections.OrderedDictionary$2}                      An OrderedDictionary mapping the extracted keys to their values.
                 */
                ToOrderedDictionary: function (TSource, TKey, source, keySelector) {
if ( TRACE ) { TRACE( "Spine.Collections.CollectionExtensions#ToOrderedDictionary", this ); }

                    return Spine.Collections.CollectionExtensions.ToOrderedDictionary$1(TSource, TKey, source, keySelector, null);
                },
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary:static end.*/

                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary$1:static start.*/
                /**
                 * Creates a new OrderedDictionary from the given collection, using the key selector to extract the key.
                 The key comparer is passed to the OrderedDictionary for comparing the extracted keys.
                 *
                 * @static
                 * @public
                 * @this Spine.Collections.CollectionExtensions
                 * @memberof Spine.Collections.CollectionExtensions
                 * @param   {Function}                                          TSource        The type of the items in the collection.
                 * @param   {Function}                                          TKey           The type of the key.
                 * @param   {System.Collections.Generic.IEnumerable$1}          source         The items to created the OrderedDictionary from.
                 * @param   {System.Func}                                       keySelector    A delegate that can extract a key from an item in the collection.
                 * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       The key equality comparer to use to compare keys in the dictionary.
                 * @return  {Spine.Collections.OrderedDictionary$2}                            An OrderedDictionary mapping the extracted keys to their values.
                 */
                ToOrderedDictionary$1: function (TSource, TKey, source, keySelector, comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.CollectionExtensions#ToOrderedDictionary$1", this ); }

                    var $t;
                    if (source == null) {
                        throw new System.ArgumentNullException.$ctor1("source");
                    }
                    if (Bridge.staticEquals(keySelector, null)) {
                        throw new System.ArgumentNullException.$ctor1("keySelector");
                    }
                    var dictionary = new (Spine.Collections.OrderedDictionary$2(TKey,TSource)).$ctor1(comparer);
                    $t = Bridge.getEnumerator(source, TSource);
                    try {
                        while ($t.moveNext()) {
                            var item = Bridge.rValue($t.Current);
                            var key = Bridge.rValue(keySelector(Bridge.rValue(item)));
                            dictionary.add(Bridge.rValue(key), Bridge.rValue(item));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return dictionary;
                },
                /*Spine.Collections.CollectionExtensions.ToOrderedDictionary$1:static end.*/


            }
        }
    });
    /*Spine.Collections.CollectionExtensions end.*/

    /*Spine.Collections.OrderedDictionary$2 start.*/
    /**
     * Represents a dictionary that tracks the order that items were added.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2
     * @implements  System.Collections.Generic.IDictionary$2
     * @implements  System.Collections.Generic.IList$1
     * @param   {Function}    [name]    The type of the dictionary keys.
     * @param   {Function}    [name]    The type of the dictionary values.
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IDictionary$2(TKey,TValue),System.Collections.Generic.IList$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))],
        statics: {
            fields: {
                CollectionModifiedMessage: null,
                EditReadOnlyListMessage: null,
                IndexOutOfRangeMessage: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#init", this ); }

                    this.CollectionModifiedMessage = "Collection was modified; enumeration operation may not execute.";
                    this.EditReadOnlyListMessage = "An attempt was made to edit a read-only list.";
                    this.IndexOutOfRangeMessage = "The index is negative or outside the bounds of the collection.";
                }
            }
        },
        fields: {
            dictionary: null,
            keys: null,
            values: null,
            version: 0
        },
        props: {
            /**
             * Gets the equality comparer used to compare keys.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Comparer
             * @type System.Collections.Generic.IEqualityComparer$1
             */
            Comparer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Comparer#get", this ); }

                    return this.dictionary.Comparer;
                }
            },
            /**
             * Gets the keys in the dictionary in the order they were added.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Keys
             * @type Spine.Collections.OrderedDictionary$2.KeyCollection
             */
            Keys: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Keys#get", this ); }

                    return new (Spine.Collections.OrderedDictionary$2.KeyCollection(TKey,TValue))(this.dictionary);
                }
            },
            /**
             * Gets the values in the dictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Values
             * @type Spine.Collections.OrderedDictionary$2.ValueCollection
             */
            Values: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Values#get", this ); }

                    return new (Spine.Collections.OrderedDictionary$2.ValueCollection(TKey,TValue))(this.values);
                }
            },
            /**
             * Gets the number of key/value pairs in the dictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Count#get", this ); }

                    return this.dictionary.Count;
                }
            },
            System$Collections$Generic$IDictionary$2$Keys: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Keys#get", this ); }

                    return this.Keys;
                }
            },
            System$Collections$Generic$IDictionary$2$Values: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IDictionary$2$Values#get", this ); }

                    return this.Values;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return false;
                }
            }
        },
        alias: [
            "add", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "containsKey", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$containsKey",
            "remove", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove",
            "removeAt", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$removeAt",
            "tryGetValue", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$tryGetValue",
            "getItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "setItem", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "clear", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$clear",
            "Count", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$indexOf",
            "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$insert",
            "System$Collections$Generic$IList$1$getItem", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getItem",
            "System$Collections$Generic$IList$1$setItem", "System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$setItem",
            "System$Collections$Generic$IDictionary$2$Keys", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Keys",
            "System$Collections$Generic$IDictionary$2$Values", "System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$Values",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$contains",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$IsReadOnly", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove", "System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#ctor", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, 0, null);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The capacity is less than zero.
             * @param   {number}    capacity    The initial capacity of the dictionary.
             * @return  {void}
             */
            $ctor2: function (capacity) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor2", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, capacity, null);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    The equality comparer to use to compare keys.
             * @return  {void}
             */
            $ctor1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor1", this ); }

                Spine.Collections.OrderedDictionary$2(TKey,TValue).$ctor3.call(this, 0, comparer);
            },
            /**
             * Initializes a new instance of an OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {number}                                            capacity    The initial capacity of the dictionary.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    The equality comparer to use to compare keys.
             * @return  {void}
             */
            $ctor3: function (capacity, comparer) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#$ctor3", this ); }

                this.$initialize();
                this.dictionary = new (System.Collections.Generic.Dictionary$2(TKey,System.Int32)).$ctor5(capacity, comparer || System.Collections.Generic.EqualityComparer$1(TKey).def);
                this.keys = new (System.Collections.Generic.List$1(TKey)).$ctor2(capacity);
                this.values = new (System.Collections.Generic.List$1(TValue)).$ctor2(capacity);
            }
        },
        methods: {
            /**
             * Gets or sets the value at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- beyond the length of the dictionary.
             * @param   {number}    index    The index of the value to get.
             * @return  {TValue}             The value at the given index.
             */
            getItem$1: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#getItem$1", this ); }

                return Bridge.rValue(this.values.getItem(index));
            },
            /**
             * Gets or sets the value at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- beyond the length of the dictionary.
             * @param   {number}    index    The index of the value to get.
             * @param   {TValue}    value
             * @return  {void}               The value at the given index.
             */
            setItem$1: function (index, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#setItem$1", this ); }

                this.values.setItem(index, Bridge.rValue(value));
            },
            /**
             * Gets or sets the value associated with the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.Collections.Generic.KeyNotFoundException} The key is not in the dictionary.
             * @param   {TKey}      key    The key to get the associated value by or to associate with the value.
             * @return  {TValue}           The value associated with the given key.
             */
            getItem: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#getItem", this ); }

                return Bridge.rValue(this.values.getItem(this.dictionary.getItem(Bridge.rValue(key))));
            },
            /**
             * Gets or sets the value associated with the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.Collections.Generic.KeyNotFoundException} The key is not in the dictionary.
             * @param   {TKey}      key      The key to get the associated value by or to associate with the value.
             * @param   {TValue}    value
             * @return  {void}               The value associated with the given key.
             */
            setItem: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#setItem", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    this.keys.setItem(index.v, Bridge.rValue(key));
                    this.values.setItem(index.v, Bridge.rValue(value));
                } else {
                    this.add(Bridge.rValue(key), Bridge.rValue(value));
                }
            },
            System$Collections$Generic$IList$1$getItem: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$getItem", this ); }

                var key = Bridge.rValue(this.keys.getItem(index));
                var value = Bridge.rValue(this.values.getItem(index));
                return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
            },
            System$Collections$Generic$IList$1$setItem: function (index, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$setItem", this ); }

                var $t;
                var key = Bridge.rValue(this.keys.getItem(index));
                if (($t = this.dictionary.Comparer)[Bridge.geti($t, "System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TKey) + "$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2")](Bridge.rValue(key), Bridge.rValue(value.key))) {
                    this.dictionary.setItem(Bridge.rValue(value.key), index);
                } else {
                    this.dictionary.add(Bridge.rValue(value.key), index); // will throw if key already exists
                    this.dictionary.remove(Bridge.rValue(key));
                }
                this.keys.setItem(index, Bridge.rValue(value.key));
                this.values.setItem(index, Bridge.rValue(value.value));
            },
            /*Spine.Collections.OrderedDictionary$2.add start.*/
            /**
             * Adds the given key/value pair to the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentException} The given key already exists in the dictionary.
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}      key      The key to add to the dictionary.
             * @param   {TValue}    value    The value to associated with the key.
             * @return  {void}
             */
            add: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#add", this ); }

                this.dictionary.add(Bridge.rValue(key), this.values.Count);
                this.keys.add(Bridge.rValue(key));
                this.values.add(Bridge.rValue(value));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.add end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add", this ); }

                this.add(Bridge.rValue(item.key), Bridge.rValue(item.value));
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$add end.*/

            /*Spine.Collections.OrderedDictionary$2.Insert start.*/
            /**
             * Inserts the given key/value pair at the specified index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentException} The given key already exists in the dictionary.
             * @throws {System.ArgumentNullException} The key is null.
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the size of the dictionary.
             * @param   {number}    index    The index to insert the key/value pair.
             * @param   {TKey}      key      The key to insert.
             * @param   {TValue}    value    The value to insert.
             * @return  {void}
             */
            Insert: function (index, key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#Insert", this ); }

                if (index < 0 || index > this.values.Count) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), Spine.Collections.OrderedDictionary$2(TKey,TValue).IndexOutOfRangeMessage);
                }
                this.dictionary.add(Bridge.rValue(key), index);
                for (var keyIndex = index; keyIndex !== this.keys.Count; keyIndex = (keyIndex + 1) | 0) {
                    var otherKey = Bridge.rValue(this.keys.getItem(keyIndex));
                    this.dictionary.setItem(Bridge.rValue(otherKey), (this.dictionary.getItem(Bridge.rValue(otherKey)) + 1) | 0);
                }
                this.keys.insert(index, Bridge.rValue(key));
                this.values.insert(index, Bridge.rValue(value));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.Insert end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert start.*/
            System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert", this ); }

                this.Insert(index, Bridge.rValue(item.key), Bridge.rValue(item.value));
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$insert end.*/

            /*Spine.Collections.OrderedDictionary$2.containsKey start.*/
            /**
             * Determines whether the given key exists in the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key    The key to look for.
             * @return  {boolean}           True if the key exists in the dictionary; otherwise, false.
             */
            containsKey: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#containsKey", this ); }

                return this.dictionary.containsKey(Bridge.rValue(key));
            },
            /*Spine.Collections.OrderedDictionary$2.containsKey end.*/

            /*Spine.Collections.OrderedDictionary$2.GetKey start.*/
            /**
             * Gets the key at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the number of keys.
             * @param   {number}    index    The index of the key to get.
             * @return  {TKey}               The key at the given index.
             */
            GetKey: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#GetKey", this ); }

                return Bridge.rValue(this.keys.getItem(index));
            },
            /*Spine.Collections.OrderedDictionary$2.GetKey end.*/

            /*Spine.Collections.OrderedDictionary$2.IndexOf start.*/
            /**
             * Gets the index of the given key.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @param   {TKey}      key    The key to get the index of.
             * @return  {number}           The index of the key in the dictionary -or- -1 if the key is not found.
             */
            IndexOf: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#IndexOf", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    return index.v;
                }
                return -1;
            },
            /*Spine.Collections.OrderedDictionary$2.IndexOf end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf start.*/
            System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(item.key), index) && Bridge.equals(this.values.getItem(index.v), item.value)) {
                    return index.v;
                }
                return -1;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$IList$1$System$Collections$Generic$KeyValuePair$2$indexOf end.*/

            /*Spine.Collections.OrderedDictionary$2.remove start.*/
            /**
             * Removes the key/value pair with the given key from the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key    The key of the pair to remove.
             * @return  {boolean}           True if the key was found and the pair removed; otherwise, false.
             */
            remove: function (key) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#remove", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    this.removeAt(index.v);
                    return true;
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.remove end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove", this ); }

                var self = this;
                if (System.Array.contains(self, item, System.Collections.Generic.KeyValuePair$2(TKey,TValue))) {
                    return this.remove(Bridge.rValue(item.key));
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$remove end.*/

            /*Spine.Collections.OrderedDictionary$2.removeAt start.*/
            /**
             * Removes the key/value pair at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentOutOfRangeException} The index is negative -or- larger than the size of the dictionary.
             * @param   {number}    index    The index of the key/value pair to remove.
             * @return  {void}
             */
            removeAt: function (index) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#removeAt", this ); }

                var key = Bridge.rValue(this.keys.getItem(index));
                for (var keyIndex = (index + 1) | 0; keyIndex < this.keys.Count; keyIndex = (keyIndex + 1) | 0) {
                    var otherKey = Bridge.rValue(this.keys.getItem(keyIndex));
                    this.dictionary.setItem(Bridge.rValue(otherKey), (this.dictionary.getItem(Bridge.rValue(otherKey)) - 1) | 0);
                }
                this.dictionary.remove(Bridge.rValue(key));
                this.keys.removeAt(index);
                this.values.removeAt(index);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.removeAt end.*/

            /*Spine.Collections.OrderedDictionary$2.tryGetValue start.*/
            /**
             * Tries to get the value associated with the given key. If the key is not found,
             default(TValue) value is stored in the value.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @throws {System.ArgumentNullException} The key is null.
             * @param   {TKey}       key      The key to get the value for.
             * @param   {TValue}     value    The value used to hold the results.
             * @return  {boolean}             True if the key was found; otherwise, false.
             */
            tryGetValue: function (key, value) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#tryGetValue", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(key), index)) {
                    value.v = Bridge.rValue(this.values.getItem(index.v));
                    return true;
                }
                value.v = Bridge.getDefaultValue(TValue);
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.tryGetValue end.*/

            /*Spine.Collections.OrderedDictionary$2.clear start.*/
            /**
             * Removes all key/value pairs from the dictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {void}
             */
            clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#clear", this ); }

                this.dictionary.clear();
                this.keys.clear();
                this.values.clear();
                this.version = (this.version + 1) | 0;
            },
            /*Spine.Collections.OrderedDictionary$2.clear end.*/

            /*Spine.Collections.OrderedDictionary$2.GetEnumerator start.*/
            /**
             * Gets the key/value pairs in the dictionary in the order they were added.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2
             * @memberof Spine.Collections.OrderedDictionary$2
             * @return  {System.Collections.Generic.IEnumerator$1}        An enumerator over the key/value pairs in the dictionary.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#GetEnumerator", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startVersion,
                    index,
                    key,
                    value,
                    $async_e;

                var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue)))(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startVersion = this.version;
                                        index = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( index !== this.keys.Count ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    key = Bridge.rValue(this.keys.getItem(index));
                                        value = Bridge.rValue(this.values.getItem(index));
                                        $enumerator.current = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    if (this.version !== startVersion) {
                                            throw new System.InvalidOperationException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).CollectionModifiedMessage);
                                        }
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    index = (index + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Collections.OrderedDictionary$2.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains", this ); }

                var index = { };
                if (this.dictionary.tryGetValue(Bridge.rValue(item.key), index) && Bridge.equals(this.values.getItem(index.v), item.value)) {
                    return true;
                }
                return false;
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$contains end.*/

            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo start.*/
            System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2#System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo", this ); }

                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (arrayIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("arrayIndex", Bridge.box(arrayIndex, System.Int32), Spine.Collections.OrderedDictionary$2(TKey,TValue).IndexOutOfRangeMessage);
                }
                for (var index = 0; index !== this.keys.Count && arrayIndex < array.length; index = (index + 1) | 0, arrayIndex = (arrayIndex + 1) | 0) {
                    var key = Bridge.rValue(this.keys.getItem(index));
                    var value = Bridge.rValue(this.values.getItem(index));
                    array[arrayIndex] = new (System.Collections.Generic.KeyValuePair$2(TKey,TValue)).$ctor1(Bridge.rValue(key), Bridge.rValue(value));
                }
            },
            /*Spine.Collections.OrderedDictionary$2.System$Collections$Generic$ICollection$1$System$Collections$Generic$KeyValuePair$2$copyTo end.*/


        },
        overloads: {
            "Add(TKey, TValue)": "add",
            "ContainsKey(TKey)": "containsKey",
            "Remove(TKey)": "remove",
            "RemoveAt(int)": "removeAt",
            "TryGetValue(TKey, TValue)": "tryGetValue",
            "Clear()": "clear"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2 end.*/

    /*Spine.Collections.OrderedDictionary$2+KeyCollection start.*/
    /**
     * Wraps the keys in an OrderDictionary.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2.KeyCollection
     * @implements  System.Collections.Generic.ICollection$1
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2.KeyCollection", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.ICollection$1(TKey)],
        $kind: "nested class",
        fields: {
            dictionary: null
        },
        props: {
            /**
             * Gets the number of keys in the OrderedDictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#Count#get", this ); }

                    return this.dictionary.Count;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return true;
                }
            }
        },
        alias: [
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$copyTo",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TKey) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$ICollection$1$contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$contains",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$add",
            "System$Collections$Generic$ICollection$1$clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$clear",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TKey) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of a KeyCollection.
             *
             * @instance
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @throws {System.ArgumentNullException} The dictionary is null.
             * @param   {System.Collections.Generic.Dictionary$2}    dictionary    The OrderedDictionary whose keys to wrap.
             * @return  {void}
             */
            ctor: function (dictionary) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#ctor", this ); }

                this.$initialize();
                this.dictionary = dictionary;
            }
        },
        methods: {
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.copyTo start.*/
            /**
             * Copies the keys from the OrderedDictionary to the given array, starting at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @throws {System.ArgumentNullException} The array is null.
             * @throws {System.ArgumentOutOfRangeException} The arrayIndex is negative.
             * @throws {System.ArgumentException} The array, starting at the given index, is not large enough to contain all the keys.
             * @param   {Array.<TKey>}    array         The array to copy the keys to.
             * @param   {number}          arrayIndex    The index into the array to start copying the keys.
             * @return  {void}
             */
            copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#copyTo", this ); }

                this.dictionary.Keys.copyTo(array, arrayIndex);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.copyTo end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.GetEnumerator start.*/
            /**
             * Gets an enumerator over the keys in the OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.KeyCollection
             * @memberof Spine.Collections.OrderedDictionary$2.KeyCollection
             * @return  {System.Collections.Generic.IEnumerator$1}        The enumerator.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#GetEnumerator", this ); }

                return this.dictionary.Keys.GetEnumerator().$clone();
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$contains start.*/
            System$Collections$Generic$ICollection$1$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$contains", this ); }

                return this.dictionary.containsKey(Bridge.rValue(item));
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$contains end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$add start.*/
            System$Collections$Generic$ICollection$1$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$add", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$add end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$clear start.*/
            System$Collections$Generic$ICollection$1$clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$clear", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$clear end.*/

            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$remove start.*/
            System$Collections$Generic$ICollection$1$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.KeyCollection#System$Collections$Generic$ICollection$1$remove", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+KeyCollection.System$Collections$Generic$ICollection$1$remove end.*/


        },
        overloads: {
            "CopyTo(TKey[], int)": "copyTo"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2+KeyCollection end.*/

    /*Spine.Collections.OrderedDictionary$2+ValueCollection start.*/
    /**
     * Wraps the keys in an OrderDictionary.
     *
     * @public
     * @class Spine.Collections.OrderedDictionary$2.ValueCollection
     * @implements  System.Collections.Generic.ICollection$1
     */
    Bridge.define("Spine.Collections.OrderedDictionary$2.ValueCollection", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.ICollection$1(TValue)],
        $kind: "nested class",
        fields: {
            values: null
        },
        props: {
            /**
             * Gets the number of values in the OrderedDictionary.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#Count#get", this ); }

                    return this.values.Count;
                }
            },
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$IsReadOnly#get", this ); }

                    return true;
                }
            }
        },
        alias: [
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$copyTo",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$Count",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TValue) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "System$Collections$Generic$ICollection$1$contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$contains",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$add",
            "System$Collections$Generic$ICollection$1$clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$clear",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(TValue) + "$remove"
        ],
        ctors: {
            /**
             * Initializes a new instance of a ValueCollection.
             *
             * @instance
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @throws {System.ArgumentNullException} The dictionary is null.
             * @param   {System.Collections.Generic.List$1}    values    The OrderedDictionary whose keys to wrap.
             * @return  {void}
             */
            ctor: function (values) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#ctor", this ); }

                this.$initialize();
                this.values = values;
            }
        },
        methods: {
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.copyTo start.*/
            /**
             * Copies the values from the OrderedDictionary to the given array, starting at the given index.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @throws {System.ArgumentNullException} The array is null.
             * @throws {System.ArgumentOutOfRangeException} The arrayIndex is negative.
             * @throws {System.ArgumentException} The array, starting at the given index, is not large enough to contain all the values.
             * @param   {Array.<TValue>}    array         The array to copy the values to.
             * @param   {number}            arrayIndex    The index into the array to start copying the values.
             * @return  {void}
             */
            copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#copyTo", this ); }

                this.values.copyTo(array, arrayIndex);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.copyTo end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.GetEnumerator start.*/
            /**
             * Gets an enumerator over the values in the OrderedDictionary.
             *
             * @instance
             * @public
             * @this Spine.Collections.OrderedDictionary$2.ValueCollection
             * @memberof Spine.Collections.OrderedDictionary$2.ValueCollection
             * @return  {System.Collections.Generic.IEnumerator$1}        The enumerator.
             */
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#GetEnumerator", this ); }

                return this.values.GetEnumerator().$clone();
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$contains start.*/
            System$Collections$Generic$ICollection$1$contains: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$contains", this ); }

                return this.values.contains(Bridge.rValue(item));
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$contains end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$add start.*/
            System$Collections$Generic$ICollection$1$add: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$add", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$add end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$clear start.*/
            System$Collections$Generic$ICollection$1$clear: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$clear", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$clear end.*/

            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$remove start.*/
            System$Collections$Generic$ICollection$1$remove: function (item) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionary$2.ValueCollection#System$Collections$Generic$ICollection$1$remove", this ); }

                throw new System.NotSupportedException.$ctor1(Spine.Collections.OrderedDictionary$2(TKey,TValue).EditReadOnlyListMessage);
            },
            /*Spine.Collections.OrderedDictionary$2+ValueCollection.System$Collections$Generic$ICollection$1$remove end.*/


        },
        overloads: {
            "CopyTo(TValue[], int)": "copyTo"
        }
    }; });
    /*Spine.Collections.OrderedDictionary$2+ValueCollection end.*/

    /*Spine.Collections.OrderedDictionaryDebugView$2 start.*/
    Bridge.define("Spine.Collections.OrderedDictionaryDebugView$2", function (TKey, TValue) { return {
        fields: {
            dictionary: null
        },
        props: {
            Items: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionaryDebugView$2#Items#get", this ); }

                    var $t;
                    return ($t = System.Collections.Generic.KeyValuePair$2(TKey,TValue), System.Linq.Enumerable.from(this.dictionary, $t).ToArray($t));
                }
            }
        },
        ctors: {
            ctor: function (dictionary) {
if ( TRACE ) { TRACE( "Spine.Collections.OrderedDictionaryDebugView$2#ctor", this ); }

                this.$initialize();
                this.dictionary = dictionary;
            }
        }
    }; });
    /*Spine.Collections.OrderedDictionaryDebugView$2 end.*/

    /*Spine.ConstraintData start.*/
    /**
     * The base class for all constraint datas.
     *
     * @abstract
     * @public
     * @class Spine.ConstraintData
     */
    Bridge.define("Spine.ConstraintData", {
        fields: {
            name: null,
            order: 0,
            skinRequired: false
        },
        props: {
            /**
             * The constraint's name, which is unique across all constraints in the skeleton of the same type.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.ConstraintData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The ordinal of this constraint for the order a skeleton's constraints will be applied by
             {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function Order
             * @type number
             */
            Order: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#get", this ); }

                    return this.order;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#set", this ); }

                    this.order = value;
                }
            },
            /**
             * When true, {@link } only updates this constraint if the {@link } contains
             this constraint.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Constraints}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.ConstraintData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#toString", this ); }

                return this.name;
            },
            /*Spine.ConstraintData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    /**
     * Stores the current pose values for an Event.
     *
     * @public
     * @class Spine.Event
     */
    Bridge.define("Spine.Event", {
        fields: {
            data: null,
            time: 0,
            intValue: 0,
            floatValue: 0,
            stringValue: null,
            volume: 0,
            balance: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The animation time this event was keyed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Event
             * @function Time
             * @type number
             */
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Time#get", this ); }

                    return this.time;
                }
            },
            Int: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Int#get", this ); }

                    return this.intValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Int#set", this ); }

                    this.intValue = value;
                }
            },
            Float: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Float#get", this ); }

                    return this.floatValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Float#set", this ); }

                    this.floatValue = value;
                }
            },
            String: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#String#get", this ); }

                    return this.stringValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#String#set", this ); }

                    this.stringValue = value;
                }
            },
            Volume: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Volume#get", this ); }

                    return this.volume;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Volume#set", this ); }

                    this.volume = value;
                }
            },
            Balance: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Balance#get", this ); }

                    return this.balance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Balance#set", this ); }

                    this.balance = value;
                }
            }
        },
        ctors: {
            ctor: function (time, data) {
if ( TRACE ) { TRACE( "Spine.Event#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.time = time;
                this.data = data;
            }
        },
        methods: {
            /*Spine.Event.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Event#toString", this ); }

                return this.data.Name;
            },
            /*Spine.Event.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    /**
     * Stores the setup pose values for an Event.
     *
     * @public
     * @class Spine.EventData
     */
    Bridge.define("Spine.EventData", {
        fields: {
            name: null,
            Int: 0,
            Float: 0,
            String: null,
            AudioPath: null,
            Volume: 0,
            Balance: 0
        },
        props: {
            /**
             * The name of the event, which is unique across all events in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventData#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.EventData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.EventData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.EventData#toString", this ); }

                return this.Name;
            },
            /*Spine.EventData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.EventData end.*/

    /*Spine.EventQueue start.*/
    Bridge.define("Spine.EventQueue", {
        fields: {
            eventQueueEntries: null,
            drainDisabled: false,
            state: null,
            trackEntryPool: null
        },
        events: {
            AnimationsChanged: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#init", this ); }

                this.eventQueueEntries = new (System.Collections.Generic.List$1(Spine.EventQueue.EventQueueEntry)).ctor();
            },
            ctor: function (state, HandleAnimationsChanged, trackEntryPool) {
if ( TRACE ) { TRACE( "Spine.EventQueue#ctor", this ); }

                this.$initialize();
                this.state = state;
                this.addAnimationsChanged(HandleAnimationsChanged);
                this.trackEntryPool = trackEntryPool;
            }
        },
        methods: {
            /*Spine.EventQueue.Start start.*/
            Start: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Start", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Start, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.Start end.*/

            /*Spine.EventQueue.Interrupt start.*/
            Interrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Interrupt", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Interrupt, entry));
            },
            /*Spine.EventQueue.Interrupt end.*/

            /*Spine.EventQueue.End start.*/
            End: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#End", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.End, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.End end.*/

            /*Spine.EventQueue.Dispose start.*/
            Dispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Dispose", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Dispose, entry));
            },
            /*Spine.EventQueue.Dispose end.*/

            /*Spine.EventQueue.Complete start.*/
            Complete: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Complete", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Complete, entry));
            },
            /*Spine.EventQueue.Complete end.*/

            /*Spine.EventQueue.Event start.*/
            Event: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Event", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Event, entry, e));
            },
            /*Spine.EventQueue.Event end.*/

            /*Spine.EventQueue.Drain start.*/
            /**
             * Raises all events in the queue and drains the queue.
             *
             * @instance
             * @this Spine.EventQueue
             * @memberof Spine.EventQueue
             * @return  {void}
             */
            Drain: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Drain", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    entries, 
                    state, 
                    i, 
                    queueEntry, 
                    trackEntry, 
                    $t, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,10,11], $step);
                            switch ($step) {
                                case 0: {
                                    if (this.drainDisabled) {
                                        return;
                                    }
                                    this.drainDisabled = true;

                                    entries = this.eventQueueEntries;
                                    state = this.state;

                                    // Don't cache entries.Count so callbacks can queue their own events (eg, call SetAnimation in AnimationState_Complete).
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < entries.Count ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 11;
                                    continue;
                                }
                                case 2: {
                                    queueEntry = entries.getItem(i).$clone();
                                    trackEntry = queueEntry.entry;

                                    $t = queueEntry.type;
                                    if ($t === Spine.EventQueue.EventType.Start) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Interrupt) {
                                        $step = 4;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.End) {
                                        $step = 5;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Dispose) {
                                        $step = 6;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Complete) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Event) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 9;
                                    continue;
                                }
                                case 3: {
                                    trackEntry.OnStart();
                                    state.OnStart(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 4: {
                                    trackEntry.OnInterrupt();
                                    state.OnInterrupt(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 5: {
                                    trackEntry.OnEnd();
                                    state.OnEnd(trackEntry);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    trackEntry.OnDispose();
                                    state.OnDispose(trackEntry);
                                    this.trackEntryPool.Free(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    trackEntry.OnComplete();
                                    state.OnComplete(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 8: {
                                    trackEntry.OnEvent(queueEntry.e);
                                    state.OnEvent(trackEntry, queueEntry.e);
                                    $step = 9;
                                    continue;
                                }

                                case 10: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 11: {
                                    this.eventQueueEntries.clear();

                                    this.drainDisabled = false;
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.EventQueue.Drain end.*/

            /*Spine.EventQueue.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Clear", this ); }

                this.eventQueueEntries.clear();
            },
            /*Spine.EventQueue.Clear end.*/


        }
    });
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    Bridge.define("Spine.EventQueue.EventQueueEntry", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getDefaultValue", this ); }
 return new Spine.EventQueue.EventQueueEntry(); }
            }
        },
        fields: {
            type: 0,
            entry: null,
            e: null
        },
        ctors: {
            $ctor1: function (eventType, trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$ctor1", this ); }

                if (e === void 0) { e = null; }

                this.$initialize();
                this.type = eventType;
                this.entry = trackEntry;
                this.e = e;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getHashCode", this ); }

                var h = Bridge.addHash([5412331426, this.type, this.entry, this.e]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#equals", this ); }

                if (!Bridge.is(o, Spine.EventQueue.EventQueueEntry)) {
                    return false;
                }
                return Bridge.equals(this.type, o.type) && Bridge.equals(this.entry, o.entry) && Bridge.equals(this.e, o.e);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$clone", this ); }

                var s = to || new Spine.EventQueue.EventQueueEntry();
                s.type = this.type;
                s.entry = this.entry;
                s.e = this.e;
                return s;
            }
        }
    });
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    Bridge.define("Spine.EventQueue.EventType", {
        $kind: "nested enum",
        statics: {
            fields: {
                Start: 0,
                Interrupt: 1,
                End: 2,
                Dispose: 3,
                Complete: 4,
                Event: 5
            }
        }
    });
    /*Spine.EventQueue+EventType end.*/

    /*Spine.ExposedList$1 start.*/
    Bridge.define("Spine.ExposedList$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        statics: {
            fields: {
                DefaultCapacity: 0,
                EmptyArray: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#init", this ); }

                    this.DefaultCapacity = 4;
                    this.EmptyArray = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            methods: {
                /*Spine.ExposedList$1.CheckMatch:static start.*/
                CheckMatch: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckMatch", this ); }

                    if (Bridge.staticEquals(match, null)) {
                        throw new System.ArgumentNullException.$ctor1("match");
                    }
                },
                /*Spine.ExposedList$1.CheckMatch:static end.*/


            }
        },
        fields: {
            Items: null,
            Count: 0,
            version: 0
        },
        props: {
            Capacity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#get", this ); }

                    return this.Items.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#set", this ); }

                    if ((value >>> 0) < (this.Count >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.ctor();
                    }

                    System.Array.resize(Bridge.ref(this, "Items"), value, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            }
        },
        alias: ["System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ctor", this ); }

                this.$initialize();
                this.Items = Spine.ExposedList$1(T).EmptyArray;
            },
            $ctor2: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor2", this ); }

                this.$initialize();
                this.CheckCollection(collection);

                // initialize to needed size (if determinable)
                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c == null) {
                    this.Items = Spine.ExposedList$1(T).EmptyArray;
                    this.AddEnumerable(collection);
                } else {
                    this.Items = System.Array.init(System.Array.getCount(c, T), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.AddCollection(c);
                }
            },
            $ctor3: function (capacity) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor3", this ); }

                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("capacity");
                }
                this.Items = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (data, size) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor1", this ); }

                this.$initialize();
                this.Items = data;
                this.Count = size;
            }
        },
        methods: {
            /*Spine.ExposedList$1.Add start.*/
            Add: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Add", this ); }

                // If we check to see if we need to grow before trying to grow
                // we can speed things up by 25%
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Items[Bridge.identity(this.Count, ((this.Count = (this.Count + 1) | 0)))] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Add end.*/

            /*Spine.ExposedList$1.GrowIfNeeded start.*/
            GrowIfNeeded: function (addedCount) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GrowIfNeeded", this ); }

                var minimumSize = (this.Count + addedCount) | 0;
                if (minimumSize > this.Items.length) {
                    this.Capacity = Math.max(Math.max(Bridge.Int.mul(this.Capacity, 2), Spine.ExposedList$1(T).DefaultCapacity), minimumSize);
                }
            },
            /*Spine.ExposedList$1.GrowIfNeeded end.*/

            /*Spine.ExposedList$1.Resize start.*/
            Resize: function (newSize) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Resize", this ); }

                var itemsLength = this.Items.length;
                var oldItems = this.Items;
                if (newSize > itemsLength) {
                    System.Array.resize(Bridge.ref(this, "Items"), newSize, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    //				var newItems = new T[newSize];
                    //				Array.Copy(oldItems, newItems, Count);
                    //				Items = newItems;
                } else if (newSize < itemsLength) {
                    // Allow nulling of T reference type to allow GC.
                    for (var i = newSize; i < itemsLength; i = (i + 1) | 0) {
                        oldItems[i] = Bridge.getDefaultValue(T);
                    }
                }
                this.Count = newSize;
                return this;
            },
            /*Spine.ExposedList$1.Resize end.*/

            /*Spine.ExposedList$1.EnsureCapacity start.*/
            EnsureCapacity: function (min) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#EnsureCapacity", this ); }

                if (this.Items.length < min) {
                    var newCapacity = this.Items.length === 0 ? Spine.ExposedList$1(T).DefaultCapacity : Bridge.Int.mul(this.Items.length, 2);
                    //if ((uint)newCapacity > Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;
                    if (newCapacity < min) {
                        newCapacity = min;
                    }
                    this.Capacity = newCapacity;
                }
            },
            /*Spine.ExposedList$1.EnsureCapacity end.*/

            /*Spine.ExposedList$1.CheckRange start.*/
            CheckRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckRange", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentException.$ctor1("index and count exceed length of list");
                }
            },
            /*Spine.ExposedList$1.CheckRange end.*/

            /*Spine.ExposedList$1.AddCollection start.*/
            AddCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                System.Array.copyTo(collection, this.Items, this.Count, T);
                this.Count = (this.Count + collectionCount) | 0;
            },
            /*Spine.ExposedList$1.AddCollection end.*/

            /*Spine.ExposedList$1.AddEnumerable start.*/
            AddEnumerable: function (enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddEnumerable", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Add(Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.AddEnumerable end.*/

            /*Spine.ExposedList$1.AddRange start.*/
            AddRange: function (list) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange", this ); }

                this.CheckCollection(list);

                var collectionCount = list.Count;
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                list.CopyTo$1(this.Items, this.Count);
                this.Count = (this.Count + collectionCount) | 0;

                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange end.*/

            /*Spine.ExposedList$1.AddRange$1 start.*/
            AddRange$1: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange$1", this ); }

                this.CheckCollection(collection);

                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c != null) {
                    this.AddCollection(c);
                } else {
                    this.AddEnumerable(collection);
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange$1 end.*/

            /*Spine.ExposedList$1.BinarySearch start.*/
            BinarySearch: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item));
            },
            /*Spine.ExposedList$1.BinarySearch end.*/

            /*Spine.ExposedList$1.BinarySearch$1 start.*/
            BinarySearch$1: function (item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$1", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$1 end.*/

            /*Spine.ExposedList$1.BinarySearch$2 start.*/
            BinarySearch$2: function (index, count, item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$2", this ); }

                this.CheckRange(index, count);
                return System.Array.binarySearch(this.Items, index, count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$2 end.*/

            /*Spine.ExposedList$1.Clear start.*/
            Clear: function (clearArray) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Clear", this ); }

                if (clearArray === void 0) { clearArray = true; }
                if (clearArray) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, 0, this.Items.length);
                }

                this.Count = 0;
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Clear end.*/

            /*Spine.ExposedList$1.Contains start.*/
            Contains: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Contains", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count) !== -1;
            },
            /*Spine.ExposedList$1.Contains end.*/

            /*Spine.ExposedList$1.ConvertAll start.*/
            ConvertAll: function (TOutput, converter) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ConvertAll", this ); }

                if (Bridge.staticEquals(converter, null)) {
                    throw new System.ArgumentNullException.$ctor1("converter");
                }
                var u = new (Spine.ExposedList$1(TOutput)).$ctor3(this.Count);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    u.Items[i] = Bridge.rValue(converter(Bridge.rValue(this.Items[i])));
                }

                u.Count = this.Count;
                return u;
            },
            /*Spine.ExposedList$1.ConvertAll end.*/

            /*Spine.ExposedList$1.CopyTo start.*/
            CopyTo: function (array) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo", this ); }

                System.Array.copy(this.Items, 0, array, 0, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo end.*/

            /*Spine.ExposedList$1.CopyTo$1 start.*/
            CopyTo$1: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$1", this ); }

                System.Array.copy(this.Items, 0, array, arrayIndex, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo$1 end.*/

            /*Spine.ExposedList$1.CopyTo$2 start.*/
            CopyTo$2: function (index, array, arrayIndex, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$2", this ); }

                this.CheckRange(index, count);
                System.Array.copy(this.Items, index, array, arrayIndex, count);
            },
            /*Spine.ExposedList$1.CopyTo$2 end.*/

            /*Spine.ExposedList$1.Exists start.*/
            Exists: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Exists", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match) !== -1;
            },
            /*Spine.ExposedList$1.Exists end.*/

            /*Spine.ExposedList$1.Find start.*/
            Find: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Find", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetIndex(0, this.Count, match);
                return (i !== -1) ? Bridge.rValue(this.Items[i]) : Bridge.getDefaultValue(T);
            },
            /*Spine.ExposedList$1.Find end.*/

            /*Spine.ExposedList$1.FindAll start.*/
            FindAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.FindAllList(match);
            },
            /*Spine.ExposedList$1.FindAll end.*/

            /*Spine.ExposedList$1.FindAllList start.*/
            FindAllList: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAllList", this ); }

                var results = new (Spine.ExposedList$1(T)).ctor();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        results.Add(Bridge.rValue(this.Items[i]));
                    }
                }

                return results;
            },
            /*Spine.ExposedList$1.FindAllList end.*/

            /*Spine.ExposedList$1.FindIndex$2 start.*/
            FindIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindIndex$2 end.*/

            /*Spine.ExposedList$1.FindIndex$1 start.*/
            FindIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetIndex(startIndex, ((this.Count - startIndex) | 0), match);
            },
            /*Spine.ExposedList$1.FindIndex$1 end.*/

            /*Spine.ExposedList$1.FindIndex start.*/
            FindIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckRange(startIndex, count);
                return this.GetIndex(startIndex, count, match);
            },
            /*Spine.ExposedList$1.FindIndex end.*/

            /*Spine.ExposedList$1.GetIndex start.*/
            GetIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetIndex", this ); }

                var end = (startIndex + count) | 0;
                for (var i = startIndex; i < end; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        return i;
                    }
                }

                return -1;
            },
            /*Spine.ExposedList$1.GetIndex end.*/

            /*Spine.ExposedList$1.FindLast start.*/
            FindLast: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLast", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetLastIndex(0, this.Count, match);
                return i === -1 ? Bridge.getDefaultValue(T) : Bridge.rValue(this.Items[i]);
            },
            /*Spine.ExposedList$1.FindLast end.*/

            /*Spine.ExposedList$1.FindLastIndex$2 start.*/
            FindLastIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetLastIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex$2 end.*/

            /*Spine.ExposedList$1.FindLastIndex$1 start.*/
            FindLastIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetLastIndex(0, ((startIndex + 1) | 0), match);
            },
            /*Spine.ExposedList$1.FindLastIndex$1 end.*/

            /*Spine.ExposedList$1.FindLastIndex start.*/
            FindLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var start = (((startIndex - count) | 0) + 1) | 0;
                this.CheckRange(start, count);
                return this.GetLastIndex(start, count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex end.*/

            /*Spine.ExposedList$1.GetLastIndex start.*/
            GetLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetLastIndex", this ); }

                // unlike FindLastIndex, takes regular params for search range
                for (var i = (startIndex + count) | 0; i !== startIndex; ) {
                    if (match(Bridge.rValue(this.Items[((i = (i - 1) | 0))]))) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.ExposedList$1.GetLastIndex end.*/

            /*Spine.ExposedList$1.ForEach start.*/
            ForEach: function (action) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ForEach", this ); }

                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException.$ctor1("action");
                }
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    action(Bridge.rValue(this.Items[i]));
                }
            },
            /*Spine.ExposedList$1.ForEach end.*/

            /*Spine.ExposedList$1.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetEnumerator", this ); }

                return new (Spine.ExposedList$1.Enumerator(T)).$ctor1(this);
            },
            /*Spine.ExposedList$1.GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator start.*/
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.ExposedList$1.GetRange start.*/
            GetRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetRange", this ); }

                this.CheckRange(index, count);
                var tmpArray = System.Array.init(count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, index, tmpArray, 0, count);
                return new (Spine.ExposedList$1(T)).$ctor1(tmpArray, count);
            },
            /*Spine.ExposedList$1.GetRange end.*/

            /*Spine.ExposedList$1.IndexOf start.*/
            IndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count);
            },
            /*Spine.ExposedList$1.IndexOf end.*/

            /*Spine.ExposedList$1.IndexOf$1 start.*/
            IndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, ((this.Count - index) | 0));
            },
            /*Spine.ExposedList$1.IndexOf$1 end.*/

            /*Spine.ExposedList$1.IndexOf$2 start.*/
            IndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index and count exceed length of list");
                }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.IndexOf$2 end.*/

            /*Spine.ExposedList$1.Shift start.*/
            Shift: function (start, delta) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Shift", this ); }

                if (delta < 0) {
                    start = (start - delta) | 0;
                }

                if (start < this.Count) {
                    System.Array.copy(this.Items, start, this.Items, ((start + delta) | 0), ((this.Count - start) | 0));
                }

                this.Count = (this.Count + delta) | 0;

                if (delta < 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, ((-delta) | 0));
                }
            },
            /*Spine.ExposedList$1.Shift end.*/

            /*Spine.ExposedList$1.CheckIndex start.*/
            CheckIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckIndex", this ); }

                if (index < 0 || (index >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
            },
            /*Spine.ExposedList$1.CheckIndex end.*/

            /*Spine.ExposedList$1.Insert start.*/
            Insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Insert", this ); }

                this.CheckIndex(index);
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Shift(index, 1);
                this.Items[index] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Insert end.*/

            /*Spine.ExposedList$1.CheckCollection start.*/
            CheckCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckCollection", this ); }

                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
            },
            /*Spine.ExposedList$1.CheckCollection end.*/

            /*Spine.ExposedList$1.InsertRange start.*/
            InsertRange: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertRange", this ); }

                this.CheckCollection(collection);
                this.CheckIndex(index);
                if (Bridge.referenceEquals(collection, this)) {
                    var buffer = System.Array.init(this.Count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.CopyTo$1(buffer, 0);
                    this.GrowIfNeeded(this.Count);
                    this.Shift(index, buffer.length);
                    System.Array.copy(buffer, 0, this.Items, index, buffer.length);
                } else {
                    var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                    if (c != null) {
                        this.InsertCollection(index, c);
                    } else {
                        this.InsertEnumeration(index, collection);
                    }
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.InsertRange end.*/

            /*Spine.ExposedList$1.InsertCollection start.*/
            InsertCollection: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                this.GrowIfNeeded(collectionCount);

                this.Shift(index, collectionCount);
                System.Array.copyTo(collection, this.Items, index, T);
            },
            /*Spine.ExposedList$1.InsertCollection end.*/

            /*Spine.ExposedList$1.InsertEnumeration start.*/
            InsertEnumeration: function (index, enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertEnumeration", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Insert(Bridge.identity(index, ((index = (index + 1) | 0))), Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.InsertEnumeration end.*/

            /*Spine.ExposedList$1.LastIndexOf start.*/
            LastIndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf", this ); }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), ((this.Count - 1) | 0), this.Count);
            },
            /*Spine.ExposedList$1.LastIndexOf end.*/

            /*Spine.ExposedList$1.LastIndexOf$1 start.*/
            LastIndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, ((index + 1) | 0));
            },
            /*Spine.ExposedList$1.LastIndexOf$1 end.*/

            /*Spine.ExposedList$1.LastIndexOf$2 start.*/
            LastIndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), "index is negative");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is negative");
                }

                if (((((index - count) | 0) + 1) | 0) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is too large");
                }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.LastIndexOf$2 end.*/

            /*Spine.ExposedList$1.Remove start.*/
            Remove: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Remove", this ); }

                var loc = this.IndexOf(Bridge.rValue(item));
                if (loc !== -1) {
                    this.RemoveAt(loc);
                }

                return loc !== -1;
            },
            /*Spine.ExposedList$1.Remove end.*/

            /*Spine.ExposedList$1.RemoveAll start.*/
            RemoveAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = 0;
                var j = 0;

                // Find the first item to remove
                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        break;
                    }
                }

                if (i === this.Count) {
                    return 0;
                }

                this.version = (this.version + 1) | 0;

                // Remove any additional items
                for (j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[j]))) {
                        this.Items[Bridge.identity(i, ((i = (i + 1) | 0)))] = Bridge.rValue(this.Items[j]);
                    }
                }
                if (((j - i) | 0) > 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, i, ((j - i) | 0));
                }

                this.Count = i;
                return (((j - i) | 0));
            },
            /*Spine.ExposedList$1.RemoveAll end.*/

            /*Spine.ExposedList$1.RemoveAt start.*/
            RemoveAt: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAt", this ); }

                if (index < 0 || (index >>> 0) >= (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                this.Shift(index, -1);
                System.Array.fill(this.Items, function () {
                    return Bridge.getDefaultValue(T);
                }, this.Count, 1);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.RemoveAt end.*/

            /*Spine.ExposedList$1.Pop start.*/
            /**
             * Pops the last item of the list. If the list is empty, Pop throws an InvalidOperationException.
             *
             * @instance
             * @public
             * @this Spine.ExposedList$1
             * @memberof Spine.ExposedList$1
             * @return  {T}
             */
            Pop: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Pop", this ); }

                if (this.Count === 0) {
                    throw new System.InvalidOperationException.$ctor1("List is empty. Nothing to pop.");
                }

                var i = (this.Count - 1) | 0;
                var item = Bridge.rValue(this.Items[i]);
                this.Items[i] = Bridge.getDefaultValue(T);
                this.Count = (this.Count - 1) | 0;
                this.version = (this.version + 1) | 0;
                return Bridge.rValue(item);
            },
            /*Spine.ExposedList$1.Pop end.*/

            /*Spine.ExposedList$1.RemoveRange start.*/
            RemoveRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveRange", this ); }

                this.CheckRange(index, count);
                if (count > 0) {
                    this.Shift(index, ((-count) | 0));
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, count);
                    this.version = (this.version + 1) | 0;
                }
            },
            /*Spine.ExposedList$1.RemoveRange end.*/

            /*Spine.ExposedList$1.Reverse start.*/
            Reverse: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse", this ); }

                System.Array.reverse(this.Items, 0, this.Count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse end.*/

            /*Spine.ExposedList$1.Reverse$1 start.*/
            Reverse$1: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse$1", this ); }

                this.CheckRange(index, count);
                System.Array.reverse(this.Items, index, count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse$1 end.*/

            /*Spine.ExposedList$1.Sort start.*/
            Sort: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort", this ); }

                System.Array.sort(this.Items, 0, this.Count, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort end.*/

            /*Spine.ExposedList$1.Sort$1 start.*/
            Sort$1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$1", this ); }

                System.Array.sort(this.Items, 0, this.Count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$1 end.*/

            /*Spine.ExposedList$1.Sort$2 start.*/
            Sort$2: function (comparison) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$2", this ); }

                System.Array.sort(this.Items, comparison);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$2 end.*/

            /*Spine.ExposedList$1.Sort$3 start.*/
            Sort$3: function (index, count, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$3", this ); }

                this.CheckRange(index, count);
                System.Array.sort(this.Items, index, count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$3 end.*/

            /*Spine.ExposedList$1.ToArray start.*/
            ToArray: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ToArray", this ); }

                var t = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, 0, t, 0, this.Count);

                return t;
            },
            /*Spine.ExposedList$1.ToArray end.*/

            /*Spine.ExposedList$1.TrimExcess start.*/
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrimExcess", this ); }

                this.Capacity = this.Count;
            },
            /*Spine.ExposedList$1.TrimExcess end.*/

            /*Spine.ExposedList$1.TrueForAll start.*/
            TrueForAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrueForAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[i]))) {
                        return false;
                    }
                }

                return true;
            },
            /*Spine.ExposedList$1.TrueForAll end.*/


        },
        overloads: {
            "AddRange(IEnumerable<T>)": "AddRange$1",
            "BinarySearch(T, IComparer<T>)": "BinarySearch$1",
            "BinarySearch(int, int, T, IComparer<T>)": "BinarySearch$2",
            "CopyTo(T[], int)": "CopyTo$1",
            "CopyTo(int, T[], int, int)": "CopyTo$2",
            "FindIndex(Predicate<T>)": "FindIndex$2",
            "FindIndex(int, Predicate<T>)": "FindIndex$1",
            "FindLastIndex(Predicate<T>)": "FindLastIndex$2",
            "FindLastIndex(int, Predicate<T>)": "FindLastIndex$1",
            "IndexOf(T, int)": "IndexOf$1",
            "IndexOf(T, int, int)": "IndexOf$2",
            "LastIndexOf(T, int)": "LastIndexOf$1",
            "LastIndexOf(T, int, int)": "LastIndexOf$2",
            "Reverse(int, int)": "Reverse$1",
            "Sort(IComparer<T>)": "Sort$1",
            "Sort(Comparison<T>)": "Sort$2",
            "Sort(int, int, IComparer<T>)": "Sort$3"
        }
    }; });
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    Bridge.define("Spine.ExposedList$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.IDisposable],
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getDefaultValue", this ); }
 return new (Spine.ExposedList$1.Enumerator(T))(); }
            }
        },
        fields: {
            l: null,
            next: 0,
            ver: 0,
            current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Current#get", this ); }

                    return Bridge.rValue(this.current);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get", this ); }

                    this.VerifyState();
                    if (this.next <= 0) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#init", this ); }

                this.current = Bridge.getDefaultValue(T);
            },
            $ctor1: function (l) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$ctor1", this ); }

                Spine.ExposedList$1.Enumerator(T).ctor.call(this);
                this.l = l;
                this.ver = l.version;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.ExposedList$1+Enumerator.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Dispose", this ); }

                this.l = null;
            },
            /*Spine.ExposedList$1+Enumerator.Dispose end.*/

            /*Spine.ExposedList$1+Enumerator.VerifyState start.*/
            VerifyState: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#VerifyState", this ); }

                if (this.l == null) {
                    throw new System.ObjectDisposedException.$ctor1(Bridge.Reflection.getTypeFullName(Spine.ExposedList$1.Enumerator(T)));
                }
                if (this.ver !== this.l.version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
            },
            /*Spine.ExposedList$1+Enumerator.VerifyState end.*/

            /*Spine.ExposedList$1+Enumerator.moveNext start.*/
            moveNext: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#moveNext", this ); }

                var $t;
                this.VerifyState();

                if (this.next < 0) {
                    return false;
                }

                if (this.next < this.l.Count) {
                    this.current = Bridge.rValue(($t = this.l.Items)[Bridge.identity(this.next, ((this.next = (this.next + 1) | 0)))]);
                    return true;
                }

                this.next = -1;
                return false;
            },
            /*Spine.ExposedList$1+Enumerator.moveNext end.*/

            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset", this ); }

                this.VerifyState();
                this.next = 0;
            },
            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getHashCode", this ); }

                var h = Bridge.addHash([3788985113, this.l, this.next, this.ver, this.current]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#equals", this ); }

                if (!Bridge.is(o, Spine.ExposedList$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.l, o.l) && Bridge.equals(this.next, o.next) && Bridge.equals(this.ver, o.ver) && Bridge.equals(this.current, o.current);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$clone", this ); }

                var s = to || new (Spine.ExposedList$1.Enumerator(T))();
                s.l = this.l;
                s.next = this.next;
                s.ver = this.ver;
                s.current = Bridge.rValue(this.current);
                return s;
            }
        },
        overloads: {
            "MoveNext()": "moveNext"
        }
    }; });
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.Format start.*/
    Bridge.define("Spine.Format", {
        $kind: "enum",
        statics: {
            fields: {
                Alpha: 0,
                Intensity: 1,
                LuminanceAlpha: 2,
                RGB565: 3,
                RGBA4444: 4,
                RGB888: 5,
                RGBA8888: 6
            }
        }
    });
    /*Spine.Format end.*/

    /*Spine.IBoneTimeline start.*/
    /**
     * An interface for timelines which change the property of a bone.
     *
     * @abstract
     * @public
     * @class Spine.IBoneTimeline
     */
    Bridge.define("Spine.IBoneTimeline", {
        $kind: "interface"
    });
    /*Spine.IBoneTimeline end.*/

    /*Spine.IHasRendererObject start.*/
    Bridge.define("Spine.IHasRendererObject", {
        $kind: "interface"
    });
    /*Spine.IHasRendererObject end.*/

    /*Spine.IInterpolation start.*/
    Bridge.define("Spine.IInterpolation", {
        statics: {
            fields: {
                Pow2: null,
                Pow2Out: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IInterpolation#init", this ); }

                    this.Pow2 = new Spine.Pow(2);
                    this.Pow2Out = new Spine.PowOut(2);
                }
            }
        },
        methods: {
            /*Spine.IInterpolation.Apply start.*/
            Apply: function (start, end, a) {
if ( TRACE ) { TRACE( "Spine.IInterpolation#Apply", this ); }

                return start + (end - start) * this.Apply$1(a);
            },
            /*Spine.IInterpolation.Apply end.*/


        }
    });
    /*Spine.IInterpolation end.*/

    /*Spine.Json start.*/
    Bridge.define("Spine.Json", {
        statics: {
            methods: {
                /*Spine.Json.Deserialize:static start.*/
                Deserialize: function (text) {
if ( TRACE ) { TRACE( "Spine.Json#Deserialize", this ); }

                    var parser = new SharpJson.JsonDecoder();
                    parser.parseNumbersAsFloat = true;
                    return parser.Decode(text.ReadToEnd());
                },
                /*Spine.Json.Deserialize:static end.*/


            }
        }
    });
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    Bridge.define("Spine.MathUtils", {
        statics: {
            fields: {
                PI: 0,
                PI2: 0,
                RadDeg: 0,
                DegRad: 0,
                random: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.MathUtils#init", this ); }

                    this.PI = 3.14159274;
                    this.PI2 = 6.28318548;
                    this.RadDeg = 57.2957764;
                    this.DegRad = 0.0174532924;
                    this.random = new System.Random.ctor();
                }
            },
            methods: {
                /*Spine.MathUtils.Sin:static start.*/
                /**
                 * Returns the sine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Sin: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Sin", this ); }

                    return Math.sin(radians);
                },
                /*Spine.MathUtils.Sin:static end.*/

                /*Spine.MathUtils.Cos:static start.*/
                /**
                 * Returns the cosine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Cos: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Cos", this ); }

                    return Math.cos(radians);
                },
                /*Spine.MathUtils.Cos:static end.*/

                /*Spine.MathUtils.SinDeg:static start.*/
                /**
                 * Returns the sine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                SinDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#SinDeg", this ); }

                    return Math.sin(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.SinDeg:static end.*/

                /*Spine.MathUtils.CosDeg:static start.*/
                /**
                 * Returns the cosine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                CosDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#CosDeg", this ); }

                    return Math.cos(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.CosDeg:static end.*/

                /*Spine.MathUtils.Atan2:static start.*/
                /**
                 * Returns the atan2 using Math.Atan2.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    y    
                 * @param   {number}    x
                 * @return  {number}
                 */
                Atan2: function (y, x) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Atan2", this ); }

                    return Math.atan2(y, x);
                },
                /*Spine.MathUtils.Atan2:static end.*/

                /*Spine.MathUtils.Clamp:static start.*/
                Clamp: function (value, min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Clamp", this ); }

                    if (value < min) {
                        return min;
                    }
                    if (value > max) {
                        return max;
                    }
                    return value;
                },
                /*Spine.MathUtils.Clamp:static end.*/

                /*Spine.MathUtils.RandomTriangle:static start.*/
                RandomTriangle: function (min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle", this ); }

                    return Spine.MathUtils.RandomTriangle$1(min, max, (min + max) * 0.5);
                },
                /*Spine.MathUtils.RandomTriangle:static end.*/

                /*Spine.MathUtils.RandomTriangle$1:static start.*/
                RandomTriangle$1: function (min, max, mode) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle$1", this ); }

                    var u = Spine.MathUtils.random.NextDouble();
                    var d = max - min;
                    if (u <= (mode - min) / d) {
                        return min + Math.sqrt(u * d * (mode - min));
                    }
                    return max - Math.sqrt((1 - u) * d * (max - mode));
                },
                /*Spine.MathUtils.RandomTriangle$1:static end.*/


            }
        }
    });
    /*Spine.MathUtils end.*/

    /*Spine.MixBlend start.*/
    /**
     * Controls how a timeline is mixed with the setup or current pose.
     *
     * @public
     * @class Spine.MixBlend
     * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
     */
    Bridge.define("Spine.MixBlend", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup
                           value is set.
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 0
                 * @type Spine.MixBlend
                 */
                Setup: 0,
                /**
                 * <p>Transitions from the current value to the timeline value. Before the first key, transitions from the current value to
                 the setup value. Timelines which perform instant transitions, such as {@link } or
                 {@link }, use the setup value before the first key.</p><p><pre><code>First</code></pre> is intended for the first animations applied, not for animations layered on top of those.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 1
                 * @type Spine.MixBlend
                 */
                First: 1,
                /**
                 * <p>Transitions from the current value to the timeline value. No change is made before the first key (the current value is
                 kept until the first key).</p><p><pre><code>Replace</code></pre> is intended for animations layered on top of others, not for the first animations applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 2
                 * @type Spine.MixBlend
                 */
                Replace: 2,
                /**
                 * <p>Transitions from the current value to the current value plus the timeline value. No change is made before the first key
                 (the current value is kept until the first key).</p><p><pre><code>Add</code></pre> is intended for animations layered on top of others, not for the first animations applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 3
                 * @type Spine.MixBlend
                 */
                Add: 3
            }
        }
    });
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    /**
     * Indicates whether a timeline's <pre><code>alpha</code></pre> is mixing out over time toward 0 (the setup or current pose value) or
     mixing in toward 1 (the timeline's value).
     *
     * @public
     * @class Spine.MixDirection
     * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
     */
    Bridge.define("Spine.MixDirection", {
        $kind: "enum",
        statics: {
            fields: {
                In: 0,
                Out: 1
            }
        }
    });
    /*Spine.MixDirection end.*/

    /*Spine.Polygon start.*/
    Bridge.define("Spine.Polygon", {
        fields: {
            Vertices: null,
            Count: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Polygon#ctor", this ); }

                this.$initialize();
                this.Vertices = System.Array.init(16, 0, System.Single);
            }
        }
    });
    /*Spine.Polygon end.*/

    /*Spine.Pool$1 start.*/
    Bridge.define("Spine.Pool$1", function (T) { return {
        fields: {
            max: 0,
            freeObjects: null,
            Peak: 0
        },
        props: {
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Count#get", this ); }

                    return this.freeObjects.Count;
                }
            }
        },
        ctors: {
            ctor: function (initialCapacity, max) {
if ( TRACE ) { TRACE( "Spine.Pool$1#ctor", this ); }

                if (initialCapacity === void 0) { initialCapacity = 16; }
                if (max === void 0) { max = 2147483647; }

                this.$initialize();
                this.freeObjects = new (System.Collections.Generic.Stack$1(T)).$ctor2(initialCapacity);
                this.max = max;
            }
        },
        methods: {
            /*Spine.Pool$1.Obtain start.*/
            Obtain: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Obtain", this ); }

                return this.freeObjects.Count === 0 ? Bridge.createInstance(T) : this.freeObjects.Pop();
            },
            /*Spine.Pool$1.Obtain end.*/

            /*Spine.Pool$1.Free start.*/
            Free: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Free", this ); }

                if (Bridge.rValue(obj) == null) {
                    throw new System.ArgumentNullException.$ctor3("obj", "obj cannot be null");
                }
                if (this.freeObjects.Count < this.max) {
                    this.freeObjects.Push(Bridge.rValue(obj));
                    this.Peak = Math.max(this.Peak, this.freeObjects.Count);
                }
                this.Reset(Bridge.rValue(obj));
            },
            /*Spine.Pool$1.Free end.*/

            /*Spine.Pool$1.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Clear", this ); }

                this.freeObjects.Clear();
            },
            /*Spine.Pool$1.Clear end.*/

            /*Spine.Pool$1.Reset start.*/
            Reset: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Reset", this ); }

                var poolable = Bridge.as(Bridge.rValue(obj), Spine.Pool$1.IPoolable(T));
                if (poolable != null) {
                    poolable["Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset"]();
                }
            },
            /*Spine.Pool$1.Reset end.*/


        }
    }; });
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    Bridge.definei("Spine.Pool$1.IPoolable", function (T) { return {
        $kind: "nested interface"
    }; });
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.PositionMode start.*/
    Bridge.define("Spine.PositionMode", {
        $kind: "enum",
        statics: {
            fields: {
                Fixed: 0,
                Percent: 1
            }
        }
    });
    /*Spine.PositionMode end.*/

    /*Spine.RotateMode start.*/
    Bridge.define("Spine.RotateMode", {
        $kind: "enum",
        statics: {
            fields: {
                Tangent: 0,
                Chain: 1,
                ChainScale: 2
            }
        }
    });
    /*Spine.RotateMode end.*/

    /*Spine.Skeleton start.*/
    Bridge.define("Spine.Skeleton", {
        statics: {
            methods: {
                /*Spine.Skeleton.SortReset:static start.*/
                SortReset: function (bones) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortReset", this ); }

                    var bonesItems = bones.Items;
                    for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                        var bone = bonesItems[i];
                        if (!bone.active) {
                            continue;
                        }
                        if (bone.sorted) {
                            Spine.Skeleton.SortReset(bone.children);
                        }
                        bone.sorted = false;
                    }
                },
                /*Spine.Skeleton.SortReset:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            slots: null,
            drawOrder: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            updateCache: null,
            updateCacheReset: null,
            skin: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            time: 0,
            scaleX: 0,
            scaleY: 0,
            x: 0,
            y: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Data#get", this ); }

                    return this.data;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Bones#get", this ); }

                    return this.bones;
                }
            },
            UpdateCacheList: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCacheList#get", this ); }

                    return this.updateCache;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Slots#get", this ); }

                    return this.slots;
                }
            },
            DrawOrder: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#DrawOrder#get", this ); }

                    return this.drawOrder;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#IkConstraints#get", this ); }

                    return this.ikConstraints;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#PathConstraints#get", this ); }

                    return this.pathConstraints;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                }
            },
            Skin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#get", this ); }

                    return this.skin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#set", this ); }

                    this.SetSkin(value);
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#set", this ); }

                    this.a = value;
                }
            },
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#get", this ); }

                    return this.time;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#set", this ); }

                    this.time = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#set", this ); }

                    this.y = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#get", this ); }

                    return this.scaleY * (Spine.Bone.yDown ? -1 : 1);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            FlipX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#get", this ); }

                    return this.scaleX < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#set", this ); }

                    this.scaleX = value ? -1.0 : 1.0;
                }
            },
            FlipY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#get", this ); }

                    return this.scaleY < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#set", this ); }

                    this.scaleY = value ? -1.0 : 1.0;
                }
            },
            RootBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#RootBone#get", this ); }

                    var $t;
                    return this.bones.Count === 0 ? null : ($t = this.bones.Items)[0];
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#init", this ); }

                this.updateCache = new (Spine.ExposedList$1(Spine.IUpdatable)).ctor();
                this.updateCacheReset = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.scaleX = 1;
                this.scaleY = 1;
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ctor", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        var bone;
                        if (boneData.parent == null) {
                            bone = new Spine.Bone(boneData, this, null);
                        } else {
                            var parent = ($t1 = this.bones.Items)[boneData.parent.index];
                            bone = new Spine.Bone(boneData, this, parent);
                            parent.children.Add(bone);
                        }
                        this.bones.Add(bone);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                $t2 = Bridge.getEnumerator(data.slots);
                try {
                    while ($t2.moveNext()) {
                        var slotData = $t2.Current;
                        var bone1 = ($t3 = this.bones.Items)[slotData.boneData.index];
                        var slot = new Spine.Slot.$ctor1(slotData, bone1);
                        this.slots.Add(slot);
                        this.drawOrder.Add(slot);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(data.ikConstraints.Count);
                $t4 = Bridge.getEnumerator(data.ikConstraints);
                try {
                    while ($t4.moveNext()) {
                        var ikConstraintData = $t4.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.$ctor1(ikConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }

                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(data.transformConstraints.Count);
                $t5 = Bridge.getEnumerator(data.transformConstraints);
                try {
                    while ($t5.moveNext()) {
                        var transformConstraintData = $t5.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.$ctor1(transformConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(data.pathConstraints.Count);
                $t6 = Bridge.getEnumerator(data.pathConstraints);
                try {
                    while ($t6.moveNext()) {
                        var pathConstraintData = $t6.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.$ctor1(pathConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t6, System.IDisposable)) {
                        $t6.System$IDisposable$Dispose();
                    }
                }

                this.UpdateCache();
                this.UpdateWorldTransform();
            }
        },
        methods: {
            /*Spine.Skeleton.UpdateCache start.*/
            /**
             * Caches information about bones and constraints. Must be called if the {@link } is modified or if bones, constraints, or
             constraints, or weighted path attachments are added or removed.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            UpdateCache: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCache", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    updateCache, 
                    boneCount, 
                    bones, 
                    bone, 
                    skinBones, 
                    bone1, 
                    ikCount, 
                    transformCount, 
                    pathCount, 
                    ikConstraints, 
                    transformConstraints, 
                    pathConstraints, 
                    constraintCount, 
                    i2, 
                    ii, 
                    constraint, 
                    ii1, 
                    constraint1, 
                    ii2, 
                    constraint2, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,22,23], $step);
                            switch ($step) {
                                case 0: {
                                    updateCache = this.updateCache;
                                    updateCache.Clear();
                                    this.updateCacheReset.Clear();

                                    boneCount = this.bones.Items.length;
                                    bones = this.bones;
                                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                                        bone = bones.Items[i];
                                        bone.sorted = bone.data.skinRequired;
                                        bone.active = !bone.sorted;
                                    }
                                    if (this.skin != null) {
                                        skinBones = this.skin.bones.Items;
                                        for (var i1 = 0, n = this.skin.bones.Count; i1 < n; i1 = (i1 + 1) | 0) {
                                            bone1 = bones.Items[Bridge.cast(skinBones[i1], Spine.BoneData).index];
                                            do {
                                                bone1.sorted = false;
                                                bone1.active = true;
                                                bone1 = bone1.parent;
                                            } while (bone1 != null);
                                        }
                                    }

                                    ikCount = this.ikConstraints.Count;
                                    transformCount = this.transformConstraints.Count;
                                    pathCount = this.pathConstraints.Count;
                                    ikConstraints = this.ikConstraints;
                                    transformConstraints = this.transformConstraints;
                                    pathConstraints = this.pathConstraints;
                                    constraintCount = (((ikCount + transformCount) | 0) + pathCount) | 0;
                                    //outer:
                                    i2 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i2 < constraintCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 23;
                                    continue;
                                }
                                case 2: {
                                    ii = 0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( ii < ikCount ) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 8;
                                    continue;
                                }
                                case 4: {
                                    constraint = ikConstraints.Items[ii];
                                    if (constraint.data.order === i2) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 6;
                                    continue;
                                }
                                case 5: {
                                    this.SortIkConstraint(constraint);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 6;
                                    continue;
                                }

                                case 7: {
                                    ii = (ii + 1) | 0;
                                    $step = 3;
                                    continue;
                                }
                                case 8: {
                                    ii1 = 0;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    if ( ii1 < transformCount ) {
                                        $step = 10;
                                        continue;
                                    }
                                    $step = 14;
                                    continue;
                                }
                                case 10: {
                                    constraint1 = transformConstraints.Items[ii1];
                                    if (constraint1.data.order === i2) {
                                        $step = 11;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    this.SortTransformConstraint(constraint1);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 12;
                                    continue;
                                }

                                case 13: {
                                    ii1 = (ii1 + 1) | 0;
                                    $step = 9;
                                    continue;
                                }
                                case 14: {
                                    ii2 = 0;
                                    $step = 15;
                                    continue;
                                }
                                case 15: {
                                    if ( ii2 < pathCount ) {
                                        $step = 16;
                                        continue;
                                    }
                                    $step = 20;
                                    continue;
                                }
                                case 16: {
                                    constraint2 = pathConstraints.Items[ii2];
                                    if (constraint2.data.order === i2) {
                                        $step = 17;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 17: {
                                    this.SortPathConstraint(constraint2);
                                    $step = 21;
                                    continue;//continue outer;
                                    $step = 18;
                                    continue;
                                }

                                case 19: {
                                    ii2 = (ii2 + 1) | 0;
                                    $step = 15;
                                    continue;
                                }
                                case 20: {

                                }

                                case 22: {
                                    i2 = (i2 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 23: {
                                    for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                                        this.SortBone(bones.Items[i3]);
                                    }
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Skeleton.UpdateCache end.*/

            /*Spine.Skeleton.SortIkConstraint start.*/
            SortIkConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortIkConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var target = constraint.target;
                this.SortBone(target);

                var constrained = constraint.bones;
                var parent = constrained.Items[0];
                this.SortBone(parent);

                if (constrained.Count > 1) {
                    var child = constrained.Items[((constrained.Count - 1) | 0)];
                    if (!this.updateCache.Contains(child)) {
                        this.updateCacheReset.Add(child);
                    }
                }

                this.updateCache.Add(constraint);

                Spine.Skeleton.SortReset(parent.children);
                constrained.Items[((constrained.Count - 1) | 0)].sorted = true;
            },
            /*Spine.Skeleton.SortIkConstraint end.*/

            /*Spine.Skeleton.SortPathConstraint start.*/
            SortPathConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraint", this ); }

                constraint.active = constraint.target.bone.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var slot = constraint.target;
                var slotIndex = slot.data.index;
                var slotBone = slot.bone;
                if (this.skin != null) {
                    this.SortPathConstraintAttachment$1(this.skin, slotIndex, slotBone);
                }
                if (this.data.defaultSkin != null && !Bridge.referenceEquals(this.data.defaultSkin, this.skin)) {
                    this.SortPathConstraintAttachment$1(this.data.defaultSkin, slotIndex, slotBone);
                }

                var attachment = slot.attachment;
                if (Bridge.is(attachment, Spine.PathAttachment)) {
                    this.SortPathConstraintAttachment(attachment, slotBone);
                }

                var constrained = constraint.bones;
                var boneCount = constrained.Count;
                for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                    this.SortBone(constrained.Items[i]);
                }

                this.updateCache.Add(constraint);

                for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained.Items[i1].children);
                }
                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    constrained.Items[i2].sorted = true;
                }
            },
            /*Spine.Skeleton.SortPathConstraint end.*/

            /*Spine.Skeleton.SortTransformConstraint start.*/
            SortTransformConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortTransformConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                this.SortBone(constraint.target);

                var constrained = constraint.bones;
                var boneCount = constrained.Count;
                if (constraint.data.local) {
                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                        var child = constrained.Items[i];
                        this.SortBone(child.parent);
                        if (!this.updateCache.Contains(child)) {
                            this.updateCacheReset.Add(child);
                        }
                    }
                } else {
                    for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                        this.SortBone(constrained.Items[i1]);
                    }
                }

                this.updateCache.Add(constraint);

                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained.Items[i2].children);
                }
                for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                    constrained.Items[i3].sorted = true;
                }
            },
            /*Spine.Skeleton.SortTransformConstraint end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment$1 start.*/
            SortPathConstraintAttachment$1: function (skin, slotIndex, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(skin.Attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entryObj = $t.Current;
                        var entry = entryObj;
                        if (entry.SlotIndex === slotIndex) {
                            this.SortPathConstraintAttachment(entry.Attachment, slotBone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment$1 end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment start.*/
            SortPathConstraintAttachment: function (attachment, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment", this ); }

                if (!(Bridge.is(attachment, Spine.PathAttachment))) {
                    return;
                }
                var pathBones = Bridge.cast(attachment, Spine.PathAttachment).bones;
                if (pathBones == null) {
                    this.SortBone(slotBone);
                } else {
                    var bones = this.bones;
                    for (var i = 0, n = pathBones.length; i < n; ) {
                        var nn = pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))];
                        nn = (nn + i) | 0;
                        while (i < nn) {
                            this.SortBone(bones.Items[pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))]]);
                        }
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment end.*/

            /*Spine.Skeleton.SortBone start.*/
            SortBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortBone", this ); }

                if (bone.sorted) {
                    return;
                }
                var parent = bone.parent;
                if (parent != null) {
                    this.SortBone(parent);
                }
                bone.sorted = true;
                this.updateCache.Add(bone);
            },
            /*Spine.Skeleton.SortBone end.*/

            /*Spine.Skeleton.UpdateWorldTransform start.*/
            /**
             * Updates the world transform for each bone and applies constraints.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform", this ); }

                var updateCacheReset = this.updateCacheReset;
                var updateCacheResetItems = updateCacheReset.Items;
                for (var i = 0, n = updateCacheReset.Count; i < n; i = (i + 1) | 0) {
                    var bone = updateCacheResetItems[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                }
                var updateItems = this.updateCache.Items;
                for (var i1 = 0, n1 = this.updateCache.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    updateItems[i1].Spine$IUpdatable$Update();
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform end.*/

            /*Spine.Skeleton.UpdateWorldTransform$1 start.*/
            /**
             * Temporarily sets the root bone as a child of the specified bone, then updates the world transform for each bone and applies
             all constraints.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Bone}    parent
             * @return  {void}
             */
            UpdateWorldTransform$1: function (parent) {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform$1", this ); }

                // This partial update avoids computing the world transform for constrained bones when 1) the bone is not updated
                // before the constraint, 2) the constraint only needs to access the applied local transform, and 3) the constraint calls
                // updateWorldTransform.
                var updateCacheReset = this.updateCacheReset;
                var updateCacheResetItems = updateCacheReset.Items;
                for (var i = 0, n = updateCacheReset.Count; i < n; i = (i + 1) | 0) {
                    var bone = updateCacheResetItems[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                }

                // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.
                var rootBone = this.RootBone;
                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;
                rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;

                var rotationY = rootBone.rotation + 90 + rootBone.shearY;
                var la = Spine.MathUtils.CosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var lb = Spine.MathUtils.CosDeg(rotationY) * rootBone.scaleY;
                var lc = Spine.MathUtils.SinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var ld = Spine.MathUtils.SinDeg(rotationY) * rootBone.scaleY;
                rootBone.a = (pa * la + pb * lc) * this.scaleX;
                rootBone.b = (pa * lb + pb * ld) * this.scaleX;
                rootBone.c = (pc * la + pd * lc) * this.scaleY;
                rootBone.d = (pc * lb + pd * ld) * this.scaleY;

                // Update everything except root bone.
                var updateCache = this.updateCache;
                var updateCacheItems = updateCache.Items;
                for (var i1 = 0, n1 = updateCache.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var updatable = updateCacheItems[i1];
                    if (!Bridge.referenceEquals(updatable, rootBone)) {
                        updatable.Spine$IUpdatable$Update();
                    }
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform$1 end.*/

            /*Spine.Skeleton.SetToSetupPose start.*/
            /**
             * Sets the bones, constraints, and slots to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetToSetupPose", this ); }

                this.SetBonesToSetupPose();
                this.SetSlotsToSetupPose();
            },
            /*Spine.Skeleton.SetToSetupPose end.*/

            /*Spine.Skeleton.SetBonesToSetupPose start.*/
            /**
             * Sets the bones and constraints to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetBonesToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetBonesToSetupPose", this ); }

                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    bonesItems[i].SetToSetupPose();
                }

                var ikConstraintsItems = this.ikConstraints.Items;
                for (var i1 = 0, n1 = this.ikConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var constraint = ikConstraintsItems[i1];
                    constraint.mix = constraint.data.mix;
                    constraint.softness = constraint.data.softness;
                    constraint.bendDirection = constraint.data.bendDirection;
                    constraint.compress = constraint.data.compress;
                    constraint.stretch = constraint.data.stretch;
                }

                var transformConstraintsItems = this.transformConstraints.Items;
                for (var i2 = 0, n2 = this.transformConstraints.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                    var constraint1 = transformConstraintsItems[i2];
                    var constraintData = constraint1.data;
                    constraint1.rotateMix = constraintData.rotateMix;
                    constraint1.translateMix = constraintData.translateMix;
                    constraint1.scaleMix = constraintData.scaleMix;
                    constraint1.shearMix = constraintData.shearMix;
                }

                var pathConstraintItems = this.pathConstraints.Items;
                for (var i3 = 0, n3 = this.pathConstraints.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    var constraint2 = pathConstraintItems[i3];
                    var constraintData1 = constraint2.data;
                    constraint2.position = constraintData1.position;
                    constraint2.spacing = constraintData1.spacing;
                    constraint2.rotateMix = constraintData1.rotateMix;
                    constraint2.translateMix = constraintData1.translateMix;
                }
            },
            /*Spine.Skeleton.SetBonesToSetupPose end.*/

            /*Spine.Skeleton.SetSlotsToSetupPose start.*/
            SetSlotsToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSlotsToSetupPose", this ); }

                var slots = this.slots;
                var slotsItems = slots.Items;
                this.drawOrder.Clear();
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    this.drawOrder.Add(slotsItems[i]);
                }

                for (var i1 = 0, n1 = slots.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    slotsItems[i1].SetToSetupPose();
                }
            },
            /*Spine.Skeleton.SetSlotsToSetupPose end.*/

            /*Spine.Skeleton.FindBone start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        boneName
             * @return  {Spine.Bone}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (Bridge.referenceEquals(bone.data.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindBone end.*/

            /*Spine.Skeleton.FindBoneIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    boneName
             * @return  {number}                -1 if the bone was not found.
             */
            FindBoneIndex: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBoneIndex", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(bonesItems[i].data.name, boneName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.Skeleton.FindBoneIndex end.*/

            /*Spine.Skeleton.FindSlot start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        slotName
             * @return  {Spine.Slot}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                var slotsItems = slots.Items;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slotsItems[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindSlot end.*/

            /*Spine.Skeleton.FindSlotIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    slotName
             * @return  {number}                -1 if the bone was not found.
             */
            FindSlotIndex: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlotIndex", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                var slotsItems = slots.Items;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    if (System.String.equals(slotsItems[i].data.name, slotName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.Skeleton.FindSlotIndex end.*/

            /*Spine.Skeleton.SetSkin$1 start.*/
            /**
             * Sets a skin by name (see SetSkin).
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    skinName
             * @return  {void}
             */
            SetSkin$1: function (skinName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin$1", this ); }

                var foundSkin = this.data.FindSkin(skinName);
                if (foundSkin == null) {
                    throw new System.ArgumentException.$ctor3("Skin not found: " + (skinName || ""), "skinName");
                }
                this.SetSkin(foundSkin);
            },
            /*Spine.Skeleton.SetSkin$1 end.*/

            /*Spine.Skeleton.SetSkin start.*/
            /**
             * <p>Sets the skin used to look up attachments before looking in the {@link }. If the
             skin is changed, {@link } is called.</p><p>Attachments from the new skin are attached if the corresponding attachment from the old skin was attached.
             If there was no old skin, each slot's setup mode attachment is attached from the new skin.</p><p>After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
             {@link }.
             Also, often {@link } is called before the next time the
             skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.</p>
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Skin}    newSkin    May be null.
             * @return  {void}
             */
            SetSkin: function (newSkin) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin", this ); }

                if (Bridge.referenceEquals(newSkin, this.skin)) {
                    return;
                }
                if (newSkin != null) {
                    if (this.skin != null) {
                        newSkin.AttachAll(this, this.skin);
                    } else {
                        var slots = this.slots;
                        for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                            var slot = slots.Items[i];
                            var name = slot.data.attachmentName;
                            if (name != null) {
                                var attachment = newSkin.GetAttachment(i, name);
                                if (attachment != null) {
                                    slot.Attachment = attachment;
                                }
                            }
                        }
                    }
                }
                this.skin = newSkin;
                this.UpdateCache();
            },
            /*Spine.Skeleton.SetSkin end.*/

            /*Spine.Skeleton.GetAttachment$1 start.*/
            /**
             * Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment name.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}              slotName          
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment$1: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment$1", this ); }

                return this.GetAttachment(this.data.FindSlotIndex(slotName), attachmentName);
            },
            /*Spine.Skeleton.GetAttachment$1 end.*/

            /*Spine.Skeleton.GetAttachment start.*/
            /**
             * Finds an attachment by looking in the skin and skeletonData.defaultSkin using the slot index and attachment name.First the skin is checked and if the attachment was not found, the default skin is checked.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}              slotIndex         
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment: function (slotIndex, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment", this ); }

                if (attachmentName == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentName", "attachmentName cannot be null.");
                }
                if (this.skin != null) {
                    var attachment = this.skin.GetAttachment(slotIndex, attachmentName);
                    if (attachment != null) {
                        return attachment;
                    }
                }
                return this.data.defaultSkin != null ? this.data.defaultSkin.GetAttachment(slotIndex, attachmentName) : null;
            },
            /*Spine.Skeleton.GetAttachment end.*/

            /*Spine.Skeleton.SetAttachment start.*/
            /**
             * A convenience method to set an attachment by finding the slot with FindSlot, finding the attachment with GetAttachment, then setting the slot's slot.Attachment.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    slotName          
             * @param   {string}    attachmentName    May be null to clear the slot's attachment.
             * @return  {void}
             */
            SetAttachment: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetAttachment", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots.Items[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        var attachment = null;
                        if (attachmentName != null) {
                            attachment = this.GetAttachment(i, attachmentName);
                            if (attachment == null) {
                                throw new System.Exception("Attachment not found: " + (attachmentName || "") + ", for slot: " + (slotName || ""));
                            }
                        }
                        slot.Attachment = attachment;
                        return;
                    }
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.Skeleton.SetAttachment end.*/

            /*Spine.Skeleton.FindIkConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                constraintName
             * @return  {Spine.IkConstraint}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints.Items[i];
                    if (Bridge.referenceEquals(ikConstraint.data.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindIkConstraint end.*/

            /*Spine.Skeleton.FindTransformConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                       constraintName
             * @return  {Spine.TransformConstraint}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints.Items[i];
                    if (Bridge.referenceEquals(transformConstraint.data.Name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindTransformConstraint end.*/

            /*Spine.Skeleton.FindPathConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                  constraintName
             * @return  {Spine.PathConstraint}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints.Items[i];
                    if (System.String.equals(constraint.data.Name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindPathConstraint end.*/

            /*Spine.Skeleton.Update start.*/
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Update", this ); }

                this.time += delta;
            },
            /*Spine.Skeleton.Update end.*/

            /*Spine.Skeleton.GetBounds start.*/
            /**
             * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {System.Single}    x               The horizontal distance between the skeleton origin and the left side of the AABB.
             * @param   {System.Single}    y               The vertical distance between the skeleton origin and the bottom side of the AABB.
             * @param   {System.Single}    width           The width of the AABB
             * @param   {System.Single}    height          The height of the AABB.
             * @param   {System.Single}    vertexBuffer    Reference to hold a float[]. May be a null reference. This method will assign it a new float[] with the appropriate size as needed.
             * @return  {void}
             */
            GetBounds: function (x, y, width, height, vertexBuffer) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetBounds", this ); }

                var temp = vertexBuffer.v;
                temp = temp || System.Array.init(8, 0, System.Single);
                var drawOrderItems = this.drawOrder.Items;
                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                for (var i = 0, n = drawOrderItems.length; i < n; i = (i + 1) | 0) {
                    var slot = drawOrderItems[i];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.attachment;
                    var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        verticesLength = 8;
                        vertices = temp;
                        if (vertices.length < 8) {
                            vertices = (temp = System.Array.init(8, 0, System.Single));
                        }
                        regionAttachment.ComputeWorldVertices(slot.bone, temp, 0);
                    } else {
                        var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var mesh = meshAttachment;
                            verticesLength = mesh.WorldVerticesLength;
                            vertices = temp;
                            if (vertices.length < verticesLength) {
                                vertices = (temp = System.Array.init(verticesLength, 0, System.Single));
                            }
                            mesh.ComputeWorldVertices(slot, 0, verticesLength, temp, 0);
                        }
                    }

                    if (vertices != null) {
                        for (var ii = 0; ii < verticesLength; ii = (ii + 2) | 0) {
                            var vx = vertices[ii], vy = vertices[((ii + 1) | 0)];
                            minX = Math.min(minX, vx);
                            minY = Math.min(minY, vy);
                            maxX = Math.max(maxX, vx);
                            maxY = Math.max(maxY, vy);
                        }
                    }
                }
                x.v = minX;
                y.v = minY;
                width.v = maxX - minX;
                height.v = maxY - minY;
                vertexBuffer.v = temp;
            },
            /*Spine.Skeleton.GetBounds end.*/


        },
        overloads: {
            "SortPathConstraintAttachment(Skin, int, Bone)": "SortPathConstraintAttachment$1",
            "UpdateWorldTransform(Bone)": "UpdateWorldTransform$1",
            "SetSkin(string)": "SetSkin$1",
            "GetAttachment(string, string)": "GetAttachment$1"
        }
    });
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonBinary start.*/
    Bridge.define("Spine.SkeletonBinary", {
        statics: {
            fields: {
                BONE_ROTATE: 0,
                BONE_TRANSLATE: 0,
                BONE_SCALE: 0,
                BONE_SHEAR: 0,
                SLOT_ATTACHMENT: 0,
                SLOT_COLOR: 0,
                SLOT_TWO_COLOR: 0,
                PATH_POSITION: 0,
                PATH_SPACING: 0,
                PATH_MIX: 0,
                CURVE_LINEAR: 0,
                CURVE_STEPPED: 0,
                CURVE_BEZIER: 0,
                TransformModeValues: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                    this.BONE_ROTATE = 0;
                    this.BONE_TRANSLATE = 1;
                    this.BONE_SCALE = 2;
                    this.BONE_SHEAR = 3;
                    this.SLOT_ATTACHMENT = 0;
                    this.SLOT_COLOR = 1;
                    this.SLOT_TWO_COLOR = 2;
                    this.PATH_POSITION = 0;
                    this.PATH_SPACING = 1;
                    this.PATH_MIX = 2;
                    this.CURVE_LINEAR = 0;
                    this.CURVE_STEPPED = 1;
                    this.CURVE_BEZIER = 2;
                    this.TransformModeValues = System.Array.init([
                        Spine.TransformMode.Normal, 
                        Spine.TransformMode.OnlyTranslation, 
                        Spine.TransformMode.NoRotationOrReflection, 
                        Spine.TransformMode.NoScale, 
                        Spine.TransformMode.NoScaleOrReflection
                    ], Spine.TransformMode);
                }
            },
            methods: {
                /*Spine.SkeletonBinary.GetVersionString:static start.*/
                /**
                 * Returns the version string of binary skeleton data.
                 *
                 * @static
                 * @public
                 * @this Spine.SkeletonBinary
                 * @memberof Spine.SkeletonBinary
                 * @param   {System.IO.Stream}    file
                 * @return  {string}
                 */
                GetVersionString: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#GetVersionString", this ); }

                    if (file == null) {
                        throw new System.ArgumentNullException.$ctor1("file");
                    }

                    var input = new Spine.SkeletonBinary.SkeletonInput(file);
                    return input.GetVersionString();
                },
                /*Spine.SkeletonBinary.GetVersionString:static end.*/


            }
        },
        fields: {
            Scale: 0,
            attachmentLoader: null,
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonJson.LinkedMesh)).ctor();
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                Spine.SkeletonBinary.$ctor1.call(this, new Spine.AtlasAttachmentLoader(atlasArray));
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor1("attachmentLoader");
                }
                this.attachmentLoader = attachmentLoader;
                this.Scale = 1;
            }
        },
        methods: {
            /*Spine.SkeletonBinary.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData$1", this ); }

                var input = new System.IO.FileStream.$ctor1(path, 3);
                try {
                    var skeletonData = this.ReadSkeletonData(input);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(input)) {
                        input.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonBinary.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonBinary.ReadSkeletonData start.*/
            ReadSkeletonData: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                if (file == null) {
                    throw new System.ArgumentNullException.$ctor1("file");
                }
                var scale = this.Scale;

                var skeletonData = new Spine.SkeletonData();
                var input = new Spine.SkeletonBinary.SkeletonInput(file);

                skeletonData.hash = input.ReadString();
                if (skeletonData.hash.length === 0) {
                    skeletonData.hash = null;
                }
                skeletonData.version = input.ReadString();
                if (skeletonData.version.length === 0) {
                    skeletonData.version = null;
                }
                if (Bridge.referenceEquals("3.8.75", skeletonData.version)) {
                    throw new System.Exception("Unsupported skeleton data, please export with a newer version of Spine.");
                }
                skeletonData.x = input.ReadFloat();
                skeletonData.y = input.ReadFloat();
                skeletonData.width = input.ReadFloat();
                skeletonData.height = input.ReadFloat();

                var nonessential = input.ReadBoolean();

                if (nonessential) {
                    skeletonData.fps = input.ReadFloat();

                    skeletonData.imagesPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.imagesPath)) {
                        skeletonData.imagesPath = null;
                    }

                    skeletonData.audioPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.audioPath)) {
                        skeletonData.audioPath = null;
                    }
                }

                var n;
                var o;

                // Strings.
                input.strings = new (Spine.ExposedList$1(System.String)).$ctor3((n = input.ReadInt$1(true)));
                o = input.strings.Resize(n).Items;
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    o[i] = input.ReadString();
                }

                // Bones.
                o = skeletonData.bones.Resize((n = input.ReadInt$1(true))).Items;
                for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                    var name = input.ReadString();
                    var parent = i1 === 0 ? null : ($t = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    var data = new Spine.BoneData(i1, name, parent);
                    data.rotation = input.ReadFloat();
                    data.x = input.ReadFloat() * scale;
                    data.y = input.ReadFloat() * scale;
                    data.scaleX = input.ReadFloat();
                    data.scaleY = input.ReadFloat();
                    data.shearX = input.ReadFloat();
                    data.shearY = input.ReadFloat();
                    data.length = input.ReadFloat() * scale;
                    data.transformMode = Spine.SkeletonBinary.TransformModeValues[input.ReadInt$1(true)];
                    data.skinRequired = input.ReadBoolean();
                    if (nonessential) {
                        input.ReadInt();
                    } // Skip bone color.
                    o[i1] = data;
                }

                // Slots.
                o = skeletonData.slots.Resize((n = input.ReadInt$1(true))).Items;
                for (var i2 = 0; i2 < n; i2 = (i2 + 1) | 0) {
                    var slotName = input.ReadString();
                    var boneData = ($t1 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    var slotData = new Spine.SlotData(i2, slotName, boneData);
                    var color = input.ReadInt();
                    slotData.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                    slotData.g = ((color & 16711680) >> 16) / 255.0;
                    slotData.b = ((color & 65280) >> 8) / 255.0;
                    slotData.a = ((color & 255)) / 255.0;

                    var darkColor = input.ReadInt(); // 0x00rrggbb
                    if (darkColor !== -1) {
                        slotData.hasSecondColor = true;
                        slotData.r2 = ((darkColor & 16711680) >> 16) / 255.0;
                        slotData.g2 = ((darkColor & 65280) >> 8) / 255.0;
                        slotData.b2 = ((darkColor & 255)) / 255.0;
                    }

                    slotData.attachmentName = input.ReadStringRef();
                    slotData.blendMode = input.ReadInt$1(true);
                    o[i2] = slotData;
                }

                // IK constraints.
                o = skeletonData.ikConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i3 = 0, nn; i3 < n; i3 = (i3 + 1) | 0) {
                    var data1 = new Spine.IkConstraintData(input.ReadString());
                    data1.order = input.ReadInt$1(true);
                    data1.skinRequired = input.ReadBoolean();
                    var bones = data1.bones.Resize((nn = input.ReadInt$1(true))).Items;
                    for (var ii = 0; ii < nn; ii = (ii + 1) | 0) {
                        bones[ii] = ($t2 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data1.target = ($t3 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    data1.mix = input.ReadFloat();
                    data1.softness = input.ReadFloat() * scale;
                    data1.bendDirection = input.ReadSByte();
                    data1.compress = input.ReadBoolean();
                    data1.stretch = input.ReadBoolean();
                    data1.uniform = input.ReadBoolean();
                    o[i3] = data1;
                }

                // Transform constraints.
                o = skeletonData.transformConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i4 = 0, nn1; i4 < n; i4 = (i4 + 1) | 0) {
                    var data2 = new Spine.TransformConstraintData(input.ReadString());
                    data2.order = input.ReadInt$1(true);
                    data2.skinRequired = input.ReadBoolean();
                    var bones1 = data2.bones.Resize((nn1 = input.ReadInt$1(true))).Items;
                    for (var ii1 = 0; ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        bones1[ii1] = ($t4 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data2.target = ($t5 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    data2.local = input.ReadBoolean();
                    data2.relative = input.ReadBoolean();
                    data2.offsetRotation = input.ReadFloat();
                    data2.offsetX = input.ReadFloat() * scale;
                    data2.offsetY = input.ReadFloat() * scale;
                    data2.offsetScaleX = input.ReadFloat();
                    data2.offsetScaleY = input.ReadFloat();
                    data2.offsetShearY = input.ReadFloat();
                    data2.rotateMix = input.ReadFloat();
                    data2.translateMix = input.ReadFloat();
                    data2.scaleMix = input.ReadFloat();
                    data2.shearMix = input.ReadFloat();
                    o[i4] = data2;
                }

                // Path constraints
                o = skeletonData.pathConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i5 = 0, nn2; i5 < n; i5 = (i5 + 1) | 0) {
                    var data3 = new Spine.PathConstraintData(input.ReadString());
                    data3.order = input.ReadInt$1(true);
                    data3.skinRequired = input.ReadBoolean();
                    var bones2 = data3.bones.Resize((nn2 = input.ReadInt$1(true))).Items;
                    for (var ii2 = 0; ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        bones2[ii2] = ($t6 = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }
                    data3.target = ($t7 = skeletonData.slots.Items)[input.ReadInt$1(true)];
                    data3.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.PositionMode), input.ReadInt$1(true)), Spine.PositionMode), System.Int32));
                    data3.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.SpacingMode), input.ReadInt$1(true)), Spine.SpacingMode), System.Int32));
                    data3.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.RotateMode), input.ReadInt$1(true)), Spine.RotateMode), System.Int32));
                    data3.offsetRotation = input.ReadFloat();
                    data3.position = input.ReadFloat();
                    if (data3.positionMode === Spine.PositionMode.Fixed) {
                        data3.position *= scale;
                    }
                    data3.spacing = input.ReadFloat();
                    if (data3.spacingMode === Spine.SpacingMode.Length || data3.spacingMode === Spine.SpacingMode.Fixed) {
                        data3.spacing *= scale;
                    }
                    data3.rotateMix = input.ReadFloat();
                    data3.translateMix = input.ReadFloat();
                    o[i5] = data3;
                }

                // Default skin.
                var defaultSkin = this.ReadSkin(input, skeletonData, true, nonessential);
                if (defaultSkin != null) {
                    skeletonData.defaultSkin = defaultSkin;
                    skeletonData.skins.Add(defaultSkin);
                }

                // Skins.
                {
                    var i6 = skeletonData.skins.Count;
                    o = skeletonData.skins.Resize((n = (i6 + input.ReadInt$1(true)) | 0)).Items;
                    for (; i6 < n; i6 = (i6 + 1) | 0) {
                        o[i6] = this.ReadSkin(input, skeletonData, false, nonessential);
                    }
                }

                // Linked meshes.
                n = this.linkedMeshes.Count;
                for (var i7 = 0; i7 < n; i7 = (i7 + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i7);
                    var skin = linkedMesh.skin == null ? skeletonData.DefaultSkin : skeletonData.FindSkin(linkedMesh.skin);
                    if (skin == null) {
                        throw new System.Exception("Skin not found: " + (linkedMesh.skin || ""));
                    }
                    var parent1 = skin.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.DeformAttachment = linkedMesh.inheritDeform ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    linkedMesh.mesh.UpdateUVs();
                }
                this.linkedMeshes.clear();

                // Events.
                o = skeletonData.events.Resize((n = input.ReadInt$1(true))).Items;
                for (var i8 = 0; i8 < n; i8 = (i8 + 1) | 0) {
                    var data4 = new Spine.EventData(input.ReadStringRef());
                    data4.Int = input.ReadInt$1(false);
                    data4.Float = input.ReadFloat();
                    data4.String = input.ReadString();
                    data4.AudioPath = input.ReadString();
                    if (data4.AudioPath != null) {
                        data4.Volume = input.ReadFloat();
                        data4.Balance = input.ReadFloat();
                    }
                    o[i8] = data4;
                }

                // Animations.
                o = skeletonData.animations.Resize((n = input.ReadInt$1(true))).Items;
                for (var i9 = 0; i9 < n; i9 = (i9 + 1) | 0) {
                    o[i9] = this.ReadAnimation(input.ReadString(), input, skeletonData);
                }

                return skeletonData;
            },
            /*Spine.SkeletonBinary.ReadSkeletonData end.*/

            /*Spine.SkeletonBinary.ReadSkin start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input           
             * @param   {Spine.SkeletonData}                    skeletonData    
             * @param   {boolean}                               defaultSkin     
             * @param   {boolean}                               nonessential
             * @return  {Spine.Skin}                                            May be null.
             */
            ReadSkin: function (input, skeletonData, defaultSkin, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkin", this ); }

                var $t, $t1, $t2, $t3;

                var skin;
                var slotCount;

                if (defaultSkin) {
                    slotCount = input.ReadInt$1(true);
                    if (slotCount === 0) {
                        return null;
                    }
                    skin = new Spine.Skin("default");
                } else {
                    skin = new Spine.Skin(input.ReadStringRef());
                    var bones = skin.bones.Resize(input.ReadInt$1(true)).Items;
                    for (var i = 0, n = skin.bones.Count; i < n; i = (i + 1) | 0) {
                        bones[i] = ($t = skeletonData.bones.Items)[input.ReadInt$1(true)];
                    }

                    for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                        skin.constraints.Add(($t1 = skeletonData.ikConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                        skin.constraints.Add(($t2 = skeletonData.transformConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                        skin.constraints.Add(($t3 = skeletonData.pathConstraints.Items)[input.ReadInt$1(true)]);
                    }
                    skin.constraints.TrimExcess();
                    slotCount = input.ReadInt$1(true);
                }
                for (var i4 = 0; i4 < slotCount; i4 = (i4 + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var name = input.ReadStringRef();
                        var attachment = this.ReadAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
                        if (attachment != null) {
                            skin.SetAttachment(slotIndex, name, attachment);
                        }
                    }
                }
                return skin;
            },
            /*Spine.SkeletonBinary.ReadSkin end.*/

            /*Spine.SkeletonBinary.ReadAttachment start.*/
            ReadAttachment: function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAttachment", this ); }

                var $t;

                var scale = this.Scale;

                var name = input.ReadStringRef();
                if (name == null) {
                    name = attachmentName;
                }

                var type = input.ReadByte();
                switch (type) {
                    case Spine.AttachmentType.Region: 
                        {
                            var path = input.ReadStringRef();
                            var rotation = input.ReadFloat();
                            var x = input.ReadFloat();
                            var y = input.ReadFloat();
                            var scaleX = input.ReadFloat();
                            var scaleY = input.ReadFloat();
                            var width = input.ReadFloat();
                            var height = input.ReadFloat();
                            var color = input.ReadInt();

                            if (path == null) {
                                path = name;
                            }
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = x * scale;
                            region.y = y * scale;
                            region.scaleX = scaleX;
                            region.scaleY = scaleY;
                            region.rotation = rotation;
                            region.width = width * scale;
                            region.height = height * scale;
                            region.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            region.g = ((color & 16711680) >> 16) / 255.0;
                            region.b = ((color & 65280) >> 8) / 255.0;
                            region.a = ((color & 255)) / 255.0;
                            region.UpdateOffset();
                            return region;
                        }
                    case Spine.AttachmentType.Boundingbox: 
                        {
                            var vertexCount = input.ReadInt$1(true);
                            var vertices = this.ReadVertices(input, vertexCount);
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0; // Avoid unused local warning.

                            var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                            if (box == null) {
                                return null;
                            }
                            box.worldVerticesLength = vertexCount << 1;
                            box.vertices = vertices.vertices;
                            box.bones = vertices.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(box.getColor(), color);
                            return box;
                        }
                    case Spine.AttachmentType.Mesh: 
                        {
                            var path1 = input.ReadStringRef();
                            var color1 = input.ReadInt();
                            var vertexCount1 = input.ReadInt$1(true);
                            var uvs = this.ReadFloatArray(input, vertexCount1 << 1, 1);
                            var triangles = this.ReadShortArray(input);
                            var vertices1 = this.ReadVertices(input, vertexCount1);
                            var hullLength = input.ReadInt$1(true);
                            var edges = null;
                            var width1 = 0, height1 = 0;
                            if (nonessential) {
                                edges = this.ReadShortArray(input);
                                width1 = input.ReadFloat();
                                height1 = input.ReadFloat();
                            }

                            if (path1 == null) {
                                path1 = name;
                            }
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path1);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path1;
                            mesh.r = ((System.Int64(color1).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh.g = ((color1 & 16711680) >> 16) / 255.0;
                            mesh.b = ((color1 & 65280) >> 8) / 255.0;
                            mesh.a = ((color1 & 255)) / 255.0;
                            mesh.bones = vertices1.bones;
                            mesh.vertices = vertices1.vertices;
                            mesh.WorldVerticesLength = vertexCount1 << 1;
                            mesh.triangles = triangles;
                            mesh.regionUVs = uvs;
                            mesh.UpdateUVs();
                            mesh.HullLength = hullLength << 1;
                            if (nonessential) {
                                mesh.Edges = edges;
                                mesh.Width = width1 * scale;
                                mesh.Height = height1 * scale;
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var path2 = input.ReadStringRef();
                            var color2 = input.ReadInt();
                            var skinName = input.ReadStringRef();
                            var parent = input.ReadStringRef();
                            var inheritDeform = input.ReadBoolean();
                            var width2 = 0, height2 = 0;
                            if (nonessential) {
                                width2 = input.ReadFloat();
                                height2 = input.ReadFloat();
                            }

                            if (path2 == null) {
                                path2 = name;
                            }
                            var mesh1 = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path2);
                            if (mesh1 == null) {
                                return null;
                            }
                            mesh1.Path = path2;
                            mesh1.r = ((System.Int64(color2).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh1.g = ((color2 & 16711680) >> 16) / 255.0;
                            mesh1.b = ((color2 & 65280) >> 8) / 255.0;
                            mesh1.a = ((color2 & 255)) / 255.0;
                            if (nonessential) {
                                mesh1.Width = width2 * scale;
                                mesh1.Height = height2 * scale;
                            }
                            this.linkedMeshes.add(new Spine.SkeletonJson.LinkedMesh(mesh1, skinName, slotIndex, parent, inheritDeform));
                            return mesh1;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var closed = input.ReadBoolean();
                            var constantSpeed = input.ReadBoolean();
                            var vertexCount2 = input.ReadInt$1(true);
                            var vertices2 = this.ReadVertices(input, vertexCount2);
                            var lengths = System.Array.init(((Bridge.Int.div(vertexCount2, 3)) | 0), 0, System.Single);
                            for (var i = 0, n = lengths.length; i < n; i = (i + 1) | 0) {
                                lengths[i] = input.ReadFloat() * scale;
                            }
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var path3 = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (path3 == null) {
                                return null;
                            }
                            path3.closed = closed;
                            path3.constantSpeed = constantSpeed;
                            path3.worldVerticesLength = vertexCount2 << 1;
                            path3.vertices = vertices2.vertices;
                            path3.bones = vertices2.bones;
                            path3.lengths = lengths;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(path.getColor(), color);
                            return path3;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var rotation1 = input.ReadFloat();
                            var x1 = input.ReadFloat();
                            var y1 = input.ReadFloat();
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = x1 * scale;
                            point.y = y1 * scale;
                            point.rotation = rotation1;
                            // skipped porting: if (nonessential) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var endSlotIndex = input.ReadInt$1(true);
                            var vertexCount3 = input.ReadInt$1(true);
                            var vertices3 = this.ReadVertices(input, vertexCount3);
                            if (nonessential) {
                                input.ReadInt();
                            }

                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }
                            clip.EndSlot = ($t = skeletonData.slots.Items)[endSlotIndex];
                            clip.worldVerticesLength = vertexCount3 << 1;
                            clip.vertices = vertices3.vertices;
                            clip.bones = vertices3.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(clip.getColor(), color);
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonBinary.ReadAttachment end.*/

            /*Spine.SkeletonBinary.ReadVertices start.*/
            ReadVertices: function (input, vertexCount) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadVertices", this ); }

                var scale = this.Scale;
                var verticesLength = vertexCount << 1;
                var vertices = new Spine.SkeletonBinary.Vertices();
                if (!input.ReadBoolean()) {
                    vertices.vertices = this.ReadFloatArray(input, verticesLength, scale);
                    return vertices;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bonesArray = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    var boneCount = input.ReadInt$1(true);
                    bonesArray.Add(boneCount);
                    for (var ii = 0; ii < boneCount; ii = (ii + 1) | 0) {
                        bonesArray.Add(input.ReadInt$1(true));
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat());
                    }
                }

                vertices.vertices = weights.ToArray();
                vertices.bones = bonesArray.ToArray();
                return vertices;
            },
            /*Spine.SkeletonBinary.ReadVertices end.*/

            /*Spine.SkeletonBinary.ReadFloatArray start.*/
            ReadFloatArray: function (input, n, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadFloatArray", this ); }

                var array = System.Array.init(n, 0, System.Single);
                if (scale === 1) {
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        array[i] = input.ReadFloat();
                    }
                } else {
                    for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                        array[i1] = input.ReadFloat() * scale;
                    }
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadFloatArray end.*/

            /*Spine.SkeletonBinary.ReadShortArray start.*/
            ReadShortArray: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadShortArray", this ); }

                var n = input.ReadInt$1(true);
                var array = System.Array.init(n, 0, System.Int32);
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    array[i] = (input.ReadByte() << 8) | input.ReadByte();
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadShortArray end.*/

            /*Spine.SkeletonBinary.ReadAnimation start.*/
            ReadAnimation: function (name, input, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).$ctor3(32);
                var scale = this.Scale;
                var duration = 0;

                // Slot timelines.
                for (var i = 0, n = input.ReadInt$1(true); i < n; i = (i + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var timelineType = input.ReadByte();
                        var frameCount = input.ReadInt$1(true);
                        switch (timelineType) {
                            case Spine.SkeletonBinary.SLOT_ATTACHMENT: 
                                {
                                    var timeline = new Spine.AttachmentTimeline(frameCount);
                                    timeline.slotIndex = slotIndex;
                                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex = (frameIndex + 1) | 0) {
                                        timeline.SetFrame(frameIndex, input.ReadFloat(), input.ReadStringRef());
                                    }
                                    timelines.Add(timeline);
                                    duration = Math.max(duration, timeline.frames[((frameCount - 1) | 0)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_COLOR: 
                                {
                                    var timeline1 = new Spine.ColorTimeline(frameCount);
                                    timeline1.slotIndex = slotIndex;
                                    for (var frameIndex1 = 0; frameIndex1 < frameCount; frameIndex1 = (frameIndex1 + 1) | 0) {
                                        var time = input.ReadFloat();
                                        var color = input.ReadInt();
                                        var r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                                        var g = ((color & 16711680) >> 16) / 255.0;
                                        var b = ((color & 65280) >> 8) / 255.0;
                                        var a = ((color & 255)) / 255.0;
                                        timeline1.SetFrame(frameIndex1, time, r, g, b, a);
                                        if (frameIndex1 < ((frameCount - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex1, timeline1);
                                        }
                                    }
                                    timelines.Add(timeline1);
                                    duration = Math.max(duration, timeline1.frames[Bridge.Int.mul((((frameCount - 1) | 0)), Spine.ColorTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_TWO_COLOR: 
                                {
                                    var timeline2 = new Spine.TwoColorTimeline(frameCount);
                                    timeline2.slotIndex = slotIndex;
                                    for (var frameIndex2 = 0; frameIndex2 < frameCount; frameIndex2 = (frameIndex2 + 1) | 0) {
                                        var time1 = input.ReadFloat();
                                        var color1 = input.ReadInt();
                                        var r1 = ((System.Int64(color1).and(System.Int64(4278190080))).shr(24)) / 255.0;
                                        var g1 = ((color1 & 16711680) >> 16) / 255.0;
                                        var b1 = ((color1 & 65280) >> 8) / 255.0;
                                        var a1 = ((color1 & 255)) / 255.0;
                                        var color2 = input.ReadInt(); // 0x00rrggbb
                                        var r2 = ((color2 & 16711680) >> 16) / 255.0;
                                        var g2 = ((color2 & 65280) >> 8) / 255.0;
                                        var b2 = ((color2 & 255)) / 255.0;

                                        timeline2.SetFrame(frameIndex2, time1, r1, g1, b1, a1, r2, g2, b2);
                                        if (frameIndex2 < ((frameCount - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex2, timeline2);
                                        }
                                    }
                                    timelines.Add(timeline2);
                                    duration = Math.max(duration, timeline2.frames[Bridge.Int.mul((((frameCount - 1) | 0)), Spine.TwoColorTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // Bone timelines.
                for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                    var boneIndex = input.ReadInt$1(true);
                    for (var ii1 = 0, nn1 = input.ReadInt$1(true); ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        var timelineType1 = input.ReadByte();
                        var frameCount1 = input.ReadInt$1(true);
                        switch (timelineType1) {
                            case Spine.SkeletonBinary.BONE_ROTATE: 
                                {
                                    var timeline3 = new Spine.RotateTimeline(frameCount1);
                                    timeline3.boneIndex = boneIndex;
                                    for (var frameIndex3 = 0; frameIndex3 < frameCount1; frameIndex3 = (frameIndex3 + 1) | 0) {
                                        timeline3.SetFrame(frameIndex3, input.ReadFloat(), input.ReadFloat());
                                        if (frameIndex3 < ((frameCount1 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex3, timeline3);
                                        }
                                    }
                                    timelines.Add(timeline3);
                                    duration = Math.max(duration, timeline3.frames[Bridge.Int.mul((((frameCount1 - 1) | 0)), Spine.RotateTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.BONE_TRANSLATE: 
                            case Spine.SkeletonBinary.BONE_SCALE: 
                            case Spine.SkeletonBinary.BONE_SHEAR: 
                                {
                                    var timeline4;
                                    var timelineScale = 1;
                                    if (timelineType1 === Spine.SkeletonBinary.BONE_SCALE) {
                                        timeline4 = new Spine.ScaleTimeline(frameCount1);
                                    } else {
                                        if (timelineType1 === Spine.SkeletonBinary.BONE_SHEAR) {
                                            timeline4 = new Spine.ShearTimeline(frameCount1);
                                        } else {
                                            timeline4 = new Spine.TranslateTimeline(frameCount1);
                                            timelineScale = scale;
                                        }
                                    }
                                    timeline4.boneIndex = boneIndex;
                                    for (var frameIndex4 = 0; frameIndex4 < frameCount1; frameIndex4 = (frameIndex4 + 1) | 0) {
                                        timeline4.SetFrame(frameIndex4, input.ReadFloat(), input.ReadFloat() * timelineScale, input.ReadFloat() * timelineScale);
                                        if (frameIndex4 < ((frameCount1 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex4, timeline4);
                                        }
                                    }
                                    timelines.Add(timeline4);
                                    duration = Math.max(duration, timeline4.frames[Bridge.Int.mul((((frameCount1 - 1) | 0)), Spine.TranslateTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // IK constraint timelines.
                for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                    var index = input.ReadInt$1(true);
                    var frameCount2 = input.ReadInt$1(true);
                    var timeline5 = ($t = new Spine.IkConstraintTimeline(frameCount2), $t.ikConstraintIndex = index, $t);
                    for (var frameIndex5 = 0; frameIndex5 < frameCount2; frameIndex5 = (frameIndex5 + 1) | 0) {
                        timeline5.SetFrame(frameIndex5, input.ReadFloat(), input.ReadFloat(), input.ReadFloat() * scale, input.ReadSByte(), input.ReadBoolean(), input.ReadBoolean());
                        if (frameIndex5 < ((frameCount2 - 1) | 0)) {
                            this.ReadCurve(input, frameIndex5, timeline5);
                        }
                    }
                    timelines.Add(timeline5);
                    duration = Math.max(duration, timeline5.frames[Bridge.Int.mul((((frameCount2 - 1) | 0)), Spine.IkConstraintTimeline.ENTRIES)]);
                }

                // Transform constraint timelines.
                for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                    var index1 = input.ReadInt$1(true);
                    var frameCount3 = input.ReadInt$1(true);
                    var timeline6 = new Spine.TransformConstraintTimeline(frameCount3);
                    timeline6.transformConstraintIndex = index1;
                    for (var frameIndex6 = 0; frameIndex6 < frameCount3; frameIndex6 = (frameIndex6 + 1) | 0) {
                        timeline6.SetFrame(frameIndex6, input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                        if (frameIndex6 < ((frameCount3 - 1) | 0)) {
                            this.ReadCurve(input, frameIndex6, timeline6);
                        }
                    }
                    timelines.Add(timeline6);
                    duration = Math.max(duration, timeline6.frames[Bridge.Int.mul((((frameCount3 - 1) | 0)), Spine.TransformConstraintTimeline.ENTRIES)]);
                }

                // Path constraint timelines.
                for (var i4 = 0, n4 = input.ReadInt$1(true); i4 < n4; i4 = (i4 + 1) | 0) {
                    var index2 = input.ReadInt$1(true);
                    var data = ($t = skeletonData.pathConstraints.Items)[index2];
                    for (var ii2 = 0, nn2 = input.ReadInt$1(true); ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        var timelineType2 = input.ReadSByte();
                        var frameCount4 = input.ReadInt$1(true);
                        switch (timelineType2) {
                            case Spine.SkeletonBinary.PATH_POSITION: 
                            case Spine.SkeletonBinary.PATH_SPACING: 
                                {
                                    var timeline7;
                                    var timelineScale1 = 1;
                                    if (timelineType2 === Spine.SkeletonBinary.PATH_SPACING) {
                                        timeline7 = new Spine.PathConstraintSpacingTimeline(frameCount4);
                                        if (data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed) {
                                            timelineScale1 = scale;
                                        }
                                    } else {
                                        timeline7 = new Spine.PathConstraintPositionTimeline(frameCount4);
                                        if (data.positionMode === Spine.PositionMode.Fixed) {
                                            timelineScale1 = scale;
                                        }
                                    }
                                    timeline7.pathConstraintIndex = index2;
                                    for (var frameIndex7 = 0; frameIndex7 < frameCount4; frameIndex7 = (frameIndex7 + 1) | 0) {
                                        timeline7.SetFrame(frameIndex7, input.ReadFloat(), input.ReadFloat() * timelineScale1);
                                        if (frameIndex7 < ((frameCount4 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex7, timeline7);
                                        }
                                    }
                                    timelines.Add(timeline7);
                                    duration = Math.max(duration, timeline7.frames[Bridge.Int.mul((((frameCount4 - 1) | 0)), Spine.PathConstraintPositionTimeline.ENTRIES)]);
                                    break;
                                }
                            case Spine.SkeletonBinary.PATH_MIX: 
                                {
                                    var timeline8 = new Spine.PathConstraintMixTimeline(frameCount4);
                                    timeline8.pathConstraintIndex = index2;
                                    for (var frameIndex8 = 0; frameIndex8 < frameCount4; frameIndex8 = (frameIndex8 + 1) | 0) {
                                        timeline8.SetFrame(frameIndex8, input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                                        if (frameIndex8 < ((frameCount4 - 1) | 0)) {
                                            this.ReadCurve(input, frameIndex8, timeline8);
                                        }
                                    }
                                    timelines.Add(timeline8);
                                    duration = Math.max(duration, timeline8.frames[Bridge.Int.mul((((frameCount4 - 1) | 0)), Spine.PathConstraintMixTimeline.ENTRIES)]);
                                    break;
                                }
                        }
                    }
                }

                // Deform timelines.
                for (var i5 = 0, n5 = input.ReadInt$1(true); i5 < n5; i5 = (i5 + 1) | 0) {
                    var skin = ($t1 = skeletonData.skins.Items)[input.ReadInt$1(true)];
                    for (var ii3 = 0, nn3 = input.ReadInt$1(true); ii3 < nn3; ii3 = (ii3 + 1) | 0) {
                        var slotIndex1 = input.ReadInt$1(true);
                        for (var iii = 0, nnn = input.ReadInt$1(true); iii < nnn; iii = (iii + 1) | 0) {
                            var attachment = Bridge.cast(skin.GetAttachment(slotIndex1, input.ReadStringRef()), Spine.VertexAttachment);
                            var weighted = attachment.bones != null;
                            var vertices = attachment.vertices;
                            var deformLength = weighted ? Bridge.Int.mul(((Bridge.Int.div(vertices.length, 3)) | 0), 2) : vertices.length;

                            var frameCount5 = input.ReadInt$1(true);
                            var timeline9 = new Spine.DeformTimeline(frameCount5);
                            timeline9.slotIndex = slotIndex1;
                            timeline9.attachment = attachment;

                            for (var frameIndex9 = 0; frameIndex9 < frameCount5; frameIndex9 = (frameIndex9 + 1) | 0) {
                                var time2 = input.ReadFloat();
                                var deform;
                                var end = input.ReadInt$1(true);
                                if (end === 0) {
                                    deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                } else {
                                    deform = System.Array.init(deformLength, 0, System.Single);
                                    var start = input.ReadInt$1(true);
                                    end = (end + start) | 0;
                                    if (scale === 1) {
                                        for (var v = start; v < end; v = (v + 1) | 0) {
                                            deform[v] = input.ReadFloat();
                                        }
                                    } else {
                                        for (var v1 = start; v1 < end; v1 = (v1 + 1) | 0) {
                                            deform[v1] = input.ReadFloat() * scale;
                                        }
                                    }
                                    if (!weighted) {
                                        for (var v2 = 0, vn = deform.length; v2 < vn; v2 = (v2 + 1) | 0) {
                                            deform[v2] += vertices[v2];
                                        }
                                    }
                                }

                                timeline9.SetFrame(frameIndex9, time2, deform);
                                if (frameIndex9 < ((frameCount5 - 1) | 0)) {
                                    this.ReadCurve(input, frameIndex9, timeline9);
                                }
                            }
                            timelines.Add(timeline9);
                            duration = Math.max(duration, timeline9.frames[((frameCount5 - 1) | 0)]);
                        }
                    }
                }

                // Draw order timeline.
                var drawOrderCount = input.ReadInt$1(true);
                if (drawOrderCount > 0) {
                    var timeline10 = new Spine.DrawOrderTimeline(drawOrderCount);
                    var slotCount = skeletonData.slots.Count;
                    for (var i6 = 0; i6 < drawOrderCount; i6 = (i6 + 1) | 0) {
                        var time3 = input.ReadFloat();
                        var offsetCount = input.ReadInt$1(true);
                        var drawOrder = System.Array.init(slotCount, 0, System.Int32);
                        for (var ii4 = (slotCount - 1) | 0; ii4 >= 0; ii4 = (ii4 - 1) | 0) {
                            drawOrder[ii4] = -1;
                        }
                        var unchanged = System.Array.init(((slotCount - offsetCount) | 0), 0, System.Int32);
                        var originalIndex = 0, unchangedIndex = 0;
                        for (var ii5 = 0; ii5 < offsetCount; ii5 = (ii5 + 1) | 0) {
                            var slotIndex2 = input.ReadInt$1(true);
                            // Collect unchanged items.
                            while (originalIndex !== slotIndex2) {
                                unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                            }
                            // Set changed items.
                            drawOrder[((originalIndex + input.ReadInt$1(true)) | 0)] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Collect remaining unchanged items.
                        while (originalIndex < slotCount) {
                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Fill in unchanged items.
                        for (var ii6 = (slotCount - 1) | 0; ii6 >= 0; ii6 = (ii6 - 1) | 0) {
                            if (drawOrder[ii6] === -1) {
                                drawOrder[ii6] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                            }
                        }
                        timeline10.SetFrame(i6, time3, drawOrder);
                    }
                    timelines.Add(timeline10);
                    duration = Math.max(duration, timeline10.frames[((drawOrderCount - 1) | 0)]);
                }

                // Event timeline.
                var eventCount = input.ReadInt$1(true);
                if (eventCount > 0) {
                    var timeline11 = new Spine.EventTimeline(eventCount);
                    for (var i7 = 0; i7 < eventCount; i7 = (i7 + 1) | 0) {
                        var time4 = input.ReadFloat();
                        var eventData = ($t2 = skeletonData.events.Items)[input.ReadInt$1(true)];
                        var e = ($t3 = new Spine.Event(time4, eventData), $t3.Int = input.ReadInt$1(false), $t3.Float = input.ReadFloat(), $t3.String = input.ReadBoolean() ? input.ReadString() : eventData.String, $t3);
                        if (e.data.AudioPath != null) {
                            e.volume = input.ReadFloat();
                            e.balance = input.ReadFloat();
                        }
                        timeline11.SetFrame(i7, e);
                    }
                    timelines.Add(timeline11);
                    duration = Math.max(duration, timeline11.frames[((eventCount - 1) | 0)]);
                }

                timelines.TrimExcess();
                return new Spine.Animation(name, timelines, duration);
            },
            /*Spine.SkeletonBinary.ReadAnimation end.*/

            /*Spine.SkeletonBinary.ReadCurve start.*/
            ReadCurve: function (input, frameIndex, timeline) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadCurve", this ); }

                switch (input.ReadByte()) {
                    case Spine.SkeletonBinary.CURVE_STEPPED: 
                        timeline.SetStepped(frameIndex);
                        break;
                    case Spine.SkeletonBinary.CURVE_BEZIER: 
                        timeline.SetCurve(frameIndex, input.ReadFloat(), input.ReadFloat(), input.ReadFloat(), input.ReadFloat());
                        break;
                }
            },
            /*Spine.SkeletonBinary.ReadCurve end.*/


        },
        overloads: {
            "ReadSkeletonData(String)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    Bridge.define("Spine.SkeletonBinary.SkeletonInput", {
        $kind: "nested class",
        fields: {
            chars: null,
            bytesBigEndian: null,
            strings: null,
            input: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#init", this ); }

                this.chars = System.Array.init(32, 0, System.Byte);
                this.bytesBigEndian = System.Array.init(4, 0, System.Byte);
            },
            ctor: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ctor", this ); }

                this.$initialize();
                this.input = input;
            }
        },
        methods: {
            /*Spine.SkeletonBinary+SkeletonInput.ReadByte start.*/
            ReadByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadByte", this ); }

                return ((this.input.ReadByte()) & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte start.*/
            ReadSByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadSByte", this ); }

                var value = this.input.ReadByte();
                if (value === -1) {
                    throw new System.IO.EndOfStreamException.ctor();
                }
                return Bridge.Int.sxb(value & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean start.*/
            ReadBoolean: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadBoolean", this ); }

                return this.input.ReadByte() !== 0;
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat start.*/
            ReadFloat: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFloat", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                this.chars[3] = this.bytesBigEndian[0];
                this.chars[2] = this.bytesBigEndian[1];
                this.chars[1] = this.bytesBigEndian[2];
                this.chars[0] = this.bytesBigEndian[3];
                return System.BitConverter.toSingle(this.chars, 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt start.*/
            ReadInt: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                return (((((((this.bytesBigEndian[0] << 24) + (this.bytesBigEndian[1] << 16)) | 0) + (this.bytesBigEndian[2] << 8)) | 0) + this.bytesBigEndian[3]) | 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 start.*/
            ReadInt$1: function (optimizePositive) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt$1", this ); }

                var b = this.input.ReadByte();
                var result = b & 127;
                if ((b & 128) !== 0) {
                    b = this.input.ReadByte();
                    result = result | ((b & 127) << 7);
                    if ((b & 128) !== 0) {
                        b = this.input.ReadByte();
                        result = result | ((b & 127) << 14);
                        if ((b & 128) !== 0) {
                            b = this.input.ReadByte();
                            result = result | ((b & 127) << 21);
                            if ((b & 128) !== 0) {
                                result = result | ((this.input.ReadByte() & 127) << 28);
                            }
                        }
                    }
                }
                return optimizePositive ? result : ((result >> 1) ^ ((-(result & 1)) | 0));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadString start.*/
            ReadString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadString", this ); }

                var byteCount = this.ReadInt$1(true);
                switch (byteCount) {
                    case 0: 
                        return null;
                    case 1: 
                        return "";
                }
                byteCount = (byteCount - 1) | 0;
                var buffer = this.chars;
                if (buffer.length < byteCount) {
                    buffer = System.Array.init(byteCount, 0, System.Byte);
                }
                this.ReadFully(buffer, 0, byteCount);
                return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            ReadStringRef: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadStringRef", this ); }

                var $t;
                var index = this.ReadInt$1(true);
                return index === 0 ? null : ($t = this.strings.Items)[((index - 1) | 0)];
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFully start.*/
            ReadFully: function (buffer, offset, length) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFully", this ); }

                while (length > 0) {
                    var count = this.input.Read(buffer, offset, length);
                    if (count <= 0) {
                        throw new System.IO.EndOfStreamException.ctor();
                    }
                    offset = (offset + count) | 0;
                    length = (length - count) | 0;
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFully end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString start.*/
            /**
             * Returns the version string of binary skeleton data.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            GetVersionString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionString", this ); }

                var $t;
                try {
                    // Hash.
                    var byteCount = this.ReadInt$1(true);
                    if (byteCount > 1) {
                        ($t = this.input).Position = $t.Position.add(System.Int64(byteCount - 1));
                    }

                    // Version.
                    byteCount = this.ReadInt$1(true);
                    if (byteCount > 1) {
                        byteCount = (byteCount - 1) | 0;
                        var buffer = System.Array.init(byteCount, 0, System.Byte);
                        this.ReadFully(buffer, 0, byteCount);
                        return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
                    }

                    throw new System.ArgumentException.$ctor3("Stream does not contain a valid binary Skeleton Data.", "input");
                } catch (e) {
                    e = System.Exception.create(e);
                    throw new System.ArgumentException.$ctor3(System.String.concat("Stream does not contain a valid binary Skeleton Data.\n", e), "input");
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString end.*/


        },
        overloads: {
            "ReadInt(bool)": "ReadInt$1"
        }
    });
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    Bridge.define("Spine.SkeletonBinary.Vertices", {
        $kind: "nested class",
        fields: {
            bones: null,
            vertices: null
        }
    });
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBounds start.*/
    /**
     * Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.
     The polygon vertices are provided along with convenience methods for doing hit detection.
     *
     * @public
     * @class Spine.SkeletonBounds
     */
    Bridge.define("Spine.SkeletonBounds", {
        fields: {
            polygonPool: null,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            BoundingBoxes: null,
            Polygons: null
        },
        props: {
            MinX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#get", this ); }

                    return this.minX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#set", this ); }

                    this.minX = value;
                }
            },
            MinY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#get", this ); }

                    return this.minY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#set", this ); }

                    this.minY = value;
                }
            },
            MaxX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#get", this ); }

                    return this.maxX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#set", this ); }

                    this.maxX = value;
                }
            },
            MaxY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#get", this ); }

                    return this.maxY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#set", this ); }

                    this.maxY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Width#get", this ); }

                    return this.maxX - this.minX;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Height#get", this ); }

                    return this.maxY - this.minY;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#init", this ); }

                this.polygonPool = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ctor", this ); }

                this.$initialize();
                this.BoundingBoxes = new (Spine.ExposedList$1(Spine.BoundingBoxAttachment)).ctor();
                this.Polygons = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonBounds.Update start.*/
            /**
             * Clears any previous polygons, finds all visible bounding box attachments,
             and computes the world vertices for each bounding box's polygon.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Skeleton}    skeleton      The skeleton.
             * @param   {boolean}           updateAabb    If true, the axis aligned bounding box containing all the polygons is computed.
             If false, the SkeletonBounds AABB methods will always return true.
             * @return  {void}
             */
            Update: function (skeleton, updateAabb) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Update", this ); }

                var $t;
                var boundingBoxes = this.BoundingBoxes;
                var polygons = this.Polygons;
                var slots = skeleton.slots;
                var slotCount = slots.Count;

                boundingBoxes.Clear();
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Add(polygons.Items[i]);
                }
                polygons.Clear();

                for (var i1 = 0; i1 < slotCount; i1 = (i1 + 1) | 0) {
                    var slot = slots.Items[i1];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var boundingBox = Bridge.as(slot.attachment, Spine.BoundingBoxAttachment);
                    if (boundingBox == null) {
                        continue;
                    }
                    boundingBoxes.Add(boundingBox);

                    var polygon = null;
                    var poolCount = this.polygonPool.Count;
                    if (poolCount > 0) {
                        polygon = ($t = this.polygonPool.Items)[((poolCount - 1) | 0)];
                        this.polygonPool.RemoveAt(((poolCount - 1) | 0));
                    } else {
                        polygon = new Spine.Polygon();
                    }
                    polygons.Add(polygon);

                    var count = boundingBox.worldVerticesLength;
                    polygon.Count = count;
                    if (polygon.Vertices.length < count) {
                        polygon.Vertices = System.Array.init(count, 0, System.Single);
                    }
                    boundingBox.ComputeWorldVertices$1(slot, polygon.Vertices);
                }

                if (updateAabb) {
                    this.AabbCompute();
                } else {
                    this.minX = -2147483648;
                    this.minY = -2147483648;
                    this.maxX = 2147483647;
                    this.maxY = 2147483647;
                }
            },
            /*Spine.SkeletonBounds.Update end.*/

            /*Spine.SkeletonBounds.AabbCompute start.*/
            AabbCompute: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbCompute", this ); }

                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    var polygon = polygons.Items[i];
                    var vertices = polygon.Vertices;
                    for (var ii = 0, nn = polygon.Count; ii < nn; ii = (ii + 2) | 0) {
                        var x = vertices[ii];
                        var y = vertices[((ii + 1) | 0)];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            },
            /*Spine.SkeletonBounds.AabbCompute end.*/

            /*Spine.SkeletonBounds.AabbContainsPoint start.*/
            /**
             * Returns true if the axis aligned bounding box contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x    
             * @param   {number}     y
             * @return  {boolean}
             */
            AabbContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbContainsPoint", this ); }

                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
            },
            /*Spine.SkeletonBounds.AabbContainsPoint end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSegment start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x1    
             * @param   {number}     y1    
             * @param   {number}     x2    
             * @param   {number}     y2
             * @return  {boolean}
             */
            AabbIntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSegment", this ); }

                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {
                    return false;
                }
                var m = (y2 - y1) / (x2 - x1);
                var y = m * (minX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                y = m * (maxX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                var x = (minY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                x = (maxY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                return false;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSegment end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSkeleton start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.SkeletonBounds}    bounds
             * @return  {boolean}
             */
            AabbIntersectsSkeleton: function (bounds) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSkeleton", this ); }

                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSkeleton end.*/

            /*Spine.SkeletonBounds.ContainsPoint$1 start.*/
            /**
             * Returns true if the polygon contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x          
             * @param   {number}           y
             * @return  {boolean}
             */
            ContainsPoint$1: function (polygon, x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var prevIndex = (nn - 2) | 0;
                var inside = false;
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var vertexY = vertices[((ii + 1) | 0)];
                    var prevY = vertices[((prevIndex + 1) | 0)];
                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) {
                            inside = !inside;
                        }
                    }
                    prevIndex = ii;
                }
                return inside;
            },
            /*Spine.SkeletonBounds.ContainsPoint$1 end.*/

            /*Spine.SkeletonBounds.ContainsPoint start.*/
            /**
             * Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
             efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x    
             * @param   {number}                         y
             * @return  {Spine.BoundingBoxAttachment}
             */
            ContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint", this ); }

                var $t;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.ContainsPoint$1(polygons.Items[i], x, y)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.ContainsPoint end.*/

            /*Spine.SkeletonBounds.IntersectsSegment start.*/
            /**
             * Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
             more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x1    
             * @param   {number}                         y1    
             * @param   {number}                         x2    
             * @param   {number}                         y2
             * @return  {Spine.BoundingBoxAttachment}
             */
            IntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment", this ); }

                var $t;
                var polygons = this.Polygons;
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.IntersectsSegment$1(polygons.Items[i], x1, y1, x2, y2)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.IntersectsSegment end.*/

            /*Spine.SkeletonBounds.IntersectsSegment$1 start.*/
            /**
             * Returns true if the polygon contains the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x1         
             * @param   {number}           y1         
             * @param   {number}           x2         
             * @param   {number}           y2
             * @return  {boolean}
             */
            IntersectsSegment$1: function (polygon, x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var width12 = x1 - x2, height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x3 = vertices[((nn - 2) | 0)], y3 = vertices[((nn - 1) | 0)];
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var x4 = vertices[ii], y4 = vertices[((ii + 1) | 0)];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4, height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;
                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
                        var y = (det1 * height34 - height12 * det2) / det3;
                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) {
                            return true;
                        }
                    }
                    x3 = x4;
                    y3 = y4;
                }
                return false;
            },
            /*Spine.SkeletonBounds.IntersectsSegment$1 end.*/

            /*Spine.SkeletonBounds.GetPolygon start.*/
            GetPolygon: function (attachment) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#GetPolygon", this ); }

                var $t;
                var index = this.BoundingBoxes.IndexOf(attachment);
                return index === -1 ? null : ($t = this.Polygons.Items)[index];
            },
            /*Spine.SkeletonBounds.GetPolygon end.*/


        },
        overloads: {
            "ContainsPoint(Polygon, float, float)": "ContainsPoint$1",
            "IntersectsSegment(Polygon, float, float, float, float)": "IntersectsSegment$1"
        }
    });
    /*Spine.SkeletonBounds end.*/

    /*Spine.SkeletonClipping start.*/
    Bridge.define("Spine.SkeletonClipping", {
        statics: {
            methods: {
                /*Spine.SkeletonClipping.MakeClockwise:static start.*/
                MakeClockwise: function (polygon) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#MakeClockwise", this ); }

                    var vertices = polygon.Items;
                    var verticeslength = polygon.Count;

                    var area = vertices[((verticeslength - 2) | 0)] * vertices[1] - vertices[0] * vertices[((verticeslength - 1) | 0)], p1x, p1y, p2x, p2y;
                    for (var i = 0, n = (verticeslength - 3) | 0; i < n; i = (i + 2) | 0) {
                        p1x = vertices[i];
                        p1y = vertices[((i + 1) | 0)];
                        p2x = vertices[((i + 2) | 0)];
                        p2y = vertices[((i + 3) | 0)];
                        area += p1x * p2y - p2x * p1y;
                    }
                    if (area < 0) {
                        return;
                    }

                    for (var i1 = 0, lastX = (verticeslength - 2) | 0, n1 = verticeslength >> 1; i1 < n1; i1 = (i1 + 2) | 0) {
                        var x = vertices[i1], y = vertices[((i1 + 1) | 0)];
                        var other = (lastX - i1) | 0;
                        vertices[i1] = vertices[other];
                        vertices[((i1 + 1) | 0)] = vertices[((other + 1) | 0)];
                        vertices[other] = x;
                        vertices[((other + 1) | 0)] = y;
                    }
                },
                /*Spine.SkeletonClipping.MakeClockwise:static end.*/


            }
        },
        fields: {
            triangulator: null,
            clippingPolygon: null,
            clipOutput: null,
            clippedVertices: null,
            clippedTriangles: null,
            clippedUVs: null,
            scratch: null,
            clipAttachment: null,
            clippingPolygons: null
        },
        props: {
            ClippedVertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedVertices#get", this ); }

                    return this.clippedVertices;
                }
            },
            ClippedTriangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedTriangles#get", this ); }

                    return this.clippedTriangles;
                }
            },
            ClippedUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedUVs#get", this ); }

                    return this.clippedUVs;
                }
            },
            IsClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#IsClipping#get", this ); }

                    return this.clipAttachment != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#init", this ); }

                this.triangulator = new Spine.Triangulator();
                this.clippingPolygon = new (Spine.ExposedList$1(System.Single)).ctor();
                this.clipOutput = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedVertices = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedTriangles = new (Spine.ExposedList$1(System.Int32)).$ctor3(128);
                this.clippedUVs = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.scratch = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonClipping.ClipStart start.*/
            ClipStart: function (slot, clip) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipStart", this ); }

                var $t;
                if (this.clipAttachment != null) {
                    return 0;
                }
                this.clipAttachment = clip;

                var n = clip.worldVerticesLength;
                var vertices = this.clippingPolygon.Resize(n).Items;
                clip.ComputeWorldVertices(slot, 0, n, vertices, 0, 2);
                Spine.SkeletonClipping.MakeClockwise(this.clippingPolygon);
                this.clippingPolygons = this.triangulator.Decompose(this.clippingPolygon, this.triangulator.Triangulate(this.clippingPolygon));
                $t = Bridge.getEnumerator(this.clippingPolygons);
                try {
                    while ($t.moveNext()) {
                        var polygon = $t.Current;
                        Spine.SkeletonClipping.MakeClockwise(polygon);
                        polygon.Add(polygon.Items[0]);
                        polygon.Add(polygon.Items[1]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return this.clippingPolygons.Count;
            },
            /*Spine.SkeletonClipping.ClipStart end.*/

            /*Spine.SkeletonClipping.ClipEnd$1 start.*/
            ClipEnd$1: function (slot) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd$1", this ); }

                if (this.clipAttachment != null && Bridge.referenceEquals(this.clipAttachment.endSlot, slot.data)) {
                    this.ClipEnd();
                }
            },
            /*Spine.SkeletonClipping.ClipEnd$1 end.*/

            /*Spine.SkeletonClipping.ClipEnd start.*/
            ClipEnd: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd", this ); }

                if (this.clipAttachment == null) {
                    return;
                }
                this.clipAttachment = null;
                this.clippingPolygons = null;
                this.clippedVertices.Clear();
                this.clippedTriangles.Clear();
                this.clippingPolygon.Clear();
            },
            /*Spine.SkeletonClipping.ClipEnd end.*/

            /*Spine.SkeletonClipping.ClipTriangles start.*/
            ClipTriangles: function (vertices, verticesLength, triangles, trianglesLength, uvs) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipTriangles", this ); }

                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons.Items;
                var polygonsCount = this.clippingPolygons.Count;

                var index = 0;
                clippedVertices.Clear();
                this.clippedUVs.Clear();
                clippedTriangles.Clear();
                //outer:
                for (var i = 0; i < trianglesLength; i = (i + 3) | 0) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset], y1 = vertices[((vertexOffset + 1) | 0)];
                    var u1 = uvs[vertexOffset], v1 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 1) | 0)] << 1;
                    var x2 = vertices[vertexOffset], y2 = vertices[((vertexOffset + 1) | 0)];
                    var u2 = uvs[vertexOffset], v2 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 2) | 0)] << 1;
                    var x3 = vertices[vertexOffset], y3 = vertices[((vertexOffset + 1) | 0)];
                    var u3 = uvs[vertexOffset], v3 = uvs[((vertexOffset + 1) | 0)];

                    for (var p = 0; p < polygonsCount; p = (p + 1) | 0) {
                        var s = clippedVertices.Count;
                        if (this.Clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.Count;
                            if (clipOutputLength === 0) {
                                continue;
                            }
                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));

                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = clipOutput.Items;
                            var clippedVerticesItems = clippedVertices.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            var clippedUVsItems = this.clippedUVs.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            for (var ii = 0; ii < clipOutputLength; ii = (ii + 2) | 0) {
                                var x = clipOutputItems[ii], y = clipOutputItems[((ii + 1) | 0)];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[((s + 1) | 0)] = y;
                                var c0 = x - x3, c1 = y - y3;
                                var a = (d0 * c0 + d1 * c1) * d;
                                var b = (d4 * c0 + d2 * c1) * d;
                                var c = 1 - a - b;
                                clippedUVsItems[s] = u1 * a + u2 * b + u3 * c;
                                clippedUVsItems[((s + 1) | 0)] = v1 * a + v2 * b + v3 * c;
                                s = (s + 2) | 0;
                            }

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems = clippedTriangles.Resize(((s + Bridge.Int.mul(3, (((clipOutputCount - 2) | 0)))) | 0)).Items;
                            clipOutputCount = (clipOutputCount - 1) | 0;
                            for (var ii1 = 1; ii1 < clipOutputCount; ii1 = (ii1 + 1) | 0) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[((s + 1) | 0)] = (index + ii1) | 0;
                                clippedTrianglesItems[((s + 2) | 0)] = (((index + ii1) | 0) + 1) | 0;
                                s = (s + 3) | 0;
                            }
                            index = (index + (((clipOutputCount + 1) | 0))) | 0;
                        } else {
                            var clippedVerticesItems1 = clippedVertices.Resize(((s + 6) | 0)).Items;
                            var clippedUVsItems1 = this.clippedUVs.Resize(((s + 6) | 0)).Items;
                            clippedVerticesItems1[s] = x1;
                            clippedVerticesItems1[((s + 1) | 0)] = y1;
                            clippedVerticesItems1[((s + 2) | 0)] = x2;
                            clippedVerticesItems1[((s + 3) | 0)] = y2;
                            clippedVerticesItems1[((s + 4) | 0)] = x3;
                            clippedVerticesItems1[((s + 5) | 0)] = y3;

                            clippedUVsItems1[s] = u1;
                            clippedUVsItems1[((s + 1) | 0)] = v1;
                            clippedUVsItems1[((s + 2) | 0)] = u2;
                            clippedUVsItems1[((s + 3) | 0)] = v2;
                            clippedUVsItems1[((s + 4) | 0)] = u3;
                            clippedUVsItems1[((s + 5) | 0)] = v3;

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems1 = clippedTriangles.Resize(((s + 3) | 0)).Items;
                            clippedTrianglesItems1[s] = index;
                            clippedTrianglesItems1[((s + 1) | 0)] = (index + 1) | 0;
                            clippedTrianglesItems1[((s + 2) | 0)] = (index + 2) | 0;
                            index = (index + 3) | 0;
                            break; //continue outer;
                        }
                    }
                }

            },
            /*Spine.SkeletonClipping.ClipTriangles end.*/

            /*Spine.SkeletonClipping.Clip start.*/
            Clip: function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#Clip", this ); }

                var originalOutput = output;
                var clipped = false;

                // Avoid copy at the end.
                var input = null;
                if (clippingArea.Count % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                } else {
                    input = this.scratch;
                }

                input.Clear();
                input.Add(x1);
                input.Add(y1);
                input.Add(x2);
                input.Add(y2);
                input.Add(x3);
                input.Add(y3);
                input.Add(x1);
                input.Add(y1);
                output.Clear();

                var clippingVertices = clippingArea.Items;
                var clippingVerticesLast = (clippingArea.Count - 4) | 0;
                for (var i = 0; ; i = (i + 2) | 0) {
                    var edgeX = clippingVertices[i], edgeY = clippingVertices[((i + 1) | 0)];
                    var edgeX2 = clippingVertices[((i + 2) | 0)], edgeY2 = clippingVertices[((i + 3) | 0)];
                    var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;

                    var inputVertices = input.Items;
                    var inputVerticesLength = (input.Count - 2) | 0, outputStart = output.Count;
                    for (var ii = 0; ii < inputVerticesLength; ii = (ii + 2) | 0) {
                        var inputX = inputVertices[ii], inputY = inputVertices[((ii + 1) | 0)];
                        var inputX2 = inputVertices[((ii + 2) | 0)], inputY2 = inputVertices[((ii + 3) | 0)];
                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
                            if (side2) { // v1 inside, v2 inside
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                            // v1 inside, v2 outside
                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
                            var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);
                            if (Math.abs(s) > 1E-06) {
                                var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                        } else if (side2) { // v1 outside, v2 inside
                            var c01 = inputY2 - inputY, c21 = inputX2 - inputX;
                            var s1 = c01 * (edgeX2 - edgeX) - c21 * (edgeY2 - edgeY);
                            if (Math.abs(s1) > 1E-06) {
                                var ua1 = (c21 * (edgeY - inputY) - c01 * (edgeX - inputX)) / s1;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua1);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua1);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                            output.Add(inputX2);
                            output.Add(inputY2);
                        }
                        clipped = true;
                    }

                    if (outputStart === output.Count) { // All edges outside.
                        originalOutput.Clear();
                        return true;
                    }

                    output.Add(output.Items[0]);
                    output.Add(output.Items[1]);

                    if (i === clippingVerticesLast) {
                        break;
                    }
                    var temp = output;
                    output = input;
                    output.Clear();
                    input = temp;
                }

                if (!Bridge.referenceEquals(originalOutput, output)) {
                    originalOutput.Clear();
                    for (var i1 = 0, n = (output.Count - 2) | 0; i1 < n; i1 = (i1 + 1) | 0) {
                        originalOutput.Add(output.Items[i1]);
                    }
                } else {
                    originalOutput.Resize(((originalOutput.Count - 2) | 0));
                }

                return clipped;
            },
            /*Spine.SkeletonClipping.Clip end.*/


        },
        overloads: {
            "ClipEnd(Slot)": "ClipEnd$1"
        }
    });
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    /**
     * Stores the setup pose and all of the stateless data for a skeleton.
     *
     * @public
     * @class Spine.SkeletonData
     */
    Bridge.define("Spine.SkeletonData", {
        fields: {
            name: null,
            bones: null,
            slots: null,
            skins: null,
            defaultSkin: null,
            events: null,
            animations: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            version: null,
            hash: null,
            fps: 0,
            imagesPath: null,
            audioPath: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#get", this ); }

                    return this.name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#set", this ); }

                    this.name = value;
                }
            },
            /**
             * The skeleton's bones, sorted parent first. The root bone is always the first bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SkeletonData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Slots#get", this ); }

                    return this.slots;
                }
            },
            /**
             * All skins, including the default skin.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Skins
             * @type Spine.ExposedList$1
             */
            Skins: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#get", this ); }

                    return this.skins;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#set", this ); }

                    this.skins = value;
                }
            },
            /**
             * The skeleton's default skin.
             By default this skin contains all attachments that were not in a skin in Spine.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function DefaultSkin
             * @type Spine.Skin
             */
            DefaultSkin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#get", this ); }

                    return this.defaultSkin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#set", this ); }

                    this.defaultSkin = value;
                }
            },
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#set", this ); }

                    this.events = value;
                }
            },
            Animations: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#get", this ); }

                    return this.animations;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#set", this ); }

                    this.animations = value;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#get", this ); }

                    return this.ikConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#set", this ); }

                    this.ikConstraints = value;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#set", this ); }

                    this.transformConstraints = value;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#get", this ); }

                    return this.pathConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#set", this ); }

                    this.pathConstraints = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#set", this ); }

                    this.y = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#set", this ); }

                    this.height = value;
                }
            },
            /**
             * The Spine version used to export this data, or null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Version
             * @type string
             */
            Version: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#get", this ); }

                    return this.version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#set", this ); }

                    this.version = value;
                }
            },
            Hash: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#get", this ); }

                    return this.hash;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#set", this ); }

                    this.hash = value;
                }
            },
            /**
             * The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function ImagesPath
             * @type string
             */
            ImagesPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#get", this ); }

                    return this.imagesPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#set", this ); }

                    this.imagesPath = value;
                }
            },
            /**
             * The path to the audio directory defined in Spine. Available only when nonessential data was exported. May be null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function AudioPath
             * @type string
             */
            AudioPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#get", this ); }

                    return this.audioPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#set", this ); }

                    this.audioPath = value;
                }
            },
            /**
             * The dopesheet FPS in Spine. Available only when nonessential data was exported.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Fps
             * @type number
             */
            Fps: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#get", this ); }

                    return this.fps;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#set", this ); }

                    this.fps = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.slots = new (Spine.ExposedList$1(Spine.SlotData)).ctor();
                this.skins = new (Spine.ExposedList$1(Spine.Skin)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.EventData)).ctor();
                this.animations = new (Spine.ExposedList$1(Spine.Animation)).ctor();
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraintData)).ctor();
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraintData)).ctor();
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraintData)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonData.FindBone start.*/
            /**
             * Finds a bone by comparing each bone's name.
             It is more efficient to cache the results of this method than to call it multiple times.
             *
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            boneName
             * @return  {Spine.BoneData}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (Bridge.referenceEquals(bone.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindBone end.*/

            /*Spine.SkeletonData.FindBoneIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    boneName
             * @return  {number}                -1 if the bone was not found.
             */
            FindBoneIndex: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBoneIndex", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones;
                var bonesItems = bones.Items;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(bonesItems[i].name, boneName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindBoneIndex end.*/

            /*Spine.SkeletonData.FindSlot start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            slotName
             * @return  {Spine.SlotData}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots.Items[i];
                    if (Bridge.referenceEquals(slot.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSlot end.*/

            /*Spine.SkeletonData.FindSlotIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    slotName
             * @return  {number}                -1 if the slot was not found.
             */
            FindSlotIndex: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlotIndex", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots;
                for (var i = 0, n = slots.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(slots.Items[i].name, slotName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindSlotIndex end.*/

            /*Spine.SkeletonData.FindSkin start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}        skinName
             * @return  {Spine.Skin}                May be null.
             */
            FindSkin: function (skinName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSkin", this ); }

                var $t;
                if (skinName == null) {
                    throw new System.ArgumentNullException.$ctor3("skinName", "skinName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.skins);
                try {
                    while ($t.moveNext()) {
                        var skin = $t.Current;
                        if (Bridge.referenceEquals(skin.name, skinName)) {
                            return skin;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSkin end.*/

            /*Spine.SkeletonData.FindEvent start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             eventDataName
             * @return  {Spine.EventData}                     May be null.
             */
            FindEvent: function (eventDataName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindEvent", this ); }

                var $t;
                if (eventDataName == null) {
                    throw new System.ArgumentNullException.$ctor3("eventDataName", "eventDataName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var eventData = $t.Current;
                        if (Bridge.referenceEquals(eventData.name, eventDataName)) {
                            return eventData;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindEvent end.*/

            /*Spine.SkeletonData.FindAnimation start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             animationName
             * @return  {Spine.Animation}                     May be null.
             */
            FindAnimation: function (animationName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindAnimation", this ); }

                if (animationName == null) {
                    throw new System.ArgumentNullException.$ctor3("animationName", "animationName cannot be null.");
                }
                var animations = this.animations;
                for (var i = 0, n = animations.Count; i < n; i = (i + 1) | 0) {
                    var animation = animations.Items[i];
                    if (Bridge.referenceEquals(animation.name, animationName)) {
                        return animation;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindAnimation end.*/

            /*Spine.SkeletonData.FindIkConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                    constraintName
             * @return  {Spine.IkConstraintData}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints.Items[i];
                    if (Bridge.referenceEquals(ikConstraint.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindIkConstraint end.*/

            /*Spine.SkeletonData.FindTransformConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                           constraintName
             * @return  {Spine.TransformConstraintData}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints.Items[i];
                    if (Bridge.referenceEquals(transformConstraint.name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindTransformConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                      constraintName
             * @return  {Spine.PathConstraintData}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints.Items[i];
                    if (System.String.equals(constraint.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindPathConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraintIndex start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}    pathConstraintName
             * @return  {number}                          -1 if the path constraint was not found.
             */
            FindPathConstraintIndex: function (pathConstraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraintIndex", this ); }

                if (pathConstraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("pathConstraintName", "pathConstraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    if (System.String.equals(pathConstraints.Items[i].name, pathConstraintName)) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.SkeletonData.FindPathConstraintIndex end.*/

            /*Spine.SkeletonData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#toString", this ); }

                var $t;
                return ($t = this.name, $t != null ? $t : Bridge.toString(this));
            },
            /*Spine.SkeletonData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    Bridge.define("Spine.SkeletonJson", {
        statics: {
            methods: {
                /*Spine.SkeletonJson.ReadCurve:static start.*/
                ReadCurve: function (valueMap, timeline, frameIndex) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadCurve", this ); }

                    if (!valueMap.containsKey("curve")) {
                        return;
                    }
                    var curveObject = valueMap.getItem("curve");
                    if (Bridge.is(curveObject, System.String)) {
                        timeline.SetStepped(frameIndex);
                    } else {
                        timeline.SetCurve(frameIndex, System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveObject, System.Single), System.Single)), Spine.SkeletonJson.GetFloat(valueMap, "c2", 0), Spine.SkeletonJson.GetFloat(valueMap, "c3", 1), Spine.SkeletonJson.GetFloat(valueMap, "c4", 1));
                    }
                },
                /*Spine.SkeletonJson.ReadCurve:static end.*/

                /*Spine.SkeletonJson.GetFloatArray:static start.*/
                GetFloatArray: function (map, name, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloatArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Single);
                    if (scale === 1) {
                        for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                            values[i] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single));
                        }
                    } else {
                        for (var i1 = 0, n1 = list.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                            values[i1] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i1), System.Single), System.Single)) * scale;
                        }
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetFloatArray:static end.*/

                /*Spine.SkeletonJson.GetIntArray:static start.*/
                GetIntArray: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetIntArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Int32);
                    for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                        values[i] = Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single)));
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetIntArray:static end.*/

                /*Spine.SkeletonJson.GetFloat:static start.*/
                GetFloat: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloat", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single));
                },
                /*Spine.SkeletonJson.GetFloat:static end.*/

                /*Spine.SkeletonJson.GetInt:static start.*/
                GetInt: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt:static end.*/

                /*Spine.SkeletonJson.GetBoolean:static start.*/
                GetBoolean: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetBoolean", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Boolean), System.Boolean));
                },
                /*Spine.SkeletonJson.GetBoolean:static end.*/

                /*Spine.SkeletonJson.GetString:static start.*/
                GetString: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetString", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.cast(map.getItem(name), System.String);
                },
                /*Spine.SkeletonJson.GetString:static end.*/

                /*Spine.SkeletonJson.ToColor:static start.*/
                ToColor: function (hexString, colorIndex, expectedLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ToColor", this ); }

                    if (expectedLength === void 0) { expectedLength = 8; }
                    if (hexString.length !== expectedLength) {
                        throw new System.ArgumentException.$ctor3("Color hexidecimal length must be " + expectedLength + ", recieved: " + (hexString || ""), "hexString");
                    }
                    return System.Convert.toNumberInBase(hexString.substr(Bridge.Int.mul(colorIndex, 2), 2), 16, 9) / 255.0;
                },
                /*Spine.SkeletonJson.ToColor:static end.*/


            }
        },
        fields: {
            Scale: 0,
            attachmentLoader: null,
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonJson.LinkedMesh)).ctor();
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                Spine.SkeletonJson.$ctor1.call(this, new Spine.AtlasAttachmentLoader(atlasArray));
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentLoader", "attachmentLoader cannot be null.");
                }
                this.attachmentLoader = attachmentLoader;
                this.Scale = 1;
            }
        },
        methods: {
            /*Spine.SkeletonJson.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData$1", this ); }

                var reader = new System.IO.StreamReader.$ctor1(new System.IO.FileStream.$ctor1(path, 3));
                try {
                    var skeletonData = this.ReadSkeletonData(reader);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(reader)) {
                        reader.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonJson.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonJson.ReadSkeletonData start.*/
            ReadSkeletonData: function (reader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16;
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }

                var scale = this.Scale;
                var skeletonData = new Spine.SkeletonData();

                var root = Bridge.as(Spine.Json.Deserialize(reader), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                if (root == null) {
                    throw new System.Exception("Invalid JSON.");
                }

                // Skeleton.
                if (root.containsKey("skeleton")) {
                    var skeletonMap = Bridge.cast(root.getItem("skeleton"), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    skeletonData.hash = Bridge.cast(skeletonMap.getItem("hash"), System.String);
                    skeletonData.version = Bridge.cast(skeletonMap.getItem("spine"), System.String);
                    if (Bridge.referenceEquals("3.8.75", skeletonData.version)) {
                        throw new System.Exception("Unsupported skeleton data, please export with a newer version of Spine.");
                    }
                    skeletonData.x = Spine.SkeletonJson.GetFloat(skeletonMap, "x", 0);
                    skeletonData.y = Spine.SkeletonJson.GetFloat(skeletonMap, "y", 0);
                    skeletonData.width = Spine.SkeletonJson.GetFloat(skeletonMap, "width", 0);
                    skeletonData.height = Spine.SkeletonJson.GetFloat(skeletonMap, "height", 0);
                    skeletonData.fps = Spine.SkeletonJson.GetFloat(skeletonMap, "fps", 30);
                    skeletonData.imagesPath = Spine.SkeletonJson.GetString(skeletonMap, "images", null);
                    skeletonData.audioPath = Spine.SkeletonJson.GetString(skeletonMap, "audio", null);
                }

                // Bones.
                if (root.containsKey("bones")) {
                    $t = Bridge.getEnumerator(Bridge.cast(root.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var boneMap = Bridge.cast($t.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var parent = null;
                            if (boneMap.containsKey("parent")) {
                                parent = skeletonData.FindBone(Bridge.cast(boneMap.getItem("parent"), System.String));
                                if (parent == null) {
                                    throw new System.Exception(System.String.concat("Parent bone not found: ", boneMap.getItem("parent")));
                                }
                            }
                            var data = new Spine.BoneData(skeletonData.Bones.Count, Bridge.cast(boneMap.getItem("name"), System.String), parent);
                            data.length = Spine.SkeletonJson.GetFloat(boneMap, "length", 0) * scale;
                            data.x = Spine.SkeletonJson.GetFloat(boneMap, "x", 0) * scale;
                            data.y = Spine.SkeletonJson.GetFloat(boneMap, "y", 0) * scale;
                            data.rotation = Spine.SkeletonJson.GetFloat(boneMap, "rotation", 0);
                            data.scaleX = Spine.SkeletonJson.GetFloat(boneMap, "scaleX", 1);
                            data.scaleY = Spine.SkeletonJson.GetFloat(boneMap, "scaleY", 1);
                            data.shearX = Spine.SkeletonJson.GetFloat(boneMap, "shearX", 0);
                            data.shearY = Spine.SkeletonJson.GetFloat(boneMap, "shearY", 0);

                            var tm = Spine.SkeletonJson.GetString(boneMap, "transform", System.Enum.toString(Spine.TransformMode, Spine.TransformMode.Normal));
                            data.transformMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TransformMode, tm, true), Spine.TransformMode), System.Int32));
                            data.skinRequired = Spine.SkeletonJson.GetBoolean(boneMap, "skin", false);

                            skeletonData.bones.Add(data);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Slots.
                if (root.containsKey("slots")) {
                    $t1 = Bridge.getEnumerator(Bridge.cast(root.getItem("slots"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t1.moveNext()) {
                            var slotMap = Bridge.cast($t1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var slotName = Bridge.cast(slotMap.getItem("name"), System.String);
                            var boneName = Bridge.cast(slotMap.getItem("bone"), System.String);
                            var boneData = skeletonData.FindBone(boneName);
                            if (boneData == null) {
                                throw new System.Exception("Slot bone not found: " + (boneName || ""));
                            }
                            var data1 = new Spine.SlotData(skeletonData.Slots.Count, slotName, boneData);

                            if (slotMap.containsKey("color")) {
                                var color = Bridge.cast(slotMap.getItem("color"), System.String);
                                data1.r = Spine.SkeletonJson.ToColor(color, 0);
                                data1.g = Spine.SkeletonJson.ToColor(color, 1);
                                data1.b = Spine.SkeletonJson.ToColor(color, 2);
                                data1.a = Spine.SkeletonJson.ToColor(color, 3);
                            }

                            if (slotMap.containsKey("dark")) {
                                var color2 = Bridge.cast(slotMap.getItem("dark"), System.String);
                                data1.r2 = Spine.SkeletonJson.ToColor(color2, 0, 6); // expectedLength = 6. ie. "RRGGBB"
                                data1.g2 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                data1.b2 = Spine.SkeletonJson.ToColor(color2, 2, 6);
                                data1.hasSecondColor = true;
                            }

                            data1.attachmentName = Spine.SkeletonJson.GetString(slotMap, "attachment", null);
                            if (slotMap.containsKey("blend")) {
                                data1.blendMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.BlendMode, Bridge.cast(slotMap.getItem("blend"), System.String), true), Spine.BlendMode), System.Int32));
                            } else {
                                data1.blendMode = Spine.BlendMode.Normal;
                            }
                            skeletonData.slots.Add(data1);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraints.
                if (root.containsKey("ik")) {
                    $t2 = Bridge.getEnumerator(Bridge.cast(root.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t2.moveNext()) {
                            var constraintMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data2 = new Spine.IkConstraintData(Bridge.cast(constraintMap.getItem("name"), System.String));
                            data2.order = Spine.SkeletonJson.GetInt(constraintMap, "order", 0);
                            data2.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap, "skin", false);

                            if (constraintMap.containsKey("bones")) {
                                $t3 = Bridge.getEnumerator(Bridge.cast(constraintMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t3.moveNext()) {
                                        var boneName1 = Bridge.cast($t3.Current, System.String);
                                        var bone = skeletonData.FindBone(boneName1);
                                        if (bone == null) {
                                            throw new System.Exception("IK bone not found: " + (boneName1 || ""));
                                        }
                                        data2.bones.Add(bone);
                                    }
                                } finally {
                                    if (Bridge.is($t3, System.IDisposable)) {
                                        $t3.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName = Bridge.cast(constraintMap.getItem("target"), System.String);
                            data2.target = skeletonData.FindBone(targetName);
                            if (data2.target == null) {
                                throw new System.Exception("IK target bone not found: " + (targetName || ""));
                            }
                            data2.mix = Spine.SkeletonJson.GetFloat(constraintMap, "mix", 1);
                            data2.softness = Spine.SkeletonJson.GetFloat(constraintMap, "softness", 0) * scale;
                            data2.bendDirection = Spine.SkeletonJson.GetBoolean(constraintMap, "bendPositive", true) ? 1 : -1;
                            data2.compress = Spine.SkeletonJson.GetBoolean(constraintMap, "compress", false);
                            data2.stretch = Spine.SkeletonJson.GetBoolean(constraintMap, "stretch", false);
                            data2.uniform = Spine.SkeletonJson.GetBoolean(constraintMap, "uniform", false);

                            skeletonData.ikConstraints.Add(data2);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraints.
                if (root.containsKey("transform")) {
                    $t4 = Bridge.getEnumerator(Bridge.cast(root.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t4.moveNext()) {
                            var constraintMap1 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data3 = new Spine.TransformConstraintData(Bridge.cast(constraintMap1.getItem("name"), System.String));
                            data3.order = Spine.SkeletonJson.GetInt(constraintMap1, "order", 0);
                            data3.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap1, "skin", false);

                            if (constraintMap1.containsKey("bones")) {
                                $t5 = Bridge.getEnumerator(Bridge.cast(constraintMap1.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t5.moveNext()) {
                                        var boneName2 = Bridge.cast($t5.Current, System.String);
                                        var bone1 = skeletonData.FindBone(boneName2);
                                        if (bone1 == null) {
                                            throw new System.Exception("Transform constraint bone not found: " + (boneName2 || ""));
                                        }
                                        data3.bones.Add(bone1);
                                    }
                                } finally {
                                    if (Bridge.is($t5, System.IDisposable)) {
                                        $t5.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName1 = Bridge.cast(constraintMap1.getItem("target"), System.String);
                            data3.target = skeletonData.FindBone(targetName1);
                            if (data3.target == null) {
                                throw new System.Exception("Transform constraint target bone not found: " + (targetName1 || ""));
                            }

                            data3.local = Spine.SkeletonJson.GetBoolean(constraintMap1, "local", false);
                            data3.relative = Spine.SkeletonJson.GetBoolean(constraintMap1, "relative", false);

                            data3.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap1, "rotation", 0);
                            data3.offsetX = Spine.SkeletonJson.GetFloat(constraintMap1, "x", 0) * scale;
                            data3.offsetY = Spine.SkeletonJson.GetFloat(constraintMap1, "y", 0) * scale;
                            data3.offsetScaleX = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleX", 0);
                            data3.offsetScaleY = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleY", 0);
                            data3.offsetShearY = Spine.SkeletonJson.GetFloat(constraintMap1, "shearY", 0);

                            data3.rotateMix = Spine.SkeletonJson.GetFloat(constraintMap1, "rotateMix", 1);
                            data3.translateMix = Spine.SkeletonJson.GetFloat(constraintMap1, "translateMix", 1);
                            data3.scaleMix = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleMix", 1);
                            data3.shearMix = Spine.SkeletonJson.GetFloat(constraintMap1, "shearMix", 1);

                            skeletonData.transformConstraints.Add(data3);
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraints.
                if (root.containsKey("path")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(root.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var constraintMap2 = Bridge.cast($t6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data4 = new Spine.PathConstraintData(Bridge.cast(constraintMap2.getItem("name"), System.String));
                            data4.order = Spine.SkeletonJson.GetInt(constraintMap2, "order", 0);
                            data4.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap2, "skin", false);

                            if (constraintMap2.containsKey("bones")) {
                                $t7 = Bridge.getEnumerator(Bridge.cast(constraintMap2.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t7.moveNext()) {
                                        var boneName3 = Bridge.cast($t7.Current, System.String);
                                        var bone2 = skeletonData.FindBone(boneName3);
                                        if (bone2 == null) {
                                            throw new System.Exception("Path bone not found: " + (boneName3 || ""));
                                        }
                                        data4.bones.Add(bone2);
                                    }
                                } finally {
                                    if (Bridge.is($t7, System.IDisposable)) {
                                        $t7.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName2 = Bridge.cast(constraintMap2.getItem("target"), System.String);
                            data4.target = skeletonData.FindSlot(targetName2);
                            if (data4.target == null) {
                                throw new System.Exception("Path target slot not found: " + (targetName2 || ""));
                            }

                            data4.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.PositionMode, Spine.SkeletonJson.GetString(constraintMap2, "positionMode", "percent"), true), Spine.PositionMode), System.Int32));
                            data4.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SpacingMode, Spine.SkeletonJson.GetString(constraintMap2, "spacingMode", "length"), true), Spine.SpacingMode), System.Int32));
                            data4.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.RotateMode, Spine.SkeletonJson.GetString(constraintMap2, "rotateMode", "tangent"), true), Spine.RotateMode), System.Int32));
                            data4.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap2, "rotation", 0);
                            data4.position = Spine.SkeletonJson.GetFloat(constraintMap2, "position", 0);
                            if (data4.positionMode === Spine.PositionMode.Fixed) {
                                data4.position *= scale;
                            }
                            data4.spacing = Spine.SkeletonJson.GetFloat(constraintMap2, "spacing", 0);
                            if (data4.spacingMode === Spine.SpacingMode.Length || data4.spacingMode === Spine.SpacingMode.Fixed) {
                                data4.spacing *= scale;
                            }
                            data4.rotateMix = Spine.SkeletonJson.GetFloat(constraintMap2, "rotateMix", 1);
                            data4.translateMix = Spine.SkeletonJson.GetFloat(constraintMap2, "translateMix", 1);

                            skeletonData.pathConstraints.Add(data4);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }

                // Skins.
                if (root.containsKey("skins")) {
                    $t8 = Bridge.getEnumerator(Bridge.cast(root.getItem("skins"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t8.moveNext()) {
                            var skinMap = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var skin = new Spine.Skin(Bridge.cast(skinMap.getItem("name"), System.String));
                            if (skinMap.containsKey("bones")) {
                                $t9 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t9.moveNext()) {
                                        var entryName = Bridge.cast($t9.Current, System.String);
                                        var bone3 = skeletonData.FindBone(entryName);
                                        if (bone3 == null) {
                                            throw new System.Exception("Skin bone not found: " + (entryName || ""));
                                        }
                                        skin.bones.Add(bone3);
                                    }
                                } finally {
                                    if (Bridge.is($t9, System.IDisposable)) {
                                        $t9.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("ik")) {
                                $t10 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t10.moveNext()) {
                                        var entryName1 = Bridge.cast($t10.Current, System.String);
                                        var constraint = skeletonData.FindIkConstraint(entryName1);
                                        if (constraint == null) {
                                            throw new System.Exception("Skin IK constraint not found: " + (entryName1 || ""));
                                        }
                                        skin.constraints.Add(constraint);
                                    }
                                } finally {
                                    if (Bridge.is($t10, System.IDisposable)) {
                                        $t10.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("transform")) {
                                $t11 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t11.moveNext()) {
                                        var entryName2 = Bridge.cast($t11.Current, System.String);
                                        var constraint1 = skeletonData.FindTransformConstraint(entryName2);
                                        if (constraint1 == null) {
                                            throw new System.Exception("Skin transform constraint not found: " + (entryName2 || ""));
                                        }
                                        skin.constraints.Add(constraint1);
                                    }
                                } finally {
                                    if (Bridge.is($t11, System.IDisposable)) {
                                        $t11.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("path")) {
                                $t12 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t12.moveNext()) {
                                        var entryName3 = Bridge.cast($t12.Current, System.String);
                                        var constraint2 = skeletonData.FindPathConstraint(entryName3);
                                        if (constraint2 == null) {
                                            throw new System.Exception("Skin path constraint not found: " + (entryName3 || ""));
                                        }
                                        skin.constraints.Add(constraint2);
                                    }
                                } finally {
                                    if (Bridge.is($t12, System.IDisposable)) {
                                        $t12.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("attachments")) {
                                $t13 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                try {
                                    while ($t13.moveNext()) {
                                        var slotEntry = $t13.Current;
                                        var slotIndex = skeletonData.FindSlotIndex(slotEntry.key);
                                        $t14 = Bridge.getEnumerator(Bridge.cast(slotEntry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                        try {
                                            while ($t14.moveNext()) {
                                                var entry = $t14.Current;
                                                try {
                                                    var attachment = this.ReadAttachment(Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), skin, slotIndex, entry.key, skeletonData);
                                                    if (attachment != null) {
                                                        skin.SetAttachment(slotIndex, entry.key, attachment);
                                                    }
                                                } catch (e) {
                                                    e = System.Exception.create(e);
                                                    throw new System.Exception(System.String.concat("Error reading attachment: " + (entry.key || "") + ", skin: ", skin), e);
                                                }
                                            }
                                        } finally {
                                            if (Bridge.is($t14, System.IDisposable)) {
                                                $t14.System$IDisposable$Dispose();
                                            }
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t13, System.IDisposable)) {
                                        $t13.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skeletonData.skins.Add(skin);
                            if (Bridge.referenceEquals(skin.name, "default")) {
                                skeletonData.defaultSkin = skin;
                            }
                        }
                    } finally {
                        if (Bridge.is($t8, System.IDisposable)) {
                            $t8.System$IDisposable$Dispose();
                        }
                    }
                }

                // Linked meshes.
                for (var i = 0, n = this.linkedMeshes.Count; i < n; i = (i + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i);
                    var skin1 = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.FindSkin(linkedMesh.skin);
                    if (skin1 == null) {
                        throw new System.Exception("Slot not found: " + (linkedMesh.skin || ""));
                    }
                    var parent1 = skin1.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.DeformAttachment = linkedMesh.inheritDeform ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    linkedMesh.mesh.UpdateUVs();
                }
                this.linkedMeshes.clear();

                // Events.
                if (root.containsKey("events")) {
                    $t15 = Bridge.getEnumerator(Bridge.cast(root.getItem("events"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t15.moveNext()) {
                            var entry1 = $t15.Current;
                            var entryMap = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data5 = new Spine.EventData(entry1.key);
                            data5.Int = Spine.SkeletonJson.GetInt(entryMap, "int", 0);
                            data5.Float = Spine.SkeletonJson.GetFloat(entryMap, "float", 0);
                            data5.String = Spine.SkeletonJson.GetString(entryMap, "string", "");
                            data5.AudioPath = Spine.SkeletonJson.GetString(entryMap, "audio", null);
                            if (data5.AudioPath != null) {
                                data5.Volume = Spine.SkeletonJson.GetFloat(entryMap, "volume", 1);
                                data5.Balance = Spine.SkeletonJson.GetFloat(entryMap, "balance", 0);
                            }
                            skeletonData.events.Add(data5);
                        }
                    } finally {
                        if (Bridge.is($t15, System.IDisposable)) {
                            $t15.System$IDisposable$Dispose();
                        }
                    }
                }

                // Animations.
                if (root.containsKey("animations")) {
                    $t16 = Bridge.getEnumerator(Bridge.cast(root.getItem("animations"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t16.moveNext()) {
                            var entry2 = $t16.Current;
                            try {
                                this.ReadAnimation(Bridge.cast(entry2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), entry2.key, skeletonData);
                            } catch (e1) {
                                e1 = System.Exception.create(e1);
                                throw new System.Exception("Error reading animation: " + (entry2.key || ""), e1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t16, System.IDisposable)) {
                            $t16.System$IDisposable$Dispose();
                        }
                    }
                }

                skeletonData.bones.TrimExcess();
                skeletonData.slots.TrimExcess();
                skeletonData.skins.TrimExcess();
                skeletonData.events.TrimExcess();
                skeletonData.animations.TrimExcess();
                skeletonData.ikConstraints.TrimExcess();
                return skeletonData;
            },
            /*Spine.SkeletonJson.ReadSkeletonData end.*/

            /*Spine.SkeletonJson.ReadAttachment start.*/
            ReadAttachment: function (map, skin, slotIndex, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAttachment", this ); }

                var scale = this.Scale;
                name = Spine.SkeletonJson.GetString(map, "name", name);

                var typeName = Spine.SkeletonJson.GetString(map, "type", "region");
                var type = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.AttachmentType, typeName, true), Spine.AttachmentType), System.Int32));

                var path = Spine.SkeletonJson.GetString(map, "path", name);

                switch (type) {
                    case Spine.AttachmentType.Region: 
                        var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path);
                        if (region == null) {
                            return null;
                        }
                        region.Path = path;
                        region.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                        region.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                        region.scaleX = Spine.SkeletonJson.GetFloat(map, "scaleX", 1);
                        region.scaleY = Spine.SkeletonJson.GetFloat(map, "scaleY", 1);
                        region.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);
                        region.width = Spine.SkeletonJson.GetFloat(map, "width", 32) * scale;
                        region.height = Spine.SkeletonJson.GetFloat(map, "height", 32) * scale;
                        if (map.containsKey("color")) {
                            var color = Bridge.cast(map.getItem("color"), System.String);
                            region.r = Spine.SkeletonJson.ToColor(color, 0);
                            region.g = Spine.SkeletonJson.ToColor(color, 1);
                            region.b = Spine.SkeletonJson.ToColor(color, 2);
                            region.a = Spine.SkeletonJson.ToColor(color, 3);
                        }
                        region.UpdateOffset();
                        return region;
                    case Spine.AttachmentType.Boundingbox: 
                        var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                        if (box == null) {
                            return null;
                        }
                        this.ReadVertices(map, box, Spine.SkeletonJson.GetInt(map, "vertexCount", 0) << 1);
                        return box;
                    case Spine.AttachmentType.Mesh: 
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path;

                            if (map.containsKey("color")) {
                                var color1 = Bridge.cast(map.getItem("color"), System.String);
                                mesh.r = Spine.SkeletonJson.ToColor(color1, 0);
                                mesh.g = Spine.SkeletonJson.ToColor(color1, 1);
                                mesh.b = Spine.SkeletonJson.ToColor(color1, 2);
                                mesh.a = Spine.SkeletonJson.ToColor(color1, 3);
                            }

                            mesh.Width = Spine.SkeletonJson.GetFloat(map, "width", 0) * scale;
                            mesh.Height = Spine.SkeletonJson.GetFloat(map, "height", 0) * scale;

                            var parent = Spine.SkeletonJson.GetString(map, "parent", null);
                            if (parent != null) {
                                this.linkedMeshes.add(new Spine.SkeletonJson.LinkedMesh(mesh, Spine.SkeletonJson.GetString(map, "skin", null), slotIndex, parent, Spine.SkeletonJson.GetBoolean(map, "deform", true)));
                                return mesh;
                            }

                            var uvs = Spine.SkeletonJson.GetFloatArray(map, "uvs", 1);
                            this.ReadVertices(map, mesh, uvs.length);
                            mesh.triangles = Spine.SkeletonJson.GetIntArray(map, "triangles");
                            mesh.regionUVs = uvs;
                            mesh.UpdateUVs();

                            if (map.containsKey("hull")) {
                                mesh.HullLength = Bridge.Int.mul(Spine.SkeletonJson.GetInt(map, "hull", 0), 2);
                            }
                            if (map.containsKey("edges")) {
                                mesh.Edges = Spine.SkeletonJson.GetIntArray(map, "edges");
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var pathAttachment = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (pathAttachment == null) {
                                return null;
                            }
                            pathAttachment.closed = Spine.SkeletonJson.GetBoolean(map, "closed", false);
                            pathAttachment.constantSpeed = Spine.SkeletonJson.GetBoolean(map, "constantSpeed", true);

                            var vertexCount = Spine.SkeletonJson.GetInt(map, "vertexCount", 0);
                            this.ReadVertices(map, pathAttachment, vertexCount << 1);

                            // potential BOZO see Java impl
                            pathAttachment.lengths = Spine.SkeletonJson.GetFloatArray(map, "lengths", scale);
                            return pathAttachment;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                            point.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                            point.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);

                            //string color = GetString(map, "color", null);
                            //if (color != null) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }

                            var end = Spine.SkeletonJson.GetString(map, "end", null);
                            if (end != null) {
                                var slot = skeletonData.FindSlot(end);
                                if (slot == null) {
                                    throw new System.Exception("Clipping end slot not found: " + (end || ""));
                                }
                                clip.EndSlot = slot;
                            }

                            this.ReadVertices(map, clip, Spine.SkeletonJson.GetInt(map, "vertexCount", 0) << 1);

                            //string color = GetString(map, "color", null);
                            // if (color != null) clip.color = color;
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonJson.ReadAttachment end.*/

            /*Spine.SkeletonJson.ReadVertices start.*/
            ReadVertices: function (map, attachment, verticesLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadVertices", this ); }

                attachment.WorldVerticesLength = verticesLength;
                var vertices = Spine.SkeletonJson.GetFloatArray(map, "vertices", 1);
                var scale = this.Scale;
                if (verticesLength === vertices.length) {
                    if (scale !== 1) {
                        for (var i = 0; i < vertices.length; i = (i + 1) | 0) {
                            vertices[i] *= scale;
                        }
                    }
                    attachment.vertices = vertices;
                    return;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bones = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i1 = 0, n = vertices.length; i1 < n; ) {
                    var boneCount = Bridge.Int.clip32(vertices[Bridge.identity(i1, ((i1 = (i1 + 1) | 0)))]);
                    bones.Add(boneCount);
                    for (var nn = (i1 + Bridge.Int.mul(boneCount, 4)) | 0; i1 < nn; i1 = (i1 + 4) | 0) {
                        bones.Add(Bridge.Int.clip32(vertices[i1]));
                        weights.Add(vertices[((i1 + 1) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 2) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 3) | 0)]);
                    }
                }
                attachment.bones = bones.ToArray();
                attachment.vertices = weights.ToArray();
            },
            /*Spine.SkeletonJson.ReadVertices end.*/

            /*Spine.SkeletonJson.ReadAnimation start.*/
            ReadAnimation: function (map, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25;
                var scale = this.Scale;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).ctor();
                var duration = 0;

                // Slot timelines.
                if (map.containsKey("slots")) {
                    $t = Bridge.getEnumerator(Bridge.cast(map.getItem("slots"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            var slotName = entry.key;
                            var slotIndex = skeletonData.FindSlotIndex(slotName);
                            var timelineMap = Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t1 = Bridge.getEnumerator(timelineMap);
                            try {
                                while ($t1.moveNext()) {
                                    var timelineEntry = $t1.Current;
                                    var values = Bridge.cast(timelineEntry.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName = timelineEntry.key;
                                    if (Bridge.referenceEquals(timelineName, "attachment")) {
                                        var timeline = new Spine.AttachmentTimeline(values.Count);
                                        timeline.slotIndex = slotIndex;

                                        var frameIndex = 0;
                                        $t2 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t2.moveNext()) {
                                                var valueMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time = Spine.SkeletonJson.GetFloat(valueMap, "time", 0);
                                                timeline.SetFrame(Bridge.identity(frameIndex, ((frameIndex = (frameIndex + 1) | 0))), time, Bridge.cast(valueMap.getItem("name"), System.String));
                                            }
                                        } finally {
                                            if (Bridge.is($t2, System.IDisposable)) {
                                                $t2.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline);
                                        duration = Math.max(duration, timeline.frames[((timeline.FrameCount - 1) | 0)]);

                                    } else if (Bridge.referenceEquals(timelineName, "color")) {
                                        var timeline1 = new Spine.ColorTimeline(values.Count);
                                        timeline1.slotIndex = slotIndex;

                                        var frameIndex1 = 0;
                                        $t3 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t3.moveNext()) {
                                                var valueMap1 = Bridge.cast($t3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time1 = Spine.SkeletonJson.GetFloat(valueMap1, "time", 0);
                                                var c = Bridge.cast(valueMap1.getItem("color"), System.String);
                                                timeline1.SetFrame(frameIndex1, time1, Spine.SkeletonJson.ToColor(c, 0), Spine.SkeletonJson.ToColor(c, 1), Spine.SkeletonJson.ToColor(c, 2), Spine.SkeletonJson.ToColor(c, 3));
                                                Spine.SkeletonJson.ReadCurve(valueMap1, timeline1, frameIndex1);
                                                frameIndex1 = (frameIndex1 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t3, System.IDisposable)) {
                                                $t3.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline1);
                                        duration = Math.max(duration, timeline1.frames[Bridge.Int.mul((((timeline1.FrameCount - 1) | 0)), Spine.ColorTimeline.ENTRIES)]);

                                    } else if (Bridge.referenceEquals(timelineName, "twoColor")) {
                                        var timeline2 = new Spine.TwoColorTimeline(values.Count);
                                        timeline2.slotIndex = slotIndex;

                                        var frameIndex2 = 0;
                                        $t4 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t4.moveNext()) {
                                                var valueMap2 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time2 = Spine.SkeletonJson.GetFloat(valueMap2, "time", 0);
                                                var light = Bridge.cast(valueMap2.getItem("light"), System.String);
                                                var dark = Bridge.cast(valueMap2.getItem("dark"), System.String);
                                                timeline2.SetFrame(frameIndex2, time2, Spine.SkeletonJson.ToColor(light, 0), Spine.SkeletonJson.ToColor(light, 1), Spine.SkeletonJson.ToColor(light, 2), Spine.SkeletonJson.ToColor(light, 3), Spine.SkeletonJson.ToColor(dark, 0, 6), Spine.SkeletonJson.ToColor(dark, 1, 6), Spine.SkeletonJson.ToColor(dark, 2, 6));
                                                Spine.SkeletonJson.ReadCurve(valueMap2, timeline2, frameIndex2);
                                                frameIndex2 = (frameIndex2 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t4, System.IDisposable)) {
                                                $t4.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline2);
                                        duration = Math.max(duration, timeline2.frames[Bridge.Int.mul((((timeline2.FrameCount - 1) | 0)), Spine.TwoColorTimeline.ENTRIES)]);

                                    } else {
                                        throw new System.Exception("Invalid timeline type for a slot: " + (timelineName || "") + " (" + (slotName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Bone timelines.
                if (map.containsKey("bones")) {
                    $t5 = Bridge.getEnumerator(Bridge.cast(map.getItem("bones"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t5.moveNext()) {
                            var entry1 = $t5.Current;
                            var boneName = entry1.key;
                            var boneIndex = skeletonData.FindBoneIndex(boneName);
                            if (boneIndex === -1) {
                                throw new System.Exception("Bone not found: " + (boneName || ""));
                            }
                            var timelineMap1 = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t6 = Bridge.getEnumerator(timelineMap1);
                            try {
                                while ($t6.moveNext()) {
                                    var timelineEntry1 = $t6.Current;
                                    var values1 = Bridge.cast(timelineEntry1.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName1 = timelineEntry1.key;
                                    if (Bridge.referenceEquals(timelineName1, "rotate")) {
                                        var timeline3 = new Spine.RotateTimeline(values1.Count);
                                        timeline3.boneIndex = boneIndex;

                                        var frameIndex3 = 0;
                                        $t7 = Bridge.getEnumerator(values1);
                                        try {
                                            while ($t7.moveNext()) {
                                                var valueMap3 = Bridge.cast($t7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline3.SetFrame(frameIndex3, Spine.SkeletonJson.GetFloat(valueMap3, "time", 0), Spine.SkeletonJson.GetFloat(valueMap3, "angle", 0));
                                                Spine.SkeletonJson.ReadCurve(valueMap3, timeline3, frameIndex3);
                                                frameIndex3 = (frameIndex3 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t7, System.IDisposable)) {
                                                $t7.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline3);
                                        duration = Math.max(duration, timeline3.frames[Bridge.Int.mul((((timeline3.FrameCount - 1) | 0)), Spine.RotateTimeline.ENTRIES)]);

                                    } else if (Bridge.referenceEquals(timelineName1, "translate") || Bridge.referenceEquals(timelineName1, "scale") || Bridge.referenceEquals(timelineName1, "shear")) {
                                        var timeline4;
                                        var timelineScale = 1, defaultValue = 0;
                                        if (Bridge.referenceEquals(timelineName1, "scale")) {
                                            timeline4 = new Spine.ScaleTimeline(values1.Count);
                                            defaultValue = 1;
                                        } else if (Bridge.referenceEquals(timelineName1, "shear")) {
                                            timeline4 = new Spine.ShearTimeline(values1.Count);
                                        } else {
                                            timeline4 = new Spine.TranslateTimeline(values1.Count);
                                            timelineScale = scale;
                                        }
                                        timeline4.boneIndex = boneIndex;

                                        var frameIndex4 = 0;
                                        $t8 = Bridge.getEnumerator(values1);
                                        try {
                                            while ($t8.moveNext()) {
                                                var valueMap4 = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time3 = Spine.SkeletonJson.GetFloat(valueMap4, "time", 0);
                                                var x = Spine.SkeletonJson.GetFloat(valueMap4, "x", defaultValue);
                                                var y = Spine.SkeletonJson.GetFloat(valueMap4, "y", defaultValue);
                                                timeline4.SetFrame(frameIndex4, time3, x * timelineScale, y * timelineScale);
                                                Spine.SkeletonJson.ReadCurve(valueMap4, timeline4, frameIndex4);
                                                frameIndex4 = (frameIndex4 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t8, System.IDisposable)) {
                                                $t8.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline4);
                                        duration = Math.max(duration, timeline4.frames[Bridge.Int.mul((((timeline4.FrameCount - 1) | 0)), Spine.TranslateTimeline.ENTRIES)]);

                                    } else {
                                        throw new System.Exception("Invalid timeline type for a bone: " + (timelineName1 || "") + " (" + (boneName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t6, System.IDisposable)) {
                                    $t6.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraint timelines.
                if (map.containsKey("ik")) {
                    $t9 = Bridge.getEnumerator(Bridge.cast(map.getItem("ik"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t9.moveNext()) {
                            var constraintMap = $t9.Current;
                            var constraint = skeletonData.FindIkConstraint(constraintMap.key);
                            var values2 = Bridge.cast(constraintMap.value, System.Collections.Generic.List$1(System.Object));
                            var timeline5 = new Spine.IkConstraintTimeline(values2.Count);
                            timeline5.ikConstraintIndex = skeletonData.ikConstraints.IndexOf(constraint);
                            var frameIndex5 = 0;
                            $t10 = Bridge.getEnumerator(values2);
                            try {
                                while ($t10.moveNext()) {
                                    var valueMap5 = Bridge.cast($t10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                    timeline5.SetFrame(frameIndex5, Spine.SkeletonJson.GetFloat(valueMap5, "time", 0), Spine.SkeletonJson.GetFloat(valueMap5, "mix", 1), Spine.SkeletonJson.GetFloat(valueMap5, "softness", 0) * scale, Spine.SkeletonJson.GetBoolean(valueMap5, "bendPositive", true) ? 1 : -1, Spine.SkeletonJson.GetBoolean(valueMap5, "compress", false), Spine.SkeletonJson.GetBoolean(valueMap5, "stretch", false));
                                    Spine.SkeletonJson.ReadCurve(valueMap5, timeline5, frameIndex5);
                                    frameIndex5 = (frameIndex5 + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t10, System.IDisposable)) {
                                    $t10.System$IDisposable$Dispose();
                                }
                            }
                            timelines.Add(timeline5);
                            duration = Math.max(duration, timeline5.frames[Bridge.Int.mul((((timeline5.FrameCount - 1) | 0)), Spine.IkConstraintTimeline.ENTRIES)]);
                        }
                    } finally {
                        if (Bridge.is($t9, System.IDisposable)) {
                            $t9.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraint timelines.
                if (map.containsKey("transform")) {
                    $t11 = Bridge.getEnumerator(Bridge.cast(map.getItem("transform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t11.moveNext()) {
                            var constraintMap1 = $t11.Current;
                            var constraint1 = skeletonData.FindTransformConstraint(constraintMap1.key);
                            var values3 = Bridge.cast(constraintMap1.value, System.Collections.Generic.List$1(System.Object));
                            var timeline6 = new Spine.TransformConstraintTimeline(values3.Count);
                            timeline6.transformConstraintIndex = skeletonData.transformConstraints.IndexOf(constraint1);
                            var frameIndex6 = 0;
                            $t12 = Bridge.getEnumerator(values3);
                            try {
                                while ($t12.moveNext()) {
                                    var valueMap6 = Bridge.cast($t12.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                    timeline6.SetFrame(frameIndex6, Spine.SkeletonJson.GetFloat(valueMap6, "time", 0), Spine.SkeletonJson.GetFloat(valueMap6, "rotateMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "translateMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "scaleMix", 1), Spine.SkeletonJson.GetFloat(valueMap6, "shearMix", 1));
                                    Spine.SkeletonJson.ReadCurve(valueMap6, timeline6, frameIndex6);
                                    frameIndex6 = (frameIndex6 + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t12, System.IDisposable)) {
                                    $t12.System$IDisposable$Dispose();
                                }
                            }
                            timelines.Add(timeline6);
                            duration = Math.max(duration, timeline6.frames[Bridge.Int.mul((((timeline6.FrameCount - 1) | 0)), Spine.TransformConstraintTimeline.ENTRIES)]);
                        }
                    } finally {
                        if (Bridge.is($t11, System.IDisposable)) {
                            $t11.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraint timelines.
                if (map.containsKey("path")) {
                    $t13 = Bridge.getEnumerator(Bridge.cast(map.getItem("path"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t13.moveNext()) {
                            var constraintMap2 = $t13.Current;
                            var index = skeletonData.FindPathConstraintIndex(constraintMap2.key);
                            if (index === -1) {
                                throw new System.Exception("Path constraint not found: " + (constraintMap2.key || ""));
                            }
                            var data = ($t14 = skeletonData.pathConstraints.Items)[index];
                            var timelineMap2 = Bridge.cast(constraintMap2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t15 = Bridge.getEnumerator(timelineMap2);
                            try {
                                while ($t15.moveNext()) {
                                    var timelineEntry2 = $t15.Current;
                                    var values4 = Bridge.cast(timelineEntry2.value, System.Collections.Generic.List$1(System.Object));
                                    var timelineName2 = timelineEntry2.key;
                                    if (Bridge.referenceEquals(timelineName2, "position") || Bridge.referenceEquals(timelineName2, "spacing")) {
                                        var timeline7;
                                        var timelineScale1 = 1;
                                        if (Bridge.referenceEquals(timelineName2, "spacing")) {
                                            timeline7 = new Spine.PathConstraintSpacingTimeline(values4.Count);
                                            if (data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed) {
                                                timelineScale1 = scale;
                                            }
                                        } else {
                                            timeline7 = new Spine.PathConstraintPositionTimeline(values4.Count);
                                            if (data.positionMode === Spine.PositionMode.Fixed) {
                                                timelineScale1 = scale;
                                            }
                                        }
                                        timeline7.pathConstraintIndex = index;
                                        var frameIndex7 = 0;
                                        $t16 = Bridge.getEnumerator(values4);
                                        try {
                                            while ($t16.moveNext()) {
                                                var valueMap7 = Bridge.cast($t16.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline7.SetFrame(frameIndex7, Spine.SkeletonJson.GetFloat(valueMap7, "time", 0), Spine.SkeletonJson.GetFloat(valueMap7, timelineName2, 0) * timelineScale1);
                                                Spine.SkeletonJson.ReadCurve(valueMap7, timeline7, frameIndex7);
                                                frameIndex7 = (frameIndex7 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t16, System.IDisposable)) {
                                                $t16.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline7);
                                        duration = Math.max(duration, timeline7.frames[Bridge.Int.mul((((timeline7.FrameCount - 1) | 0)), Spine.PathConstraintPositionTimeline.ENTRIES)]);
                                    } else if (Bridge.referenceEquals(timelineName2, "mix")) {
                                        var timeline8 = new Spine.PathConstraintMixTimeline(values4.Count);
                                        timeline8.pathConstraintIndex = index;
                                        var frameIndex8 = 0;
                                        $t17 = Bridge.getEnumerator(values4);
                                        try {
                                            while ($t17.moveNext()) {
                                                var valueMap8 = Bridge.cast($t17.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline8.SetFrame(frameIndex8, Spine.SkeletonJson.GetFloat(valueMap8, "time", 0), Spine.SkeletonJson.GetFloat(valueMap8, "rotateMix", 1), Spine.SkeletonJson.GetFloat(valueMap8, "translateMix", 1));
                                                Spine.SkeletonJson.ReadCurve(valueMap8, timeline8, frameIndex8);
                                                frameIndex8 = (frameIndex8 + 1) | 0;
                                            }
                                        } finally {
                                            if (Bridge.is($t17, System.IDisposable)) {
                                                $t17.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline8);
                                        duration = Math.max(duration, timeline8.frames[Bridge.Int.mul((((timeline8.FrameCount - 1) | 0)), Spine.PathConstraintMixTimeline.ENTRIES)]);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t15, System.IDisposable)) {
                                    $t15.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t13, System.IDisposable)) {
                            $t13.System$IDisposable$Dispose();
                        }
                    }
                }

                // Deform timelines.
                if (map.containsKey("deform")) {
                    $t18 = Bridge.getEnumerator(Bridge.cast(map.getItem("deform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t18.moveNext()) {
                            var deformMap = $t18.Current;
                            var skin = skeletonData.FindSkin(deformMap.key);
                            $t19 = Bridge.getEnumerator(Bridge.cast(deformMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                            try {
                                while ($t19.moveNext()) {
                                    var slotMap = $t19.Current;
                                    var slotIndex1 = skeletonData.FindSlotIndex(slotMap.key);
                                    if (slotIndex1 === -1) {
                                        throw new System.Exception("Slot not found: " + (slotMap.key || ""));
                                    }
                                    $t20 = Bridge.getEnumerator(Bridge.cast(slotMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                    try {
                                        while ($t20.moveNext()) {
                                            var timelineMap3 = $t20.Current;
                                            var values5 = Bridge.cast(timelineMap3.value, System.Collections.Generic.List$1(System.Object));
                                            var attachment = Bridge.cast(skin.GetAttachment(slotIndex1, timelineMap3.key), Spine.VertexAttachment);
                                            if (attachment == null) {
                                                throw new System.Exception("Deform attachment not found: " + (timelineMap3.key || ""));
                                            }
                                            var weighted = attachment.bones != null;
                                            var vertices = attachment.vertices;
                                            var deformLength = weighted ? Bridge.Int.mul(((Bridge.Int.div(vertices.length, 3)) | 0), 2) : vertices.length;

                                            var timeline9 = new Spine.DeformTimeline(values5.Count);
                                            timeline9.slotIndex = slotIndex1;
                                            timeline9.attachment = attachment;

                                            var frameIndex9 = 0;
                                            $t21 = Bridge.getEnumerator(values5);
                                            try {
                                                while ($t21.moveNext()) {
                                                    var valueMap9 = Bridge.cast($t21.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var deform;
                                                    if (!valueMap9.containsKey("vertices")) {
                                                        deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                                    } else {
                                                        deform = System.Array.init(deformLength, 0, System.Single);
                                                        var start = Spine.SkeletonJson.GetInt(valueMap9, "offset", 0);
                                                        var verticesValue = Spine.SkeletonJson.GetFloatArray(valueMap9, "vertices", 1);
                                                        System.Array.copy(verticesValue, 0, deform, start, verticesValue.length);
                                                        if (scale !== 1) {
                                                            for (var i = start, n = (i + verticesValue.length) | 0; i < n; i = (i + 1) | 0) {
                                                                deform[i] *= scale;
                                                            }
                                                        }

                                                        if (!weighted) {
                                                            for (var i1 = 0; i1 < deformLength; i1 = (i1 + 1) | 0) {
                                                                deform[i1] += vertices[i1];
                                                            }
                                                        }
                                                    }

                                                    timeline9.SetFrame(frameIndex9, Spine.SkeletonJson.GetFloat(valueMap9, "time", 0), deform);
                                                    Spine.SkeletonJson.ReadCurve(valueMap9, timeline9, frameIndex9);
                                                    frameIndex9 = (frameIndex9 + 1) | 0;
                                                }
                                            } finally {
                                                if (Bridge.is($t21, System.IDisposable)) {
                                                    $t21.System$IDisposable$Dispose();
                                                }
                                            }
                                            timelines.Add(timeline9);
                                            duration = Math.max(duration, timeline9.frames[((timeline9.FrameCount - 1) | 0)]);
                                        }
                                    } finally {
                                        if (Bridge.is($t20, System.IDisposable)) {
                                            $t20.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t19, System.IDisposable)) {
                                    $t19.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t18, System.IDisposable)) {
                            $t18.System$IDisposable$Dispose();
                        }
                    }
                }

                // Draw order timeline.
                if (map.containsKey("drawOrder") || map.containsKey("draworder")) {
                    var values6 = Bridge.cast(map.getItem(map.containsKey("drawOrder") ? "drawOrder" : "draworder"), System.Collections.Generic.List$1(System.Object));
                    var timeline10 = new Spine.DrawOrderTimeline(values6.Count);
                    var slotCount = skeletonData.slots.Count;
                    var frameIndex10 = 0;
                    $t22 = Bridge.getEnumerator(values6);
                    try {
                        while ($t22.moveNext()) {
                            var drawOrderMap = Bridge.cast($t22.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var drawOrder = null;
                            if (drawOrderMap.containsKey("offsets")) {
                                drawOrder = System.Array.init(slotCount, 0, System.Int32);
                                for (var i2 = (slotCount - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                                    drawOrder[i2] = -1;
                                }
                                var offsets = Bridge.cast(drawOrderMap.getItem("offsets"), System.Collections.Generic.List$1(System.Object));
                                var unchanged = System.Array.init(((slotCount - offsets.Count) | 0), 0, System.Int32);
                                var originalIndex = 0, unchangedIndex = 0;
                                $t23 = Bridge.getEnumerator(offsets);
                                try {
                                    while ($t23.moveNext()) {
                                        var offsetMap = Bridge.cast($t23.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var slotIndex2 = skeletonData.FindSlotIndex(Bridge.cast(offsetMap.getItem("slot"), System.String));
                                        if (slotIndex2 === -1) {
                                            throw new System.Exception(System.String.concat("Slot not found: ", offsetMap.getItem("slot")));
                                        }
                                        // Collect unchanged items.
                                        while (originalIndex !== slotIndex2) {
                                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                        }
                                        // Set changed items.
                                        var index1 = (originalIndex + Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(offsetMap.getItem("offset"), System.Single), System.Single)))) | 0;
                                        drawOrder[index1] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                    }
                                } finally {
                                    if (Bridge.is($t23, System.IDisposable)) {
                                        $t23.System$IDisposable$Dispose();
                                    }
                                }
                                // Collect remaining unchanged items.
                                while (originalIndex < slotCount) {
                                    unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                }
                                // Fill in unchanged items.
                                for (var i3 = (slotCount - 1) | 0; i3 >= 0; i3 = (i3 - 1) | 0) {
                                    if (drawOrder[i3] === -1) {
                                        drawOrder[i3] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                                    }
                                }
                            }
                            timeline10.SetFrame(Bridge.identity(frameIndex10, ((frameIndex10 = (frameIndex10 + 1) | 0))), Spine.SkeletonJson.GetFloat(drawOrderMap, "time", 0), drawOrder);
                        }
                    } finally {
                        if (Bridge.is($t22, System.IDisposable)) {
                            $t22.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline10);
                    duration = Math.max(duration, timeline10.frames[((timeline10.FrameCount - 1) | 0)]);
                }

                // Event timeline.
                if (map.containsKey("events")) {
                    var eventsMap = Bridge.cast(map.getItem("events"), System.Collections.Generic.List$1(System.Object));
                    var timeline11 = new Spine.EventTimeline(eventsMap.Count);
                    var frameIndex11 = 0;
                    $t24 = Bridge.getEnumerator(eventsMap);
                    try {
                        while ($t24.moveNext()) {
                            var eventMap = Bridge.cast($t24.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var eventData = skeletonData.FindEvent(Bridge.cast(eventMap.getItem("name"), System.String));
                            if (eventData == null) {
                                throw new System.Exception(System.String.concat("Event not found: ", eventMap.getItem("name")));
                            }
                            var e = ($t25 = new Spine.Event(Spine.SkeletonJson.GetFloat(eventMap, "time", 0), eventData), $t25.intValue = Spine.SkeletonJson.GetInt(eventMap, "int", eventData.Int), $t25.floatValue = Spine.SkeletonJson.GetFloat(eventMap, "float", eventData.Float), $t25.stringValue = Spine.SkeletonJson.GetString(eventMap, "string", eventData.String), $t25);
                            if (e.data.AudioPath != null) {
                                e.volume = Spine.SkeletonJson.GetFloat(eventMap, "volume", eventData.Volume);
                                e.balance = Spine.SkeletonJson.GetFloat(eventMap, "balance", eventData.Balance);
                            }
                            timeline11.SetFrame(Bridge.identity(frameIndex11, ((frameIndex11 = (frameIndex11 + 1) | 0))), e);
                        }
                    } finally {
                        if (Bridge.is($t24, System.IDisposable)) {
                            $t24.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline11);
                    duration = Math.max(duration, timeline11.frames[((timeline11.FrameCount - 1) | 0)]);
                }

                timelines.TrimExcess();
                skeletonData.animations.Add(new Spine.Animation(name, timelines, duration));
            },
            /*Spine.SkeletonJson.ReadAnimation end.*/


        },
        overloads: {
            "ReadSkeletonData(string)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    Bridge.define("Spine.SkeletonJson.LinkedMesh", {
        $kind: "nested class",
        fields: {
            parent: null,
            skin: null,
            slotIndex: 0,
            mesh: null,
            inheritDeform: false
        },
        ctors: {
            ctor: function (mesh, skin, slotIndex, parent, inheritDeform) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson.LinkedMesh#ctor", this ); }

                this.$initialize();
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent;
                this.inheritDeform = inheritDeform;
            }
        }
    });
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.Skin start.*/
    /**
     * Stores attachments by slot index and attachment name.
     <p>See SkeletonData {@link }, Skeleton {@link }, and
     <a href="http://esotericsoftware.com/spine-runtime-skins">Runtime skins</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.Skin
     */
    Bridge.define("Spine.Skin", {
        fields: {
            name: null,
            attachments: null,
            bones: null,
            constraints: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Name#get", this ); }

                    return this.name;
                }
            },
            Attachments: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Attachments#get", this ); }

                    return this.attachments;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Bones#get", this ); }

                    return this.bones;
                }
            },
            Constraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Constraints#get", this ); }

                    return this.constraints;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skin#init", this ); }

                this.attachments = new (Spine.Collections.OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment)).$ctor1(Spine.Skin.SkinEntryComparer.Instance);
                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.constraints = new (Spine.ExposedList$1(Spine.ConstraintData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Skin#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.Skin.SetAttachment start.*/
            /**
             * Adds an attachment to the skin for the specified slot index and name.
             If the name already exists for the slot, the previous value is replaced.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex     
             * @param   {string}              name          
             * @param   {Spine.Attachment}    attachment
             * @return  {void}
             */
            SetAttachment: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin#SetAttachment", this ); }

                if (attachment == null) {
                    throw new System.ArgumentNullException.$ctor3("attachment", "attachment cannot be null.");
                }
                if (slotIndex < 0) {
                    throw new System.ArgumentNullException.$ctor3("slotIndex", "slotIndex must be >= 0.");
                }
                this.attachments.setItem(new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, attachment), attachment);
            },
            /*Spine.Skin.SetAttachment end.*/

            /*Spine.Skin.AddSkin start.*/
            /**
             * Adds all attachments, bones, and constraints from the specified skin to this skin.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            AddSkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#AddSkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments.Keys);
                try {
                    while ($t2.moveNext()) {
                        var entry = $t2.Current;
                        this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AddSkin end.*/

            /*Spine.Skin.CopySkin start.*/
            /**
             * Adds all attachments from the specified skin to this skin. Attachments are deep copied.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            CopySkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#CopySkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments.Keys);
                try {
                    while ($t2.moveNext()) {
                        var entry = $t2.Current;
                        if (Bridge.is(entry.Attachment, Spine.MeshAttachment)) {
                            this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment != null ? Bridge.cast(entry.Attachment, Spine.MeshAttachment).NewLinkedMesh() : null);
                        } else {
                            this.SetAttachment(entry.SlotIndex, entry.Name, entry.Attachment != null ? entry.Attachment.Copy() : null);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.CopySkin end.*/

            /*Spine.Skin.GetAttachment start.*/
            /**
             * Returns the attachment for the specified slot index and name, or null.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex    
             * @param   {string}              name
             * @return  {Spine.Attachment}                 May be null.
             */
            GetAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachment", this ); }

                var lookup = new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, null);
                var attachment = { v : null };
                var containsKey = this.attachments.tryGetValue(lookup, attachment);
                return containsKey ? attachment.v : null;
            },
            /*Spine.Skin.GetAttachment end.*/

            /*Spine.Skin.RemoveAttachment start.*/
            /**
             * Removes the attachment in the skin for the specified slot index and name, if any.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}    slotIndex    
             * @param   {string}    name
             * @return  {void}
             */
            RemoveAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#RemoveAttachment", this ); }

                if (slotIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("slotIndex", "slotIndex must be >= 0");
                }
                var lookup = new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, null);
                this.attachments.remove(lookup);
            },
            /*Spine.Skin.RemoveAttachment end.*/

            /*Spine.Skin.GetAttachments start.*/
            /**
             * Returns all attachments contained in this skin.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @return  {System.Collections.Generic.ICollection$1}
             */
            GetAttachments: function () {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments", this ); }

                return this.attachments.Keys;
            },
            /*Spine.Skin.GetAttachments end.*/

            /*Spine.Skin.GetAttachments$1 start.*/
            
            GetAttachments$1: function (slotIndex, attachments) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        if (entry.SlotIndex === slotIndex) {
                            attachments.add(entry);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.GetAttachments$1 end.*/

            /*Spine.Skin.Clear start.*/
            /**
             * Clears all attachments, bones, and constraints.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Clear", this ); }

                this.attachments.clear();
                this.bones.Clear();
                this.constraints.Clear();
            },
            /*Spine.Skin.Clear end.*/

            /*Spine.Skin.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Skin#toString", this ); }

                return this.name;
            },
            /*Spine.Skin.toString end.*/

            /*Spine.Skin.AttachAll start.*/
            /**
             * Attach all attachments from this skin if the corresponding attachment from the old skin is currently attached.
             *
             * @instance
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Skin}        oldSkin
             * @return  {void}
             */
            AttachAll: function (skeleton, oldSkin) {
if ( TRACE ) { TRACE( "Spine.Skin#AttachAll", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(oldSkin.attachments.Keys);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var slotIndex = entry.SlotIndex;
                        var slot = ($t1 = skeleton.slots.Items)[slotIndex];
                        if (Bridge.referenceEquals(slot.Attachment, entry.Attachment)) {
                            var attachment = this.GetAttachment(slotIndex, entry.Name);
                            if (attachment != null) {
                                slot.Attachment = attachment;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AttachAll end.*/


        },
        overloads: {
            "GetAttachments(int, List<SkinEntry>)": "GetAttachments$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    /**
     * Stores an entry in the skin consisting of the slot index, name, and attachment.
     *
     * @public
     * @class Spine.Skin.SkinEntry
     */
    Bridge.define("Spine.Skin.SkinEntry", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getDefaultValue", this ); }
 return new Spine.Skin.SkinEntry(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            attachment: null,
            hashCode: 0
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            /**
             * The name the attachment is associated with, equivalent to the skin placeholder name in the Spine editor.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skin.SkinEntry
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Name#get", this ); }

                    return this.name;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Attachment#get", this ); }

                    return this.attachment;
                }
            }
        },
        ctors: {
            $ctor1: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$ctor1", this ); }

                this.$initialize();
                this.slotIndex = slotIndex;
                this.name = name;
                this.attachment = attachment;
                this.hashCode = (Bridge.getHashCode(this.name) + Bridge.Int.mul(this.slotIndex, 37)) | 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getHashCode", this ); }

                var h = Bridge.addHash([3772635665, this.slotIndex, this.name, this.attachment, this.hashCode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinEntry)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.attachment, o.attachment) && Bridge.equals(this.hashCode, o.hashCode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$clone", this ); }

                var s = to || new Spine.Skin.SkinEntry();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.attachment = this.attachment;
                s.hashCode = this.hashCode;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Slot start.*/
    /**
     * Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store
     state for an attachment.State cannot be stored in an attachment itself because attachments are stateless and may be shared
     across multiple skeletons.
     *
     * @public
     * @class Spine.Slot
     */
    Bridge.define("Spine.Slot", {
        fields: {
            data: null,
            bone: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachment: null,
            attachmentTime: 0,
            deform: null,
            attachmentState: 0
        },
        props: {
            /**
             * The slot's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Data
             * @type Spine.SlotData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Bone
             * @type Spine.Bone
             */
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Bone#get", this ); }

                    return this.bone;
                }
            },
            /**
             * The skeleton this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Skeleton
             * @type Spine.Skeleton
             */
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Skeleton#get", this ); }

                    return this.bone.skeleton;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R
             * @type number
             */
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R#set", this ); }

                    this.r = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G
             * @type number
             */
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G#set", this ); }

                    this.g = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B
             * @type number
             */
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B#set", this ); }

                    this.b = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function A
             * @type number
             */
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#A#set", this ); }

                    this.a = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R2
             * @type number
             * @see {@link HasSecondColor}
             */
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R2#set", this ); }

                    this.r2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G2
             * @type number
             * @see {@link HasSecondColor}
             */
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G2#set", this ); }

                    this.g2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B2
             * @type number
             * @see {@link HasSecondColor}
             */
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B2#set", this ); }

                    this.b2 = value;
                }
            },
            /**
             * Whether R2 G2 B2 are used to tint the slot's attachment for two color tinting. False if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function HasSecondColor
             * @type boolean
             */
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#get", this ); }

                    return this.data.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#set", this ); }

                    this.data.hasSecondColor = value;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#set", this ); }

                    if (Bridge.referenceEquals(this.attachment, value)) {
                        return;
                    }
                    this.attachment = value;
                    this.attachmentTime = this.bone.skeleton.time;
                    this.deform.Clear(false);
                }
            },
            /**
             * The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton
             {@link }
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function AttachmentTime
             * @type number
             */
            AttachmentTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#AttachmentTime#get", this ); }

                    return this.bone.skeleton.time - this.attachmentTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#AttachmentTime#set", this ); }

                    this.attachmentTime = this.bone.skeleton.time - value;
                }
            },
            /**
             * Vertices to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
             weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
             <p />
             See {@link } and {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function Deform
             * @type Spine.ExposedList$1
             */
            Deform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#get", this ); }

                    return this.deform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#set", this ); }

                    if (this.deform == null) {
                        throw new System.ArgumentNullException.$ctor3("deform", "deform cannot be null.");
                    }
                    this.deform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Slot#init", this ); }

                this.deform = new (Spine.ExposedList$1(System.Single)).ctor();
            },
            $ctor1: function (data, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = data;
                this.bone = bone;

                // darkColor = data.darkColor == null ? null : new Color();
                if (data.hasSecondColor) {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }

                this.SetToSetupPose();
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @param   {Spine.Slot}    slot    
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            ctor: function (slot, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#ctor", this ); }

                this.$initialize();
                if (slot == null) {
                    throw new System.ArgumentNullException.$ctor3("slot", "slot cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = slot.data;
                this.bone = bone;
                this.r = slot.r;
                this.g = slot.g;
                this.b = slot.b;
                this.a = slot.a;

                // darkColor = slot.darkColor == null ? null : new Color(slot.darkColor);
                if (slot.hasSecondColor) {
                    this.r2 = slot.r2;
                    this.g2 = slot.g2;
                    this.b2 = slot.b2;
                } else {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }
                this.hasSecondColor = slot.hasSecondColor;

                this.attachment = slot.attachment;
                this.attachmentTime = slot.attachmentTime;
                this.deform.AddRange(slot.deform);
            }
        },
        methods: {
            /*Spine.Slot.ClampColor start.*/
            ClampColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampColor", this ); }

                this.r = Spine.MathUtils.Clamp(this.r, 0, 1);
                this.g = Spine.MathUtils.Clamp(this.g, 0, 1);
                this.b = Spine.MathUtils.Clamp(this.b, 0, 1);
                this.a = Spine.MathUtils.Clamp(this.a, 0, 1);
            },
            /*Spine.Slot.ClampColor end.*/

            /*Spine.Slot.ClampSecondColor start.*/
            ClampSecondColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampSecondColor", this ); }

                this.r2 = Spine.MathUtils.Clamp(this.r2, 0, 1);
                this.g2 = Spine.MathUtils.Clamp(this.g2, 0, 1);
                this.b2 = Spine.MathUtils.Clamp(this.b2, 0, 1);
            },
            /*Spine.Slot.ClampSecondColor end.*/

            /*Spine.Slot.SetToSetupPose start.*/
            /**
             * Sets this slot to the setup pose.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SetToSetupPose", this ); }

                this.r = this.data.r;
                this.g = this.data.g;
                this.b = this.data.b;
                this.a = this.data.a;

                // if (darkColor != null) darkColor.set(data.darkColor);
                if (this.HasSecondColor) {
                    this.r2 = this.data.r2;
                    this.g2 = this.data.g2;
                    this.b2 = this.data.b2;
                }

                if (this.data.attachmentName == null) {
                    this.Attachment = null;
                } else {
                    this.attachment = null;
                    this.Attachment = this.bone.skeleton.GetAttachment(this.data.index, this.data.attachmentName);
                }
            },
            /*Spine.Slot.SetToSetupPose end.*/

            /*Spine.Slot.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Slot#toString", this ); }

                return this.data.name;
            },
            /*Spine.Slot.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    Bridge.define("Spine.SlotData", {
        fields: {
            index: 0,
            name: null,
            boneData: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachmentName: null,
            blendMode: 0
        },
        props: {
            /**
             * The index of the slot in {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the slot, which is unique across all slots in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function BoneData
             * @type Spine.BoneData
             */
            BoneData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BoneData#get", this ); }

                    return this.boneData;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#A#set", this ); }

                    this.a = value;
                }
            },
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#set", this ); }

                    this.r2 = value;
                }
            },
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#set", this ); }

                    this.g2 = value;
                }
            },
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#set", this ); }

                    this.b2 = value;
                }
            },
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#get", this ); }

                    return this.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#set", this ); }

                    this.hasSecondColor = value;
                }
            },
            /**
             * The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function AttachmentName
             * @type string
             */
            AttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#get", this ); }

                    return this.attachmentName;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#set", this ); }

                    this.attachmentName = value;
                }
            },
            /**
             * The blend mode for drawing the slot's attachment.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function BlendMode
             * @type Spine.BlendMode
             */
            BlendMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#get", this ); }

                    return this.blendMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#set", this ); }

                    this.blendMode = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.r2 = 0;
                this.g2 = 0;
                this.b2 = 0;
                this.hasSecondColor = false;
            },
            ctor: function (index, name, boneData) {
if ( TRACE ) { TRACE( "Spine.SlotData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0.", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (boneData == null) {
                    throw new System.ArgumentNullException.$ctor3("boneData", "boneData cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.boneData = boneData;
            }
        },
        methods: {
            /*Spine.SlotData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#toString", this ); }

                return this.name;
            },
            /*Spine.SlotData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SlotData end.*/

    /*Spine.SpacingMode start.*/
    Bridge.define("Spine.SpacingMode", {
        $kind: "enum",
        statics: {
            fields: {
                Length: 0,
                Fixed: 1,
                Percent: 2
            }
        }
    });
    /*Spine.SpacingMode end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasRendererObject);
                },
                /*Spine.SpineSkeletonExtensions.IsRenderable:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/

                /*Spine.SpineSkeletonExtensions.SetPropertyToSetupPose:static start.*/
                SetPropertyToSetupPose: function (skeleton, propertyID) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetPropertyToSetupPose", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11;
                    var tt = propertyID >> 24;
                    var timelineType = tt;
                    var i = (propertyID - (tt << 24)) | 0;

                    var bone;
                    var ikc;
                    var pc;

                    switch (timelineType) {
                        case Spine.TimelineType.Rotate: 
                            bone = ($t = skeleton.bones.Items)[i];
                            bone.rotation = bone.data.rotation;
                            break;
                        case Spine.TimelineType.Translate: 
                            bone = ($t1 = skeleton.bones.Items)[i];
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            break;
                        case Spine.TimelineType.Scale: 
                            bone = ($t2 = skeleton.bones.Items)[i];
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            break;
                        case Spine.TimelineType.Shear: 
                            bone = ($t3 = skeleton.bones.Items)[i];
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            break;
                        case Spine.TimelineType.Attachment: 
                            Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose(skeleton, i);
                            break;
                        case Spine.TimelineType.Color: 
                            Spine.SpineSkeletonExtensions.SetColorToSetupPose(($t4 = skeleton.slots.Items)[i]);
                            break;
                        case Spine.TimelineType.TwoColor: 
                            Spine.SpineSkeletonExtensions.SetColorToSetupPose(($t5 = skeleton.slots.Items)[i]);
                            break;
                        case Spine.TimelineType.Deform: 
                            ($t6 = skeleton.slots.Items)[i].Deform.Clear();
                            break;
                        case Spine.TimelineType.DrawOrder: 
                            Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose(skeleton);
                            break;
                        case Spine.TimelineType.IkConstraint: 
                            ikc = ($t7 = skeleton.ikConstraints.Items)[i];
                            ikc.mix = ikc.data.mix;
                            ikc.softness = ikc.data.softness;
                            ikc.bendDirection = ikc.data.bendDirection;
                            ikc.stretch = ikc.data.stretch;
                            break;
                        case Spine.TimelineType.TransformConstraint: 
                            var tc = ($t8 = skeleton.transformConstraints.Items)[i];
                            var tcData = tc.data;
                            tc.rotateMix = tcData.rotateMix;
                            tc.translateMix = tcData.translateMix;
                            tc.scaleMix = tcData.scaleMix;
                            tc.shearMix = tcData.shearMix;
                            break;
                        case Spine.TimelineType.PathConstraintPosition: 
                            pc = ($t9 = skeleton.pathConstraints.Items)[i];
                            pc.position = pc.data.position;
                            break;
                        case Spine.TimelineType.PathConstraintSpacing: 
                            pc = ($t10 = skeleton.pathConstraints.Items)[i];
                            pc.spacing = pc.data.spacing;
                            break;
                        case Spine.TimelineType.PathConstraintMix: 
                            pc = ($t11 = skeleton.pathConstraints.Items)[i];
                            pc.rotateMix = pc.data.rotateMix;
                            pc.translateMix = pc.data.translateMix;
                            break;
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetPropertyToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose:static start.*/
                /**
                 * Resets the DrawOrder to the Setup Pose's draw order
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton
                 * @return  {void}
                 */
                SetDrawOrderToSetupPose: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetDrawOrderToSetupPose", this ); }

                    var slotsItems = skeleton.slots.Items;
                    var n = skeleton.slots.Count;

                    var drawOrder = skeleton.drawOrder;
                    drawOrder.Clear(false);
                    drawOrder.EnsureCapacity(n);
                    drawOrder.Count = n;
                    System.Array.copy(slotsItems, 0, drawOrder.Items, 0, n);
                },
                /*Spine.SpineSkeletonExtensions.SetDrawOrderToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentsToSetupPose:static start.*/
                /**
                 * Resets all the slots on the skeleton to their Setup Pose attachments but does not reset slot colors.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton
                 * @return  {void}
                 */
                SetSlotAttachmentsToSetupPose: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetSlotAttachmentsToSetupPose", this ); }

                    var slotsItems = skeleton.slots.Items;
                    for (var i = 0; i < skeleton.slots.Count; i = (i + 1) | 0) {
                        var slot = slotsItems[i];
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = System.String.isNullOrEmpty(attachmentName) ? null : skeleton.GetAttachment(i, attachmentName);
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentsToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetColorToSetupPose:static start.*/
                /**
                 * Resets the color of a slot to Setup Pose value.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Slot}    slot
                 * @return  {void}
                 */
                SetColorToSetupPose: function (slot) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetColorToSetupPose", this ); }

                    slot.r = slot.data.r;
                    slot.g = slot.data.g;
                    slot.b = slot.data.b;
                    slot.a = slot.data.a;
                    slot.r2 = slot.data.r2;
                    slot.g2 = slot.data.g2;
                    slot.b2 = slot.data.b2;
                },
                /*Spine.SpineSkeletonExtensions.SetColorToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetAttachmentToSetupPose:static start.*/
                /**
                 * Sets a slot's attachment to setup pose. If you have the slotIndex, Skeleton.SetSlotAttachmentToSetupPose is faster.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Slot}    slot
                 * @return  {void}
                 */
                SetAttachmentToSetupPose: function (slot) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetAttachmentToSetupPose", this ); }

                    var slotData = slot.data;
                    slot.Attachment = slot.bone.skeleton.GetAttachment$1(slotData.name, slotData.attachmentName);
                },
                /*Spine.SpineSkeletonExtensions.SetAttachmentToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose:static start.*/
                /**
                 * Resets the attachment of slot at a given slotIndex to setup pose. This is faster than Slot.SetAttachmentToSetupPose.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Skeleton}    skeleton     
                 * @param   {number}            slotIndex
                 * @return  {void}
                 */
                SetSlotAttachmentToSetupPose: function (skeleton, slotIndex) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetSlotAttachmentToSetupPose", this ); }

                    var $t;
                    var slot = ($t = skeleton.slots.Items)[slotIndex];
                    var attachmentName = slot.data.attachmentName;
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        slot.Attachment = null;
                    } else {
                        var attachment = skeleton.GetAttachment(slotIndex, attachmentName);
                        slot.Attachment = attachment;
                    }
                },
                /*Spine.SpineSkeletonExtensions.SetSlotAttachmentToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose:static start.*/
                /**
                 * Resets Skeleton parts to Setup Pose according to a Spine.Animation's keyed items.
                 *
                 * @static
                 * @public
                 * @this Spine.SpineSkeletonExtensions
                 * @memberof Spine.SpineSkeletonExtensions
                 * @param   {Spine.Animation}    animation    
                 * @param   {Spine.Skeleton}     skeleton
                 * @return  {void}
                 */
                SetKeyedItemsToSetupPose: function (animation, skeleton) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#SetKeyedItemsToSetupPose", this ); }

                    animation.Apply(skeleton, 0, 0, false, null, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                },
                /*Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose:static end.*/

                /*Spine.SpineSkeletonExtensions.AllowImmediateQueue:static start.*/
                AllowImmediateQueue: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#AllowImmediateQueue", this ); }

                    if (trackEntry.nextTrackLast < 0) {
                        trackEntry.nextTrackLast = 0;
                    }
                },
                /*Spine.SpineSkeletonExtensions.AllowImmediateQueue:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.TextureFilter start.*/
    Bridge.define("Spine.TextureFilter", {
        $kind: "enum",
        statics: {
            fields: {
                Nearest: 0,
                Linear: 1,
                MipMap: 2,
                MipMapNearestNearest: 3,
                MipMapLinearNearest: 4,
                MipMapNearestLinear: 5,
                MipMapLinearLinear: 6
            }
        }
    });
    /*Spine.TextureFilter end.*/

    /*Spine.TextureLoader start.*/
    Bridge.define("Spine.TextureLoader", {
        $kind: "interface"
    });
    /*Spine.TextureLoader end.*/

    /*Spine.TextureWrap start.*/
    Bridge.define("Spine.TextureWrap", {
        $kind: "enum",
        statics: {
            fields: {
                MirroredRepeat: 0,
                ClampToEdge: 1,
                Repeat: 2
            }
        }
    });
    /*Spine.TextureWrap end.*/

    /*Spine.TimelineType start.*/
    Bridge.define("Spine.TimelineType", {
        $kind: "enum",
        statics: {
            fields: {
                Rotate: 0,
                Translate: 1,
                Scale: 2,
                Shear: 3,
                Attachment: 4,
                Color: 5,
                Deform: 6,
                Event: 7,
                DrawOrder: 8,
                IkConstraint: 9,
                TransformConstraint: 10,
                PathConstraintPosition: 11,
                PathConstraintSpacing: 12,
                PathConstraintMix: 13,
                TwoColor: 14
            }
        }
    });
    /*Spine.TimelineType end.*/

    /*Spine.TransformMode start.*/
    Bridge.define("Spine.TransformMode", {
        $kind: "enum",
        statics: {
            fields: {
                Normal: 0,
                OnlyTranslation: 7,
                NoRotationOrReflection: 1,
                NoScale: 2,
                NoScaleOrReflection: 6
            }
        },
        $flags: true
    });
    /*Spine.TransformMode end.*/

    /*Spine.Triangulator start.*/
    Bridge.define("Spine.Triangulator", {
        statics: {
            methods: {
                /*Spine.Triangulator.IsConcave:static start.*/
                IsConcave: function (index, vertexCount, vertices, indices) {
if ( TRACE ) { TRACE( "Spine.Triangulator#IsConcave", this ); }

                    var previous = indices[(((((vertexCount + index) | 0) - 1) | 0)) % vertexCount] << 1;
                    var current = indices[index] << 1;
                    var next = indices[(((index + 1) | 0)) % vertexCount] << 1;
                    return !Spine.Triangulator.PositiveArea(vertices[previous], vertices[((previous + 1) | 0)], vertices[current], vertices[((current + 1) | 0)], vertices[next], vertices[((next + 1) | 0)]);
                },
                /*Spine.Triangulator.IsConcave:static end.*/

                /*Spine.Triangulator.PositiveArea:static start.*/
                PositiveArea: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#PositiveArea", this ); }

                    return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
                },
                /*Spine.Triangulator.PositiveArea:static end.*/

                /*Spine.Triangulator.Winding:static start.*/
                Winding: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Winding", this ); }

                    var px = p2x - p1x, py = p2y - p1y;
                    return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
                },
                /*Spine.Triangulator.Winding:static end.*/


            }
        },
        fields: {
            convexPolygons: null,
            convexPolygonsIndices: null,
            indicesArray: null,
            isConcaveArray: null,
            triangles: null,
            polygonPool: null,
            polygonIndicesPool: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Triangulator#init", this ); }

                this.convexPolygons = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Single))).ctor();
                this.convexPolygonsIndices = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor();
                this.indicesArray = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.isConcaveArray = new (Spine.ExposedList$1(System.Boolean)).ctor();
                this.triangles = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.polygonPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Single)))();
                this.polygonIndicesPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Int32)))();
            }
        },
        methods: {
            /*Spine.Triangulator.Triangulate start.*/
            Triangulate: function (verticesArray) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Triangulate", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    vertices, 
                    vertexCount, 
                    indicesArray, 
                    indices, 
                    isConcaveArray, 
                    isConcave, 
                    triangles, 
                    previous, 
                    i2, 
                    next, 
                    p1, 
                    p2, 
                    p3, 
                    p1x, 
                    p1y, 
                    p2x, 
                    p2y, 
                    p3x, 
                    p3y, 
                    ii, 
                    v, 
                    vx, 
                    vy, 
                    previousIndex, 
                    nextIndex, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,14,15,16,17,18,19], $step);
                            switch ($step) {
                                case 0: {
                                    vertices = verticesArray.Items;
                                    vertexCount = verticesArray.Count >> 1;

                                    indicesArray = this.indicesArray;
                                    indicesArray.Clear();
                                    indices = indicesArray.Resize(vertexCount).Items;
                                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                        indices[i] = i;
                                    }

                                    isConcaveArray = this.isConcaveArray;
                                    isConcave = isConcaveArray.Resize(vertexCount).Items;
                                    for (var i1 = 0, n = vertexCount; i1 < n; i1 = (i1 + 1) | 0) {
                                        isConcave[i1] = Spine.Triangulator.IsConcave(i1, vertexCount, vertices, indices);
                                    }

                                    triangles = this.triangles;
                                    triangles.Clear();
                                    triangles.EnsureCapacity(Math.max(0, ((vertexCount - 2) | 0)) << 2);
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( vertexCount > 3 ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 19;
                                    continue;
                                }
                                case 2: {
                                    // Find ear tip.
                                    previous = (vertexCount - 1) | 0;
                                    i2 = 0;
                                    next = 1;

                                    // outer:
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( true ) {
                                        $step = 4;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 4: {
                                    if (!isConcave[i2]) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 16;
                                    continue;
                                }
                                case 5: {
                                    p1 = indices[previous] << 1;
                                    p2 = indices[i2] << 1;
                                    p3 = indices[next] << 1;
                                    p1x = vertices[p1];
                                    p1y = vertices[((p1 + 1) | 0)];
                                    p2x = vertices[p2];
                                    p2y = vertices[((p2 + 1) | 0)];
                                    p3x = vertices[p3];
                                    p3y = vertices[((p3 + 1) | 0)];
                                    ii = (((next + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    if ( ii !== previous ) {
                                        $step = 7;
                                        continue;
                                    }
                                    $step = 15;
                                    continue;
                                }
                                case 7: {
                                    if (!isConcave[ii]) {
                                        $step = 14;
                                        continue;
                                    }
                                    v = indices[ii] << 1;
                                    vx = vertices[v];
                                    vy = vertices[((v + 1) | 0)];
                                    if (Spine.Triangulator.PositiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
                                        $step = 8;
                                        continue;
                                    } 
                                    $step = 13;
                                    continue;
                                }
                                case 8: {
                                    if (Spine.Triangulator.PositiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 9: {
                                    if (Spine.Triangulator.PositiveArea(p2x, p2y, p3x, p3y, vx, vy)) {
                                        $step = 10;
                                        continue;
                                    } 
                                    $step = 11;
                                    continue;
                                }
                                case 10: {
                                    $step = 17;
                                    continue;
                                }
                                case 11: {
                                    // break outer;
                                    $step = 12;
                                    continue;
                                }


                                case 14: {
                                    ii = (((ii + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 15: {
                                    $step = 18;
                                    continue;
                                }
                                case 16: {

                                }
                                case 17: {
                                    if (next === 0) {
                                        do {
                                            if (!isConcave[i2]) {
                                                break;
                                            }
                                            i2 = (i2 - 1) | 0;
                                        } while (i2 > 0);
                                        $step = 18;
                                        continue;
                                    }

                                    previous = i2;
                                    i2 = next;
                                    next = (((next + 1) | 0)) % vertexCount;

                                    $step = 3;
                                    continue;
                                }
                                case 18: {
                                    // Cut ear tip.
                                    triangles.Add(indices[(((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount]);
                                    triangles.Add(indices[i2]);
                                    triangles.Add(indices[(((i2 + 1) | 0)) % vertexCount]);
                                    indicesArray.RemoveAt(i2);
                                    isConcaveArray.RemoveAt(i2);
                                    vertexCount = (vertexCount - 1) | 0;

                                    previousIndex = (((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount;
                                    nextIndex = i2 === vertexCount ? 0 : i2;
                                    isConcave[previousIndex] = Spine.Triangulator.IsConcave(previousIndex, vertexCount, vertices, indices);
                                    isConcave[nextIndex] = Spine.Triangulator.IsConcave(nextIndex, vertexCount, vertices, indices);

                                    $step = 1;
                                    continue;
                                }
                                case 19: {
                                    if (vertexCount === 3) {
                                        triangles.Add(indices[2]);
                                        triangles.Add(indices[0]);
                                        triangles.Add(indices[1]);
                                    }

                                    return triangles;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Triangulator.Triangulate end.*/

            /*Spine.Triangulator.Decompose start.*/
            Decompose: function (verticesArray, triangles) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Decompose", this ); }

                var vertices = verticesArray.Items;
                var convexPolygons = this.convexPolygons;
                for (var i = 0, n = convexPolygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Free(convexPolygons.Items[i]);
                }
                convexPolygons.Clear();

                var convexPolygonsIndices = this.convexPolygonsIndices;
                for (var i1 = 0, n1 = convexPolygonsIndices.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    this.polygonIndicesPool.Free(convexPolygonsIndices.Items[i1]);
                }
                convexPolygonsIndices.Clear();

                var polygonIndices = this.polygonIndicesPool.Obtain();
                polygonIndices.Clear();

                var polygon = this.polygonPool.Obtain();
                polygon.Clear();

                // Merge subsequent triangles if they form a triangle fan.
                var fanBaseIndex = -1, lastWinding = 0;
                var trianglesItems = triangles.Items;
                for (var i2 = 0, n2 = triangles.Count; i2 < n2; i2 = (i2 + 3) | 0) {
                    var t1 = trianglesItems[i2] << 1, t2 = trianglesItems[((i2 + 1) | 0)] << 1, t3 = trianglesItems[((i2 + 2) | 0)] << 1;
                    var x1 = vertices[t1], y1 = vertices[((t1 + 1) | 0)];
                    var x2 = vertices[t2], y2 = vertices[((t2 + 1) | 0)];
                    var x3 = vertices[t3], y3 = vertices[((t3 + 1) | 0)];

                    // If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).
                    var merged = false;
                    if (fanBaseIndex === t1) {
                        var o = (polygon.Count - 4) | 0;
                        var p = polygon.Items;
                        var winding1 = Spine.Triangulator.Winding(p[o], p[((o + 1) | 0)], p[((o + 2) | 0)], p[((o + 3) | 0)], x3, y3);
                        var winding2 = Spine.Triangulator.Winding(x3, y3, p[0], p[1], p[2], p[3]);
                        if (winding1 === lastWinding && winding2 === lastWinding) {
                            polygon.Add(x3);
                            polygon.Add(y3);
                            polygonIndices.Add(t3);
                            merged = true;
                        }
                    }

                    // Otherwise make this triangle the new base.
                    if (!merged) {
                        if (polygon.Count > 0) {
                            convexPolygons.Add(polygon);
                            convexPolygonsIndices.Add(polygonIndices);
                        } else {
                            this.polygonPool.Free(polygon);
                            this.polygonIndicesPool.Free(polygonIndices);
                        }
                        polygon = this.polygonPool.Obtain();
                        polygon.Clear();
                        polygon.Add(x1);
                        polygon.Add(y1);
                        polygon.Add(x2);
                        polygon.Add(y2);
                        polygon.Add(x3);
                        polygon.Add(y3);
                        polygonIndices = this.polygonIndicesPool.Obtain();
                        polygonIndices.Clear();
                        polygonIndices.Add(t1);
                        polygonIndices.Add(t2);
                        polygonIndices.Add(t3);
                        lastWinding = Spine.Triangulator.Winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1;
                    }
                }

                if (polygon.Count > 0) {
                    convexPolygons.Add(polygon);
                    convexPolygonsIndices.Add(polygonIndices);
                }

                // Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.
                for (var i3 = 0, n3 = convexPolygons.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    polygonIndices = convexPolygonsIndices.Items[i3];
                    if (polygonIndices.Count === 0) {
                        continue;
                    }
                    var firstIndex = polygonIndices.Items[0];
                    var lastIndex = polygonIndices.Items[((polygonIndices.Count - 1) | 0)];

                    polygon = convexPolygons.Items[i3];
                    var o1 = (polygon.Count - 4) | 0;
                    var p1 = polygon.Items;
                    var prevPrevX = p1[o1], prevPrevY = p1[((o1 + 1) | 0)];
                    var prevX = p1[((o1 + 2) | 0)], prevY = p1[((o1 + 3) | 0)];
                    var firstX = p1[0], firstY = p1[1];
                    var secondX = p1[2], secondY = p1[3];
                    var winding = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);

                    for (var ii = 0; ii < n3; ii = (ii + 1) | 0) {
                        if (ii === i3) {
                            continue;
                        }
                        var otherIndices = convexPolygonsIndices.Items[ii];
                        if (otherIndices.Count !== 3) {
                            continue;
                        }
                        var otherFirstIndex = otherIndices.Items[0];
                        var otherSecondIndex = otherIndices.Items[1];
                        var otherLastIndex = otherIndices.Items[2];

                        var otherPoly = convexPolygons.Items[ii];
                        var x31 = otherPoly.Items[((otherPoly.Count - 2) | 0)], y31 = otherPoly.Items[((otherPoly.Count - 1) | 0)];

                        if (otherFirstIndex !== firstIndex || otherSecondIndex !== lastIndex) {
                            continue;
                        }
                        var winding11 = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, x31, y31);
                        var winding21 = Spine.Triangulator.Winding(x31, y31, firstX, firstY, secondX, secondY);
                        if (winding11 === winding && winding21 === winding) {
                            otherPoly.Clear();
                            otherIndices.Clear();
                            polygon.Add(x31);
                            polygon.Add(y31);
                            polygonIndices.Add(otherLastIndex);
                            prevPrevX = prevX;
                            prevPrevY = prevY;
                            prevX = x31;
                            prevY = y31;
                            ii = 0;
                        }
                    }
                }

                // Remove empty polygons that resulted from the merge step above.
                for (var i4 = (convexPolygons.Count - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                    polygon = convexPolygons.Items[i4];
                    if (polygon.Count === 0) {
                        convexPolygons.RemoveAt(i4);
                        this.polygonPool.Free(polygon);
                        polygonIndices = convexPolygonsIndices.Items[i4];
                        convexPolygonsIndices.RemoveAt(i4);
                        this.polygonIndicesPool.Free(polygonIndices);
                    }
                }

                return convexPolygons;
            },
            /*Spine.Triangulator.Decompose end.*/


        }
    });
    /*Spine.Triangulator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.ScaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        $kind: "interface"
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are computed relative to setup pose instead of local-absolute.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t;
                    if (skeletonData === void 0) { skeletonData = null; }
                    var PREV_TIME = -3, PREV_X = -2, PREV_Y = -1;
                    var X = 1, Y = 2;

                    var frames = timeline.frames;
                    if (time < frames[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x, y;
                    if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                        x = frames[((frames.length + PREV_X) | 0)];
                        y = frames[((frames.length + PREV_Y) | 0)];
                    } else {
                        // Interpolate between the previous frame and the current frame.
                        var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                        x = frames[((frame + PREV_X) | 0)];
                        y = frames[((frame + PREV_Y) | 0)];
                        var frameTime = frames[frame];
                        var percent = timeline.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + PREV_TIME) | 0)] - frameTime));

                        x += (frames[((frame + X) | 0)] - x) * percent;
                        y += (frames[((frame + Y) | 0)] - y) * percent;
                    }

                    var xy = new pc.Vec2( x, y );
                    if (skeletonData == null) {
                        return xy.$clone();
                    } else {
                        var boneData = ($t = skeletonData.bones.Items)[timeline.boneIndex];
                        return xy.$clone().add( new pc.Vec2( boneData.x, boneData.y ) );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {Spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, Spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AttachmentTools.SkinUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.SkinUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.SkinUtilities.UnshareSkin:static start.*/
                /**
                 * Convenience method for duplicating a skeleton's current active skin so changes to it will not affect other skeleton instances. .
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skeleton}          skeleton              
                 * @param   {boolean}                 includeDefaultSkin    
                 * @param   {boolean}                 unshareAttachments    
                 * @param   {Spine.AnimationState}    state
                 * @return  {Spine.Skin}
                 */
                UnshareSkin: function (skeleton, includeDefaultSkin, unshareAttachments, state) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#UnshareSkin", this ); }

                    if (state === void 0) { state = null; }
                    // 1. Copy the current skin and set the skeleton's skin to the new one.
                    var newSkin = Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin(skeleton, "cloned skin", includeDefaultSkin, unshareAttachments, true);
                    skeleton.SetSkin(newSkin);

                    // 2. Apply correct attachments: skeleton.SetToSetupPose + animationState.Apply
                    if (state != null) {
                        skeleton.SetToSetupPose();
                        state.Apply(skeleton);
                    }

                    // 3. Return unshared skin.
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.UnshareSkin:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin:static start.*/
                GetClonedSkin: function (skeleton, newSkinName, includeDefaultSkin, cloneAttachments, cloneMeshesAsLinked) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetClonedSkin", this ); }

                    if (includeDefaultSkin === void 0) { includeDefaultSkin = false; }
                    if (cloneAttachments === void 0) { cloneAttachments = false; }
                    if (cloneMeshesAsLinked === void 0) { cloneMeshesAsLinked = true; }
                    var newSkin = new Spine.Skin(newSkinName); // may have null name. Harmless.
                    var defaultSkin = skeleton.data.DefaultSkin;
                    var activeSkin = skeleton.skin;

                    if (includeDefaultSkin) {
                        Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(defaultSkin, newSkin, true, cloneAttachments, cloneMeshesAsLinked);
                    }

                    if (activeSkin != null) {
                        Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(activeSkin, newSkin, true, cloneAttachments, cloneMeshesAsLinked);
                    }

                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClonedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClone:static start.*/
                /**
                 * Gets a shallow copy of the skin. The cloned skin's attachments are shared with the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}    original
                 * @return  {Spine.Skin}
                 */
                GetClone: function (original) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetClone", this ); }

                    var $t;
                    var newSkin = new Spine.Skin((original.name || "") + " clone");
                    var newSkinAttachments = newSkin.Attachments;
                    var newSkinBones = newSkin.Bones;
                    var newSkinConstraints = newSkin.Constraints;

                    $t = Bridge.getEnumerator(original.Attachments);
                    try {
                        while ($t.moveNext()) {
                            var a = $t.Current;
                            newSkinAttachments.setItem(a.key, a.value);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    newSkinBones.AddRange(original.bones);
                    newSkinConstraints.AddRange(original.constraints);
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment$1:static start.*/
                /**
                 * Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin          
                 * @param   {string}              slotName      
                 * @param   {string}              keyName       
                 * @param   {Spine.Attachment}    attachment    
                 * @param   {Spine.Skeleton}      skeleton
                 * @return  {void}
                 */
                SetAttachment$1: function (skin, slotName, keyName, attachment, skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment$1", this ); }

                    var slotIndex = skeleton.FindSlotIndex(slotName);
                    if (skeleton == null) {
                        throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    skin.SetAttachment(slotIndex, keyName, attachment);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment:static start.*/
                /**
                 * Adds an attachment to the skin for the specified slot index and name. If the name already exists for the slot, the previous value is replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin          
                 * @param   {number}              slotIndex     
                 * @param   {string}              keyName       
                 * @param   {Spine.Attachment}    attachment
                 * @return  {void}
                 */
                SetAttachment: function (skin, slotIndex, keyName, attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#SetAttachment", this ); }

                    skin.SetAttachment(slotIndex, keyName, attachment);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.SetAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.AddAttachments:static start.*/
                /**
                 * Adds skin items from another skin. For items that already exist, the previous values are replaced.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}    skin         
                 * @param   {Spine.Skin}    otherSkin
                 * @return  {void}
                 */
                AddAttachments: function (skin, otherSkin) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#AddAttachments", this ); }

                    if (otherSkin == null) {
                        return;
                    }
                    Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(otherSkin, skin, true, false);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.AddAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.GetAttachment:static start.*/
                /**
                 * Gets an attachment from the skin for the specified slot index and name.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.SkinUtilities
                 * @memberof Spine.Unity.AttachmentTools.SkinUtilities
                 * @param   {Spine.Skin}          skin        
                 * @param   {string}              slotName    
                 * @param   {string}              keyName     
                 * @param   {Spine.Skeleton}      skeleton
                 * @return  {Spine.Attachment}
                 */
                GetAttachment: function (skin, slotName, keyName, skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#GetAttachment", this ); }

                    var slotIndex = skeleton.FindSlotIndex(slotName);
                    if (skeleton == null) {
                        throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    return skin.GetAttachment(slotIndex, keyName);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.GetAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.RemoveAttachment:static start.*/
                RemoveAttachment: function (skin, slotName, keyName, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#RemoveAttachment", this ); }

                    var slotIndex = skeletonData.FindSlotIndex(slotName);
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor3("skeletonData", "skeletonData cannot be null.");
                    }
                    if (slotIndex === -1) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Slot '{0}' does not exist in skeleton.", [slotName]), "slotName");
                    }
                    skin.RemoveAttachment(slotIndex, keyName);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.RemoveAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.Clear:static start.*/
                Clear: function (skin) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#Clear", this ); }

                    skin.Attachments.clear();
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.Clear:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.Append:static start.*/
                Append: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#Append", this ); }

                    Spine.Unity.AttachmentTools.SkinUtilities.CopyTo(source, destination, true, false);
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.Append:static end.*/

                /*Spine.Unity.AttachmentTools.SkinUtilities.CopyTo:static start.*/
                CopyTo: function (source, destination, overwrite, cloneAttachments, cloneMeshesAsLinked) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.SkinUtilities#CopyTo", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5;
                    if (cloneMeshesAsLinked === void 0) { cloneMeshesAsLinked = true; }
                    var sourceAttachments = source.Attachments;
                    var destinationAttachments = destination.Attachments;
                    var destinationBones = destination.Bones;
                    var destinationConstraints = destination.Constraints;

                    if (cloneAttachments) {
                        if (overwrite) {
                            $t = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t.moveNext()) {
                                    var e = $t.Current;
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }
                        } else {
                            $t1 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t1.moveNext()) {
                                    var e1 = $t1.Current;
                                    if (destinationAttachments.containsKey(e1.key)) {
                                        continue;
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } else {
                        if (overwrite) {
                            $t2 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t2.moveNext()) {
                                    var e2 = $t2.Current;
                                    destinationAttachments.setItem(e2.key, e2.value);
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                        } else {
                            $t3 = Bridge.getEnumerator(sourceAttachments);
                            try {
                                while ($t3.moveNext()) {
                                    var e3 = $t3.Current;
                                    if (destinationAttachments.containsKey(e3.key)) {
                                        continue;
                                    }
                                    destinationAttachments.add(e3.key, e3.value);
                                }
                            } finally {
                                if (Bridge.is($t3, System.IDisposable)) {
                                    $t3.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }

                    $t4 = Bridge.getEnumerator(source.bones);
                    try {
                        while ($t4.moveNext()) {
                            var data = $t4.Current;
                            if (!destinationBones.Contains(data)) {
                                destinationBones.Add(data);
                            }
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }

                    $t5 = Bridge.getEnumerator(source.constraints);
                    try {
                        while ($t5.moveNext()) {
                            var data1 = $t5.Current;
                            if (!destinationConstraints.Contains(data1)) {
                                destinationConstraints.Add(data1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.AttachmentTools.SkinUtilities.CopyTo:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.SkinUtilities end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === Spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === Spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case Spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case Spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case Spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            skin.GetAttachments$1(slotIndex, skinEntries);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasRendererObject);
                            if (renderableAttachment != null) {
                                renderableAttachment.Spine$IHasRendererObject$RendererObject = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), replacementMaterials);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: "nested class",
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: "nested class",
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var localScale = this.followLocalScale ? new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) : new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }

                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: "nested enum",
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var canvas = this.skeletonGraphic.canvas;
                if (UnityEngine.Component.op_Equality(canvas, null)) {
                    canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                }
                var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var localScale = this.followLocalScale ? new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) : new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }
                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                var slotIndex = skeleton.FindSlotIndex(this.slotName);

                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments$1(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                bbCollider.isTrigger = this.IsTrigger;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                var slotIndex = skeleton.FindSlotIndex(this.slotName);

                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(canvas, null)) {
                        canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments$1(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                bbCollider.isTrigger = this.IsTrigger;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes start.*/
    /** @namespace Spine.Unity.Deprecated */

    /**
     * Deprecated. The spine-unity 3.7 runtime introduced SkeletonDataModifierAssets BlendModeMaterials which replaced SlotBlendModes. See the
     {@link } and
     {@link } for further information.
     This class will be removed in the spine-unity 3.9 runtime.
     *
     * @public
     * @class Spine.Unity.Deprecated.SlotBlendModes
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                materialTable: null
            },
            props: {
                MaterialTable: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#MaterialTable#get", this ); }

                        if (Spine.Unity.Deprecated.SlotBlendModes.materialTable == null) {
                            Spine.Unity.Deprecated.SlotBlendModes.materialTable = new (System.Collections.Generic.Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount)).ctor();
                        }
                        return Spine.Unity.Deprecated.SlotBlendModes.materialTable;
                    }
                }
            },
            methods: {
                /*Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor:static start.*/
                GetOrAddMaterialFor: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetOrAddMaterialFor", this ); }

                    var $t;
                    if (materialSource == null || texture == null) {
                        return null;
                    }

                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var matWithRefcount = { };
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    if (!mt.tryGetValue(key.$clone(), matWithRefcount)) {
                        matWithRefcount.v = new Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount(new UnityEngine.Material.$ctor1(materialSource));
                        var m = matWithRefcount.v.materialClone;
                        m.name = "(Clone)" + (texture.name || "") + "-" + (materialSource.name || "");
                        m.mainTexture = texture;
                        mt.setItem(key, matWithRefcount.v);
                    } else {
                        matWithRefcount.v.refcount = (matWithRefcount.v.refcount + 1) | 0;
                    }
                    return matWithRefcount.v.materialClone;
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor:static end.*/

                /*Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor:static start.*/
                GetExistingMaterialFor: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetExistingMaterialFor", this ); }

                    var $t;
                    if (materialSource == null || texture == null) {
                        return null;
                    }

                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var matWithRefcount = { };
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    if (!mt.tryGetValue(key.$clone(), matWithRefcount)) {
                        return null;
                    }
                    return matWithRefcount.v;
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor:static end.*/

                /*Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable:static start.*/
                RemoveMaterialFromTable: function (materialSource, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#RemoveMaterialFromTable", this ); }

                    var $t;
                    var mt = Spine.Unity.Deprecated.SlotBlendModes.MaterialTable;
                    var key = ($t = new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(), $t.material = materialSource, $t.texture2D = texture, $t);
                    mt.remove(key.$clone());
                },
                /*Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable:static end.*/


            }
        },
        fields: {
            multiplyMaterialSource: null,
            screenMaterialSource: null,
            texture: null,
            slotsWithCustomMaterial: null,
            Applied: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#init", this ); }

                this.slotsWithCustomMaterial = System.Array.init(0, function (){
                    return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                }, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple);
            }
        },
        methods: {
            /*Spine.Unity.Deprecated.SlotBlendModes.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Start", this ); }

                if (!this.Applied) {
                    this.Apply();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Start end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#OnDestroy", this ); }

                if (this.Applied) {
                    this.Remove();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.OnDestroy end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.Apply start.*/
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Apply", this ); }

                var $t, $t1;
                this.GetTexture();
                if (this.texture == null) {
                    return;
                }

                var skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                    return;
                }

                var slotMaterials = skeletonRenderer.CustomSlotMaterials;

                var numSlotsWithCustomMaterial = 0;
                $t = Bridge.getEnumerator(skeletonRenderer.Skeleton.Slots);
                try {
                    while ($t.moveNext()) {
                        var s = $t.Current;
                        switch (s.data.blendMode) {
                            case Spine.BlendMode.Multiply: 
                                if (this.multiplyMaterialSource != null) {
                                    slotMaterials.setItem(s, Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor(this.multiplyMaterialSource, this.texture));
                                    numSlotsWithCustomMaterial = (numSlotsWithCustomMaterial + 1) | 0;
                                }
                                break;
                            case Spine.BlendMode.Screen: 
                                if (this.screenMaterialSource != null) {
                                    slotMaterials.setItem(s, Spine.Unity.Deprecated.SlotBlendModes.GetOrAddMaterialFor(this.screenMaterialSource, this.texture));
                                    numSlotsWithCustomMaterial = (numSlotsWithCustomMaterial + 1) | 0;
                                }
                                break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slotsWithCustomMaterial = System.Array.init(numSlotsWithCustomMaterial, function (){
                    return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                }, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple);
                var storedSlotIndex = 0;
                $t1 = Bridge.getEnumerator(skeletonRenderer.Skeleton.Slots);
                try {
                    while ($t1.moveNext()) {
                        var s1 = $t1.Current;
                        switch (s1.data.blendMode) {
                            case Spine.BlendMode.Multiply: 
                                if (this.multiplyMaterialSource != null) {
                                    this.slotsWithCustomMaterial[Bridge.identity(storedSlotIndex, ((storedSlotIndex = (storedSlotIndex + 1) | 0)))] = new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple.$ctor1(s1, this.multiplyMaterialSource, this.texture);
                                }
                                break;
                            case Spine.BlendMode.Screen: 
                                if (this.screenMaterialSource != null) {
                                    this.slotsWithCustomMaterial[Bridge.identity(storedSlotIndex, ((storedSlotIndex = (storedSlotIndex + 1) | 0)))] = new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple.$ctor1(s1, this.screenMaterialSource, this.texture);
                                }
                                break;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.Applied = true;
                skeletonRenderer.LateUpdate();
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Apply end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.Remove start.*/
            Remove: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#Remove", this ); }

                var $t;
                this.GetTexture();
                if (this.texture == null) {
                    return;
                }

                var skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                    return;
                }

                var slotMaterials = skeletonRenderer.CustomSlotMaterials;

                $t = Bridge.getEnumerator(this.slotsWithCustomMaterial);
                try {
                    while ($t.moveNext()) {
                        var slotWithCustomMat = $t.Current.$clone();

                        var s = slotWithCustomMat.slot;
                        var storedMaterialSource = slotWithCustomMat.material;
                        var storedTexture = slotWithCustomMat.texture2D;

                        var matWithRefcount = Spine.Unity.Deprecated.SlotBlendModes.GetExistingMaterialFor(storedMaterialSource, storedTexture);
                        if (((matWithRefcount.refcount = (matWithRefcount.refcount - 1) | 0)) === 0) {
                            Spine.Unity.Deprecated.SlotBlendModes.RemoveMaterialFromTable(storedMaterialSource, storedTexture);
                        }
                        // we don't want to remove slotMaterials[s] if it has been changed in the meantime.
                        var m = { };
                        if (slotMaterials.tryGetValue(s, m)) {
                            var existingMat = matWithRefcount == null ? null : matWithRefcount.materialClone;
                            if (Bridge.referenceEquals(m.v, existingMat)) {
                                slotMaterials.remove(s);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slotsWithCustomMaterial = null;

                this.Applied = false;
                if (skeletonRenderer.valid) {
                    skeletonRenderer.LateUpdate();
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.Remove end.*/

            /*Spine.Unity.Deprecated.SlotBlendModes.GetTexture start.*/
            GetTexture: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes#GetTexture", this ); }

                if (this.texture == null) {
                    var sr = this.GetComponent(Spine.Unity.SkeletonRenderer);
                    if (UnityEngine.MonoBehaviour.op_Equality(sr, null)) {
                        return;
                    }
                    var sda = sr.skeletonDataAsset;
                    if (sda == null) {
                        return;
                    }
                    var aa = sda.atlasAssets[0];
                    if (aa == null) {
                        return;
                    }
                    var am = aa.PrimaryMaterial;
                    if (am == null) {
                        return;
                    }
                    this.texture = Bridge.as(am.mainTexture, UnityEngine.Texture2D);
                }
            },
            /*Spine.Unity.Deprecated.SlotBlendModes.GetTexture end.*/


        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getDefaultValue", this ); }
 return new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair(); }
            }
        },
        fields: {
            texture2D: null,
            material: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#getHashCode", this ); }

                var h = Bridge.addHash([6830820329, this.texture2D, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair)) {
                    return false;
                }
                return Bridge.equals(this.texture2D, o.texture2D) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair#$clone", this ); }

                var s = to || new Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair();
                s.texture2D = this.texture2D;
                s.material = this.material;
                return s;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount", {
        $kind: "nested class",
        fields: {
            materialClone: null,
            refcount: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#init", this ); }

                this.refcount = 1;
            },
            ctor: function (mat) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount#ctor", this ); }

                this.$initialize();
                this.materialClone = mat;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple start.*/
    Bridge.define("Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getDefaultValue", this ); }
 return new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple(); }
            }
        },
        fields: {
            slot: null,
            texture2D: null,
            material: null
        },
        ctors: {
            $ctor1: function (slot, material, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$ctor1", this ); }

                this.$initialize();
                this.slot = slot;
                this.material = material;
                this.texture2D = texture;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#getHashCode", this ); }

                var h = Bridge.addHash([10545495888, this.slot, this.texture2D, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple)) {
                    return false;
                }
                return Bridge.equals(this.slot, o.slot) && Bridge.equals(this.texture2D, o.texture2D) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple#$clone", this ); }

                var s = to || new Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple();
                s.slot = this.slot;
                s.texture2D = this.texture2D;
                s.material = this.material;
                return s;
            }
        }
    });
    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).FindEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Spine.Unity.FollowLocationRigidbody.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#FixedUpdate", this ); }

                this.ownRigidbody.rotation = this.reference.rotation.$clone();
                this.ownRigidbody.position = this.reference.position.$clone();
            },
            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody2D
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            followFlippedX: false,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody2D.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Spine.Unity.FollowLocationRigidbody2D.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#FixedUpdate", this ); }

                if (this.followFlippedX) {
                    this.ownRigidbody.rotation = ((-this.reference.rotation.getPositiveEulerAngles().z + 270.0) % 360.0) - 90.0;
                } else {
                    this.ownRigidbody.rotation = this.reference.rotation.getPositiveEulerAngles().z;
                }
                this.ownRigidbody.position = UnityEngine.Vector2.FromVector3(this.reference.position.$clone());
            },
            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note that flipping needs to be performed by 180 degree rotation at {@link },
     by setting {@link } to true, not via negative scale.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.FollowSkeletonUtilityRootRotation
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowSkeletonUtilityRootRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                FLIP_ANGLE_THRESHOLD: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                    this.FLIP_ANGLE_THRESHOLD = 100.0;
                }
            }
        },
        fields: {
            reference: null,
            prevLocalEulerAngles: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                this.prevLocalEulerAngles = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#Start", this ); }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate", this ); }

                this.transform.rotation = this.reference.rotation.$clone();

                var wasFlippedAroundY = Math.abs(this.transform.localEulerAngles.y - this.prevLocalEulerAngles.y) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                var wasFlippedAroundX = Math.abs(this.transform.localEulerAngles.x - this.prevLocalEulerAngles.x) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                if (wasFlippedAroundY) {
                    this.CompensatePositionToYRotation();
                }
                if (wasFlippedAroundX) {
                    this.CompensatePositionToXRotation();
                }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToYRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.y = this.transform.position.y;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToXRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.x = this.transform.position.x;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation end.*/


        }
    });
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        $kind: "interface"
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        $kind: "interface"
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        $kind: "interface"
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        $kind: "interface"
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        $kind: "interface"
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            continue;
                        }
                        var attachment = slot.attachment;

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.RendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            continue;
                        }
                        var attachment = slot.attachment;
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasRendererObject);
                        if (rendererAttachment != null) {
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                } else {
                                    lastRendererMaterial = material;
                                }
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.drawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.active) {
                            continue;
                        }
                        var attachment = slot.attachment;
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var rendererObject = null; // An AtlasRegion in plain Spine-Unity. Spine-TK2D hooks into TK2D's system. eventual source of Material object.
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.RendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var m = wsii[i].material;
                        var mo = { };
                        if (customMaterialOverride.tryGetValue(m, mo)) {
                            wsii[i].material = mo.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.Offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BLX], offsets[Spine.RegionAttachment.BLY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.ULX], offsets[Spine.RegionAttachment.ULY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.URX], offsets[Spine.RegionAttachment.URY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BRX], offsets[Spine.RegionAttachment.BRY], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.UVs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.ULX], uvs[Spine.RegionAttachment.ULY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.URX], uvs[Spine.RegionAttachment.URY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BRX], uvs[Spine.RegionAttachment.BRY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BLX], uvs[Spine.RegionAttachment.BLY] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.r, regionAttachment.g, regionAttachment.b, regionAttachment.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.WorldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.WorldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.Vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.r, meshAttachment.g, meshAttachment.b, meshAttachment.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.ClipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.drawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.a, skeletonR = skeleton.r, skeletonG = skeleton.g, skeletonB = skeleton.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.ClipStart(slot, Bridge.as(slot.attachment, Spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.active) {
                        this.clipper.ClipEnd$1(slot1);
                        continue;
                    }
                    var attachment = slot1.attachment;
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.ComputeWorldVertices(slot1.bone, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.r;
                        c.g = region.g;
                        c.b = region.b;
                        c.a = region.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.ComputeWorldVertices(slot1, 0, meshVerticesLength, workingVerts, 0); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.r;
                            c.g = mesh.g;
                            c.b = mesh.b;
                            c.a = mesh.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.ClipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.ClipEnd$1(slot1);
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.b * c.b * color.a);
                        if (slot1.data.blendMode === Spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.IsClipping) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.clippedVertices.Items;
                        attachmentVertexCount = this.clipper.clippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.clippedTriangles.Items;
                        attachmentIndexCount = this.clipper.clippedTriangles.Count;
                        uvs = this.clipper.clippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.r2;
                            var g2 = slot1.g2;
                            var b2 = slot1.b2;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.ClipEnd$1(slot1);
                }
                this.clipper.ClipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i].$clone(), updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.drawOrder.Items;
                    var a = skeleton.a, r = skeleton.r, g = skeleton.g, b = skeleton.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.active) {
                                continue;
                            }
                            var attachment = slot.attachment;

                            rg.x = slot.r2; //r
                            rg.y = slot.g2; //g
                            b2.x = slot.b2; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.a * regionAttachment.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === Spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.a * meshAttachment.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === Spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var meshVertexCount = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < meshVertexCount; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.active) {
                            continue;
                        }
                        var attachment1 = slot1.attachment;
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.ComputeWorldVertices(slot1.bone, tempVerts, 0);

                            var x1 = tempVerts[Spine.RegionAttachment.BLX], y1 = tempVerts[Spine.RegionAttachment.BLY];
                            var x2 = tempVerts[Spine.RegionAttachment.ULX], y2 = tempVerts[Spine.RegionAttachment.ULY];
                            var x3 = tempVerts[Spine.RegionAttachment.URX], y3 = tempVerts[Spine.RegionAttachment.URY];
                            var x4 = tempVerts[Spine.RegionAttachment.BRX], y4 = tempVerts[Spine.RegionAttachment.BRY];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.a * regionAttachment1.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.r * regionAttachment1.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.g * regionAttachment1.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.b * regionAttachment1.b * color.a);
                                if (slot1.data.blendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.a * regionAttachment1.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.r * regionAttachment1.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.g * regionAttachment1.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.b * regionAttachment1.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[Spine.RegionAttachment.BLX];
                            ubi[vertexIndex].y = regionUVs[Spine.RegionAttachment.BLY];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[Spine.RegionAttachment.BRX];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[Spine.RegionAttachment.BRY];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[Spine.RegionAttachment.ULX];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[Spine.RegionAttachment.ULY];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[Spine.RegionAttachment.URX];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[Spine.RegionAttachment.URY];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var meshVertexCount1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < meshVertexCount1) {
                                    this.tempVerts = (tempVerts = System.Array.init(meshVertexCount1, 0, System.Single));
                                }
                                meshAttachment1.ComputeWorldVertices$1(slot1, tempVerts);

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.a * meshAttachment1.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.r * meshAttachment1.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.g * meshAttachment1.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.b * meshAttachment1.b * color.a);
                                    if (slot1.data.blendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.a * meshAttachment1.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.r * meshAttachment1.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.g * meshAttachment1.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.b * meshAttachment1.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < meshVertexCount1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.drawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.active) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].attachment;
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var $t;
                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;

                    if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                        mesh.bounds = new pc.BoundingBox.ctor();
                    } else {
                        //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                        var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                        var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                        mesh.bounds = ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                    }
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$3(submeshesItems[i].Items, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: "nested struct",
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: "nested class",
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new Spine.AnimationStateData(this.skeletonData);
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        if (this.fromAnimation[i].length === 0 || this.toAnimation[i].length === 0) {
                            continue;
                        }
                        this.stateData.SetMix$1(this.fromAnimation[i], this.toAnimation[i], this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: "nested class",
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: "nested enum",
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: "nested class",
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.r, s.g, s.b, s.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.r, a.g, a.b, a.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.r, a.g, a.b, a.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.r, s.g, s.b, s.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.r2, s.g2, s.b2, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.A = color.a;
                    skeleton.R = color.r;
                    skeleton.G = color.g;
                    skeleton.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.A = color.a;
                    slot.R = color.r;
                    slot.G = color.g;
                    slot.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.ScaleX = scale.x;
                    skeleton.ScaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.ScaleX, skeleton.ScaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasRendererObject);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasRendererObject$RendererObject;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.Name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.ComputeWorldVertices$1(slot, floats);

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.Name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.ComputeWorldVertices$1(slot, floats);

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: "nested class",
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static start.*/
                AnimationTime$1: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(normalizedTime, clipLength, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = (normalizedTime % 1.0) + 1.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, Spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.Name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                if (isLooping && clip.duration !== 0) {
                    time %= clip.duration;
                    lastTime %= clip.duration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === Spine.MixBlend.Add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        Spine.SpineSkeletonExtensions.SetKeyedItemsToSetupPose(previousAnimations.getItem(i), skeleton);
                    }

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : Spine.MixBlend.Replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === Spine.MixBlend.Add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === Spine.MixBlend.Add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: "nested class",
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: "nested class",
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: "nested class",
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            rigidBody: null,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            topLevelBones: null,
            initialOffset: null,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null
        },
        props: {
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector2();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                    this.rigidBody2D.MovePosition(new pc.Vec2( this.transform.position.x, this.transform.position.y ).add( this.rigidbodyDisplacement ));
                }
                if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                    this.rigidBody.MovePosition(this.transform.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, 0 ) ));
                }
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                this.GetScaleAffectingRootMotion$1(parentBoneScale);
                this.ClearEffectiveBoneOffsets(parentBoneScale.v.$clone());
                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var $t;
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var index = skeleton.FindBoneIndex(name);
                if (index >= 0) {
                    this.rootMotionBoneIndex = index;
                    this.rootMotionBone = ($t = skeleton.bones.Items)[index];
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.RootBone;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }


                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    return this.GetTimelineMovementDelta(startTime, endTime, timeline, animation);
                }
                return pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    var duration = animation.duration;
                    var mid = duration * 0.5;
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, duration);
                    rootMotion.timeIsPastMid = currentTime > mid;
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, timeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.Parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var skeletonDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale);
                this.ApplyRootMotion(skeletonDelta.$clone(), parentBoneScale.v.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }

                // Apply root motion to Transform or RigidBody;
                if (this.UsesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( UnityEngine.Vector2.FromVector3(this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta))) );

                    // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                    // Until the next Physics update, tempBoneDisplacement is offsetting bone locations
                    // to prevent stutter which would otherwise occur if we don't move every Update.
                    this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonDelta.$clone() );
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement.$clone(), parentBoneScale.$clone());
                } else {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta)) );
                    this.ClearEffectiveBoneOffsets(parentBoneScale.$clone());
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.ScaleX;
                totalScale.y *= skeleton.ScaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.ScaleX;
                    parentBoneScale.v.y *= scaleBone.ScaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                var totalScale = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;
                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.ScaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.ScaleY;
                            }
                        } else {
                            var offsetX = (this.initialOffset.x - this.rootMotionBone.x) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - this.rootMotionBone.y) * parentBoneScale.y;
                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.ScaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.ScaleY) + offsetY;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), parentBoneScale.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i].$clone(), updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    /**
     * This enum controls the mode under which the sprite will interact with the masking system.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
     */
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: "nested class",
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                    this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);

                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(Spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.drawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.active) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.attachment;
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                this.skeletonRenderer.LateUpdate();

                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                if (this.copyPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (this.copyPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }

                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }

            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.FindSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var attachment = skin.GetAttachment(skeleton.FindSlotIndex(slotName), attachmentName);
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                    if (box != null) {
                        var slot = skeleton.FindSlot(slotName);
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.Name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.Name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.Vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            canvas: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.ScaleX), Math.abs(skeleton.ScaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.ScaleY > 0 ? 0 : 180, skeleton.ScaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.ScaleX, skeleton.ScaleY, 1.0 );
                    }
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.positionScale = this.canvas.referencePixelsPerUnit;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.positionScale = 100.0;
                    }
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.Data.Name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.Data.Name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.AppliedRotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.X * this.positionScale, b.bone.Y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.FindBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.Active) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.ScaleX * skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            // Use Applied transform values (ax, ay, AppliedRotation, ascale) if world values were modified by constraints.
                            if (!this.bone.appliedValid) {
                                this.bone.UpdateAppliedTransform();
                            }
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.AppliedRotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle;
                            this.bone.AppliedRotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up.$clone()) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle1;
                            this.bone.AppliedRotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: "nested enum",
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: "nested enum",
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: "enum",
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: "nested enum",
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data.Name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     *
     * @public
     * @class Spine.Unity.WaitForSpineTrackEntryEnd
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineTrackEntryEnd
             * @memberof Spine.Unity.WaitForSpineTrackEntryEnd
             * @param   {Spine.TrackEntry}                         trackEntry
             * @return  {Spine.Unity.WaitForSpineTrackEntryEnd}
             */
            NowWaitFor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*ThirdParties.Truongtv.SoundManager.BaseAudio start.*/
    Bridge.define("ThirdParties.Truongtv.SoundManager.BaseAudio", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            AudioSource: null
        },
        methods: {
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#Awake", this ); }

                this.AudioSource = this.GetComponent(UnityEngine.AudioSource);
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Awake end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.PlayOnceShot start.*/
            PlayOnceShot: function (clip, delay, complete) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#PlayOnceShot", this ); }

                if (delay === void 0) { delay = 0.0; }
                if (complete === void 0) { complete = null; }
                this.AudioSource.clip = clip;
                this.AudioSource.PlayDelayed(delay);
                this.StartCoroutine$1(this.WaitToFinish(complete));
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.PlayOnceShot end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.PlayLoop start.*/
            PlayLoop: function (clip) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#PlayLoop", this ); }

                this.AudioSource.clip = clip;
                this.AudioSource.loop = true;
                this.AudioSource.Play();

            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.PlayLoop end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.WaitToFinish start.*/
            WaitToFinish: function (complete) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#WaitToFinish", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (complete === void 0) { complete = null; }
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( this.AudioSource.isPlaying ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    !Bridge.staticEquals(complete, null) ? complete() : null;
                                        this.Stop();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.WaitToFinish end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Pause start.*/
            Pause: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#Pause", this ); }

                this.AudioSource.Pause();
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Pause end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Resume start.*/
            Resume: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#Resume", this ); }

                this.AudioSource.UnPause();
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Resume end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Stop start.*/
            Stop: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#Stop", this ); }

                this.AudioSource.Stop();
                this.AudioSource.clip = null;
                this.AudioSource.gameObject.SetActive(false);
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.Stop end.*/

            /*ThirdParties.Truongtv.SoundManager.BaseAudio.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.BaseAudio#OnValidate", this ); }

                this.GetComponent(UnityEngine.AudioSource).playOnAwake = false;
            },
            /*ThirdParties.Truongtv.SoundManager.BaseAudio.OnValidate end.*/


        }
    });
    /*ThirdParties.Truongtv.SoundManager.BaseAudio end.*/

    /*ThirdParties.Truongtv.SoundManager.SoundManager start.*/
    Bridge.define("ThirdParties.Truongtv.SoundManager.SoundManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                INSERT_KEY: null,
                SOUND_SFX: null,
                SOUND_BGM: null,
                OnBgmSettingChange: null,
                OnSfxSettingChange: null,
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#Instance#get", this ); }

                        return ThirdParties.Truongtv.SoundManager.SoundManager._instance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#init", this ); }

                    this.INSERT_KEY = "_number_";
                    this.SOUND_SFX = "sfx";
                    this.SOUND_BGM = "bgm";
                }
            },
            methods: {
                /*ThirdParties.Truongtv.SoundManager.SoundManager.IsBgm:static start.*/
                IsBgm: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#IsBgm", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(ThirdParties.Truongtv.SoundManager.SoundManager.SOUND_BGM) === 0;
                },
                /*ThirdParties.Truongtv.SoundManager.SoundManager.IsBgm:static end.*/

                /*ThirdParties.Truongtv.SoundManager.SoundManager.IsSfx:static start.*/
                IsSfx: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#IsSfx", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(ThirdParties.Truongtv.SoundManager.SoundManager.SOUND_SFX) === 0;
                },
                /*ThirdParties.Truongtv.SoundManager.SoundManager.IsSfx:static end.*/

                /*ThirdParties.Truongtv.SoundManager.SoundManager.SetSfx:static start.*/
                SetSfx: function (isOn) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#SetSfx", this ); }

                    !Bridge.staticEquals(ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange, null) ? ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange(isOn) : null;
                    UnityEngine.PlayerPrefs.SetInt(ThirdParties.Truongtv.SoundManager.SoundManager.SOUND_SFX, isOn ? 0 : -1);
                    UnityEngine.PlayerPrefs.Save();
                },
                /*ThirdParties.Truongtv.SoundManager.SoundManager.SetSfx:static end.*/

                /*ThirdParties.Truongtv.SoundManager.SoundManager.SetBgm:static start.*/
                SetBgm: function (isOn) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#SetBgm", this ); }

                    !Bridge.staticEquals(ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange, null) ? ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange(isOn) : null;
                    UnityEngine.PlayerPrefs.SetInt(ThirdParties.Truongtv.SoundManager.SoundManager.SOUND_BGM, isOn ? 0 : -1);
                    UnityEngine.PlayerPrefs.Save();
                },
                /*ThirdParties.Truongtv.SoundManager.SoundManager.SetBgm:static end.*/


            }
        },
        fields: {
            sfxPrefab: null,
            sfxList: null,
            buttonSound: null,
            popupOpenSound: null,
            popupCloseSound: null
        },
        methods: {
            /*ThirdParties.Truongtv.SoundManager.SoundManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(ThirdParties.Truongtv.SoundManager.SoundManager._instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(ThirdParties.Truongtv.SoundManager.SoundManager._instance.gameObject);
                }

                ThirdParties.Truongtv.SoundManager.SoundManager._instance = this;
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.Awake end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlaySfx start.*/
            PlaySfx: function (clip, isLoop, delay, onComplete) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#PlaySfx", this ); }

                if (isLoop === void 0) { isLoop = false; }
                if (delay === void 0) { delay = 0.0; }
                if (onComplete === void 0) { onComplete = null; }
                var simple = this.GetSfxInstance();
                simple.Play(clip, isLoop, delay, onComplete);
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlaySfx end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayBgm start.*/
            PlayBgm: function (clip) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#PlayBgm", this ); }

                if (!ThirdParties.Truongtv.SoundManager.Bgm.Instance.IsPlaying()) {
                    ThirdParties.Truongtv.SoundManager.Bgm.Instance.Play(clip);
                } else {
                    if (ThirdParties.Truongtv.SoundManager.Bgm.Instance.IsPlayingClip(clip)) {
                        ThirdParties.Truongtv.SoundManager.Bgm.Instance.Resume();
                    } else {
                        ThirdParties.Truongtv.SoundManager.Bgm.Instance.Play(clip);
                    }
                }
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayBgm end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.Pause start.*/
            Pause: function (isPause) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#Pause", this ); }

                if (isPause) {
                    ThirdParties.Truongtv.SoundManager.Bgm.Instance.Pause();
                    for (var i = 0; i < this.sfxList.Count; i = (i + 1) | 0) {
                        this.sfxList.getItem(i).Pause();
                    }
                } else {
                    ThirdParties.Truongtv.SoundManager.Bgm.Instance.Resume();
                    for (var i1 = 0; i1 < this.sfxList.Count; i1 = (i1 + 1) | 0) {
                        this.sfxList.getItem(i1).Resume();
                    }
                }
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.Pause end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.GetSfxInstance start.*/
            GetSfxInstance: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#GetSfxInstance", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.sfxPrefab, null)) {
                    return null;
                }
                for (var i = 0; i < this.sfxList.Count; i = (i + 1) | 0) {
                    if (this.sfxList.getItem(i).gameObject.activeSelf) {
                        continue;
                    }
                    this.sfxList.getItem(i).gameObject.SetActive(true);
                    return this.sfxList.getItem(i);
                }
                var count = this.sfxList.Count;
                var go = UnityEngine.Object.Instantiate(ThirdParties.Truongtv.SoundManager.Sfx, this.sfxPrefab, this.transform);
                go.transform.SetParent(this.transform);
                go.gameObject.name = "sfx_number_" + count;
                this.sfxList.add(go);
                return go;
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.GetSfxInstance end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayPopupOpenSound start.*/
            PlayPopupOpenSound: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#PlayPopupOpenSound", this ); }

                this.PlaySfx(this.popupOpenSound);
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayPopupOpenSound end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayPopupCloseSound start.*/
            PlayPopupCloseSound: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#PlayPopupCloseSound", this ); }

                this.PlaySfx(this.popupCloseSound);
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayPopupCloseSound end.*/

            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayButtonSound start.*/
            PlayButtonSound: function (complete) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SoundManager#PlayButtonSound", this ); }

                if (complete === void 0) { complete = null; }
                this.PlaySfx(this.buttonSound, false, 0.0, complete);
            },
            /*ThirdParties.Truongtv.SoundManager.SoundManager.PlayButtonSound end.*/


        }
    });
    /*ThirdParties.Truongtv.SoundManager.SoundManager end.*/

    /*Truongtv.Utilities.DontDestroyOnLoad start.*/
    Bridge.define("Truongtv.Utilities.DontDestroyOnLoad", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*Truongtv.Utilities.DontDestroyOnLoad.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Truongtv.Utilities.DontDestroyOnLoad#Start", this ); }

                UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
            },
            /*Truongtv.Utilities.DontDestroyOnLoad.Start end.*/


        }
    });
    /*Truongtv.Utilities.DontDestroyOnLoad end.*/

    /*Truongtv.Utilities.Extended start.*/
    Bridge.define("Truongtv.Utilities.Extended", {
        statics: {
            methods: {
                /*Truongtv.Utilities.Extended.IsInLayerMask:static start.*/
                IsInLayerMask: function (obj, layerMask) {
if ( TRACE ) { TRACE( "Truongtv.Utilities.Extended#IsInLayerMask", this ); }

                    return ((layerMask.value & (1 << obj.layer)) > 0);
                },
                /*Truongtv.Utilities.Extended.IsInLayerMask:static end.*/


            }
        }
    });
    /*Truongtv.Utilities.Extended end.*/

    /*Truongtv.Utilities.Singleton$1 start.*/
    Bridge.define("Truongtv.Utilities.Singleton$1", function (T) { return {
        statics: {
            fields: {
                _instance: Bridge.getDefaultValue(T)
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Truongtv.Utilities.Singleton$1#Instance#get", this ); }

                        if (Bridge.rValue(Truongtv.Utilities.Singleton$1(T)._instance) == null) {
                            Truongtv.Utilities.Singleton$1(T)._instance = Bridge.createInstance(T);
                        }
                        return Bridge.rValue(Truongtv.Utilities.Singleton$1(T)._instance);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Truongtv.Utilities.Singleton$1#init", this ); }

                    this._instance = Bridge.getDefaultValue(T);
                }
            }
        }
    }; });
    /*Truongtv.Utilities.Singleton$1 end.*/

    /*UICanvasManager start.*/
    Bridge.define("UICanvasManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                GlobalAccess: null
            }
        },
        fields: {
            MouseOverButton: false,
            PENameText: null,
            ToolTipText: null,
            rayHit: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UICanvasManager#init", this ); }

                this.rayHit = new UnityEngine.RaycastHit();
                this.MouseOverButton = false;
            }
        },
        methods: {
            /*UICanvasManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UICanvasManager#Awake", this ); }

                UICanvasManager.GlobalAccess = this;
            },
            /*UICanvasManager.Awake end.*/

            /*UICanvasManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UICanvasManager#Start", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.PENameText, null)) {
                    this.PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
                }
            },
            /*UICanvasManager.Start end.*/

            /*UICanvasManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "UICanvasManager#Update", this ); }


                // Mouse Click - Check if mouse over button to prevent spawning particle effects while hovering or using UI buttons.
                if (!this.MouseOverButton) {
                    // Left Button Click
                    if (UnityEngine.Input.GetMouseButtonUp(0)) {
                        // Spawn Currently Selected Particle System
                        this.SpawnCurrentParticleEffect();
                    }
                }

                if (UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode.A)) {
                    this.SelectPreviousPE();
                }
                if (UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode.D)) {
                    this.SelectNextPE();
                }
            },
            /*UICanvasManager.Update end.*/

            /*UICanvasManager.UpdateToolTip start.*/
            UpdateToolTip: function (toolTipType) {
if ( TRACE ) { TRACE( "UICanvasManager#UpdateToolTip", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ToolTipText, null)) {
                    if (toolTipType === ButtonTypes.Previous) {
                        this.ToolTipText.text = "Select Previous Particle Effect";
                    } else if (toolTipType === ButtonTypes.Next) {
                        this.ToolTipText.text = "Select Next Particle Effect";
                    }
                }
            },
            /*UICanvasManager.UpdateToolTip end.*/

            /*UICanvasManager.ClearToolTip start.*/
            ClearToolTip: function () {
if ( TRACE ) { TRACE( "UICanvasManager#ClearToolTip", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ToolTipText, null)) {
                    this.ToolTipText.text = "";
                }
            },
            /*UICanvasManager.ClearToolTip end.*/

            /*UICanvasManager.SelectPreviousPE start.*/
            SelectPreviousPE: function () {
if ( TRACE ) { TRACE( "UICanvasManager#SelectPreviousPE", this ); }

                // Previous
                ParticleEffectsLibrary.GlobalAccess.PreviousParticleEffect();
                if (UnityEngine.MonoBehaviour.op_Inequality(this.PENameText, null)) {
                    this.PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
                }
            },
            /*UICanvasManager.SelectPreviousPE end.*/

            /*UICanvasManager.SelectNextPE start.*/
            SelectNextPE: function () {
if ( TRACE ) { TRACE( "UICanvasManager#SelectNextPE", this ); }

                // Next
                ParticleEffectsLibrary.GlobalAccess.NextParticleEffect();
                if (UnityEngine.MonoBehaviour.op_Inequality(this.PENameText, null)) {
                    this.PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
                }
            },
            /*UICanvasManager.SelectNextPE end.*/

            /*UICanvasManager.SpawnCurrentParticleEffect start.*/
            SpawnCurrentParticleEffect: function () {
if ( TRACE ) { TRACE( "UICanvasManager#SpawnCurrentParticleEffect", this ); }

                // Spawn Particle Effect
                var mouseRay = UnityEngine.Camera.main.ScreenPointToRay(UnityEngine.Input.mousePosition.$clone());
                if (UnityEngine.Physics.Raycast$1(mouseRay, Bridge.ref(this, "rayHit"))) {
                    ParticleEffectsLibrary.GlobalAccess.SpawnParticleEffect(this.rayHit.point.$clone());
                }
            },
            /*UICanvasManager.SpawnCurrentParticleEffect end.*/

            /*UICanvasManager.UIButtonClick start.*/
            /**
             * User interfaces the button click.
             *
             * @instance
             * @public
             * @this UICanvasManager
             * @memberof UICanvasManager
             * @param   {ButtonTypes}    buttonTypeClicked    Button type clicked.
             * @return  {void}
             */
            UIButtonClick: function (buttonTypeClicked) {
if ( TRACE ) { TRACE( "UICanvasManager#UIButtonClick", this ); }

                switch (buttonTypeClicked) {
                    case ButtonTypes.Previous: 
                        // Select Previous Prefab
                        this.SelectPreviousPE();
                        break;
                    case ButtonTypes.Next: 
                        // Select Next Prefab
                        this.SelectNextPE();
                        break;
                    default: 
                        // Nothing
                        break;
                }
            },
            /*UICanvasManager.UIButtonClick end.*/


        }
    });
    /*UICanvasManager end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPairComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.AnimationStateData.AnimationPair)],
        $kind: "nested class",
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#init", this ); }

                    this.Instance = new Spine.AnimationStateData.AnimationPairComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", this ); }

                return Bridge.referenceEquals(x.a1, y.a1) && Bridge.referenceEquals(x.a2, y.a2);
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 end.*/

            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2: function (obj) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", this ); }

                // from Tuple.CombineHashCodes // return (((h1 << 5) + h1) ^ h2);
                var h1 = Bridge.getHashCode(obj.a1);
                return (((((h1 << 5) + h1) | 0)) ^ Bridge.getHashCode(obj.a2));
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 end.*/


        }
    });
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    Bridge.define("Spine.Atlas", {
        inherits: [System.Collections.Generic.IEnumerable$1(Spine.AtlasRegion)],
        statics: {
            methods: {
                /*Spine.Atlas.ReadValue:static start.*/
                ReadValue: function (reader) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadValue", this ); }

                    var line = reader.ReadLine();
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        throw new System.Exception("Invalid line: " + (line || ""));
                    }
                    return line.substr(((colon + 1) | 0)).trim();
                },
                /*Spine.Atlas.ReadValue:static end.*/

                /*Spine.Atlas.ReadTuple:static start.*/
                /**
                 * Returns the number of tuple values read (1, 2 or 4).
                 *
                 * @static
                 * @private
                 * @this Spine.Atlas
                 * @memberof Spine.Atlas
                 * @param   {System.IO.TextReader}    reader    
                 * @param   {Array.<string>}          tuple
                 * @return  {number}
                 */
                ReadTuple: function (reader, tuple) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadTuple", this ); }

                    var line = reader.ReadLine();
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        throw new System.Exception("Invalid line: " + (line || ""));
                    }
                    var i = 0, lastMatch = (colon + 1) | 0;
                    for (; i < 3; i = (i + 1) | 0) {
                        var comma = System.String.indexOf(line, String.fromCharCode(44), lastMatch);
                        if (comma === -1) {
                            break;
                        }
                        tuple[i] = line.substr(lastMatch, ((comma - lastMatch) | 0)).trim();
                        lastMatch = (comma + 1) | 0;
                    }
                    tuple[i] = line.substr(lastMatch).trim();
                    return ((i + 1) | 0);
                },
                /*Spine.Atlas.ReadTuple:static end.*/


            }
        },
        fields: {
            pages: null,
            regions: null,
            textureLoader: null
        },
        props: {
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Regions#get", this ); }

                    return this.regions;
                }
            },
            Pages: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Pages#get", this ); }

                    return this.pages;
                }
            }
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$Spine$AtlasRegion$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#init", this ); }

                this.pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                this.regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
            },
            $ctor1: function (reader, dir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#$ctor1", this ); }

                this.$initialize();
                this.Load(reader, dir, textureLoader);
            },
            ctor: function (pages, regions) {
if ( TRACE ) { TRACE( "Spine.Atlas#ctor", this ); }

                this.$initialize();
                this.pages = pages;
                this.regions = regions;
                this.textureLoader = null;
            }
        },
        methods: {
            /*Spine.Atlas.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.GetEnumerator end.*/

            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Atlas.Load start.*/
            Load: function (reader, imagesDir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#Load", this ); }

                if (textureLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("textureLoader", "textureLoader cannot be null.");
                }
                this.textureLoader = textureLoader;

                var tuple = System.Array.init(4, null, System.String);
                var page = null;
                while (true) {
                    var line = reader.ReadLine();
                    if (line == null) {
                        break;
                    }
                    if (line.trim().length === 0) {
                        page = null;
                    } else {
                        if (page == null) {
                            page = new Spine.AtlasPage();
                            page.name = line;

                            if (Spine.Atlas.ReadTuple(reader, tuple) === 2) { // size is only optional for an atlas packed with an old TexturePacker.
                                page.width = System.Int32.parse(tuple[0]);
                                page.height = System.Int32.parse(tuple[1]);
                                Spine.Atlas.ReadTuple(reader, tuple);
                            }
                            page.format = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Format, tuple[0], false), Spine.Format), System.Int32));

                            Spine.Atlas.ReadTuple(reader, tuple);
                            page.minFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, tuple[0], false), Spine.TextureFilter), System.Int32));
                            page.magFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, tuple[1], false), Spine.TextureFilter), System.Int32));

                            var direction = Spine.Atlas.ReadValue(reader);
                            page.uWrap = Spine.TextureWrap.ClampToEdge;
                            page.vWrap = Spine.TextureWrap.ClampToEdge;
                            if (Bridge.referenceEquals(direction, "x")) {
                                page.uWrap = Spine.TextureWrap.Repeat;
                            } else {
                                if (Bridge.referenceEquals(direction, "y")) {
                                    page.vWrap = Spine.TextureWrap.Repeat;
                                } else {
                                    if (Bridge.referenceEquals(direction, "xy")) {
                                        page.uWrap = (page.vWrap = Spine.TextureWrap.Repeat);
                                    }
                                }
                            }

                            textureLoader.Spine$TextureLoader$Load(page, System.IO.Path.Combine(imagesDir, line));

                            this.pages.add(page);

                        } else {
                            var region = new Spine.AtlasRegion();
                            region.name = line;
                            region.page = page;

                            var rotateValue = Spine.Atlas.ReadValue(reader);
                            if (Bridge.referenceEquals(rotateValue, "true")) {
                                region.degrees = 90;
                            } else {
                                if (Bridge.referenceEquals(rotateValue, "false")) {
                                    region.degrees = 0;
                                } else {
                                    region.degrees = System.Int32.parse(rotateValue);
                                }
                            }
                            region.rotate = region.degrees === 90;

                            Spine.Atlas.ReadTuple(reader, tuple);
                            var x = System.Int32.parse(tuple[0]);
                            var y = System.Int32.parse(tuple[1]);

                            Spine.Atlas.ReadTuple(reader, tuple);
                            var width = System.Int32.parse(tuple[0]);
                            var height = System.Int32.parse(tuple[1]);

                            region.u = x / page.width;
                            region.v = y / page.height;
                            if (region.rotate) {
                                region.u2 = (((x + height) | 0)) / page.width;
                                region.v2 = (((y + width) | 0)) / page.height;
                            } else {
                                region.u2 = (((x + width) | 0)) / page.width;
                                region.v2 = (((y + height) | 0)) / page.height;
                            }
                            region.x = x;
                            region.y = y;
                            region.width = Math.abs(width);
                            region.height = Math.abs(height);

                            if (Spine.Atlas.ReadTuple(reader, tuple) === 4) { // split is optional
                                region.splits = System.Array.init([System.Int32.parse(tuple[0]), System.Int32.parse(tuple[1]), System.Int32.parse(tuple[2]), System.Int32.parse(tuple[3])], System.Int32);

                                if (Spine.Atlas.ReadTuple(reader, tuple) === 4) { // pad is optional, but only present with splits
                                    region.pads = System.Array.init([System.Int32.parse(tuple[0]), System.Int32.parse(tuple[1]), System.Int32.parse(tuple[2]), System.Int32.parse(tuple[3])], System.Int32);

                                    Spine.Atlas.ReadTuple(reader, tuple);
                                }
                            }

                            region.originalWidth = System.Int32.parse(tuple[0]);
                            region.originalHeight = System.Int32.parse(tuple[1]);

                            Spine.Atlas.ReadTuple(reader, tuple);
                            region.offsetX = System.Int32.parse(tuple[0]);
                            region.offsetY = System.Int32.parse(tuple[1]);

                            region.index = System.Int32.parse(Spine.Atlas.ReadValue(reader));

                            this.regions.add(region);
                        }
                    }
                }
            },
            /*Spine.Atlas.Load end.*/

            /*Spine.Atlas.FlipV start.*/
            FlipV: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#FlipV", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    var region = this.regions.getItem(i);
                    region.v = 1 - region.v;
                    region.v2 = 1 - region.v2;
                }
            },
            /*Spine.Atlas.FlipV end.*/

            /*Spine.Atlas.FindRegion start.*/
            /**
             * Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
             should be cached rather than calling this method multiple times.
             *
             * @instance
             * @public
             * @this Spine.Atlas
             * @memberof Spine.Atlas
             * @param   {string}               name
             * @return  {Spine.AtlasRegion}            The region, or null.
             */
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.Atlas#FindRegion", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.regions.getItem(i).name, name)) {
                        return this.regions.getItem(i);
                    }
                }
                return null;
            },
            /*Spine.Atlas.FindRegion end.*/

            /*Spine.Atlas.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Dispose", this ); }

                if (this.textureLoader == null) {
                    return;
                }
                for (var i = 0, n = this.pages.Count; i < n; i = (i + 1) | 0) {
                    this.textureLoader.Spine$TextureLoader$Unload(this.pages.getItem(i).rendererObject);
                }
            },
            /*Spine.Atlas.Dispose end.*/


        }
    });
    /*Spine.Atlas end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    /**
     * An AttachmentLoader that configures attachments using texture regions from an Atlas.
     See <a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data">Loading Skeleton Data</a> in the Spine Runtimes Guide.
     *
     * @public
     * @class Spine.AtlasAttachmentLoader
     * @implements  Spine.AttachmentLoader
     */
    Bridge.define("Spine.AtlasAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        fields: {
            atlasArray: null
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        ctors: {
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                if (atlasArray == null) {
                    throw new System.ArgumentNullException.$ctor1("atlas array cannot be null.");
                }
                this.atlasArray = atlasArray;
            }
        },
        methods: {
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewRegionAttachment", this ); }

                var region = this.FindRegion(path);
                if (region == null) {
                    throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                }
                var attachment = new Spine.RegionAttachment(name);
                attachment.RendererObject = region;
                attachment.SetUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                attachment.regionOffsetX = region.offsetX;
                attachment.regionOffsetY = region.offsetY;
                attachment.regionWidth = region.width;
                attachment.regionHeight = region.height;
                attachment.regionOriginalWidth = region.originalWidth;
                attachment.regionOriginalHeight = region.originalHeight;
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewMeshAttachment", this ); }

                var region = this.FindRegion(path);
                if (region == null) {
                    throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                }
                var attachment = new Spine.MeshAttachment(name);
                attachment.RendererObject = region;
                attachment.RegionU = region.u;
                attachment.RegionV = region.v;
                attachment.RegionU2 = region.u2;
                attachment.RegionV2 = region.v2;
                attachment.RegionRotate = region.rotate;
                attachment.RegionDegrees = region.degrees;
                attachment.regionOffsetX = region.offsetX;
                attachment.regionOffsetY = region.offsetY;
                attachment.regionWidth = region.width;
                attachment.regionHeight = region.height;
                attachment.regionOriginalWidth = region.originalWidth;
                attachment.regionOriginalHeight = region.originalHeight;
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPathAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPointAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment(name);
            },
            /*Spine.AtlasAttachmentLoader.NewClippingAttachment end.*/

            /*Spine.AtlasAttachmentLoader.FindRegion start.*/
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#FindRegion", this ); }

                var region;

                for (var i = 0; i < this.atlasArray.length; i = (i + 1) | 0) {
                    region = this.atlasArray[i].FindRegion(name);
                    if (region != null) {
                        return region;
                    }
                }

                return null;
            },
            /*Spine.AtlasAttachmentLoader.FindRegion end.*/


        }
    });
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.AttachmentTimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.AttachmentTimeline
     * @implements  Spine.Timeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.AttachmentTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            frames: null,
            attachmentNames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#PropertyId#get", this ); }

                    return (((67108864) + this.slotIndex) | 0);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AttachmentTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.AttachmentTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The attachment name for each key frame. May contain null values to clear the attachment.
             *
             * @instance
             * @public
             * @memberof Spine.AttachmentTimeline
             * @function AttachmentNames
             * @type Array.<string>
             */
            AttachmentNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#get", this ); }

                    return this.attachmentNames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#set", this ); }

                    this.attachmentNames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.attachmentNames = System.Array.init(frameCount, null, System.String);
            }
        },
        methods: {
            /*Spine.AttachmentTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the attachment name for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.AttachmentTimeline
             * @memberof Spine.AttachmentTimeline
             * @param   {number}    frameIndex        
             * @param   {number}    time              
             * @param   {string}    attachmentName
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.attachmentNames[frameIndex] = attachmentName;
            },
            /*Spine.AttachmentTimeline.SetFrame end.*/

            /*Spine.AttachmentTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                var frameIndex;
                if (time >= frames[((frames.length - 1) | 0)]) {
                    frameIndex = (frames.length - 1) | 0;
                } else {
                    frameIndex = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                }

                this.SetAttachment(skeleton, slot, this.attachmentNames[frameIndex]);
            },
            /*Spine.AttachmentTimeline.Apply end.*/

            /*Spine.AttachmentTimeline.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(this.slotIndex, attachmentName);
            },
            /*Spine.AttachmentTimeline.SetAttachment end.*/


        }
    });
    /*Spine.AttachmentTimeline end.*/

    /*Spine.Bone start.*/
    /**
     * Stores a bone's current pose.
     <p>A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a
     local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a
     constraint or application code modifies the world transform after it was computed from the local transform.</p>
     *
     * @public
     * @class Spine.Bone
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.Bone", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                yDown: false
            }
        },
        fields: {
            data: null,
            skeleton: null,
            parent: null,
            children: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            ax: 0,
            ay: 0,
            arotation: 0,
            ascaleX: 0,
            ascaleY: 0,
            ashearX: 0,
            ashearY: 0,
            appliedValid: false,
            a: 0,
            b: 0,
            worldX: 0,
            c: 0,
            d: 0,
            worldY: 0,
            sorted: false,
            active: false
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Data#get", this ); }

                    return this.data;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Skeleton#get", this ); }

                    return this.skeleton;
                }
            },
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Parent#get", this ); }

                    return this.parent;
                }
            },
            Children: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Children#get", this ); }

                    return this.children;
                }
            },
            /**
             * Returns false when the bone has not been computed because {@link } is true and the
             {@link } does not {@link } this bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function Active
             * @type boolean
             */
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * The local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * The local rotation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * The local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * The local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * The local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * The local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * The rotation, as calculated by any constraints.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AppliedRotation
             * @type number
             */
            AppliedRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#get", this ); }

                    return this.arotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#set", this ); }

                    this.arotation = value;
                }
            },
            /**
             * The applied local x translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AX
             * @type number
             */
            AX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AX#get", this ); }

                    return this.ax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AX#set", this ); }

                    this.ax = value;
                }
            },
            /**
             * The applied local y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AY
             * @type number
             */
            AY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AY#get", this ); }

                    return this.ay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AY#set", this ); }

                    this.ay = value;
                }
            },
            /**
             * The applied local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleX
             * @type number
             */
            AScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#get", this ); }

                    return this.ascaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#set", this ); }

                    this.ascaleX = value;
                }
            },
            /**
             * The applied local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleY
             * @type number
             */
            AScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#get", this ); }

                    return this.ascaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#set", this ); }

                    this.ascaleY = value;
                }
            },
            /**
             * The applied local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearX
             * @type number
             */
            AShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#get", this ); }

                    return this.ashearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#set", this ); }

                    this.ashearX = value;
                }
            },
            /**
             * The applied local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearY
             * @type number
             */
            AShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#get", this ); }

                    return this.ashearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#set", this ); }

                    this.ashearY = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#A#get", this ); }

                    return this.a;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#B#get", this ); }

                    return this.b;
                }
            },
            C: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#C#get", this ); }

                    return this.c;
                }
            },
            D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#D#get", this ); }

                    return this.d;
                }
            },
            WorldX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#get", this ); }

                    return this.worldX;
                }
            },
            WorldY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#get", this ); }

                    return this.worldY;
                }
            },
            WorldRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationX#get", this ); }

                    return Spine.MathUtils.Atan2(this.c, this.a) * Spine.MathUtils.RadDeg;
                }
            },
            WorldRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationY#get", this ); }

                    return Spine.MathUtils.Atan2(this.d, this.b) * Spine.MathUtils.RadDeg;
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale X.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleX
             * @type number
             */
            WorldScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleX#get", this ); }

                    return Math.sqrt(this.a * this.a + this.c * this.c);
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale Y.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleY
             * @type number
             */
            WorldScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleY#get", this ); }

                    return Math.sqrt(this.b * this.b + this.d * this.d);
                }
            },
            WorldToLocalRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationX#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, a = this.a, c = this.c;
                    return Spine.MathUtils.Atan2(pa * c - pc * a, pd * a - pb * c) * Spine.MathUtils.RadDeg;
                }
            },
            WorldToLocalRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationY#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, b = this.b, d = this.d;
                    return Spine.MathUtils.Atan2(pa * d - pc * b, pd * b - pb * d) * Spine.MathUtils.RadDeg;
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Bone#init", this ); }

                this.children = new (Spine.ExposedList$1(Spine.Bone)).ctor();
            },
            /**
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {Spine.BoneData}    data        
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Bone}        parent      May be null.
             * @return  {void}
             */
            ctor: function (data, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.SetToSetupPose();
            }
        },
        methods: {
            /*Spine.Bone.Update start.*/
            /**
             * Same as {@link }. This method exists for Bone to implement {@link }.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Update", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.Update end.*/

            /*Spine.Bone.UpdateWorldTransform start.*/
            /**
             * Computes the world transform using the parent bone and this bone's local transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.UpdateWorldTransform end.*/

            /*Spine.Bone.UpdateWorldTransform$1 start.*/
            /**
             * Computes the world transform using the parent bone and the specified local transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    x           
             * @param   {number}    y           
             * @param   {number}    rotation    
             * @param   {number}    scaleX      
             * @param   {number}    scaleY      
             * @param   {number}    shearX      
             * @param   {number}    shearY
             * @return  {void}
             */
            UpdateWorldTransform$1: function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform$1", this ); }

                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;
                this.appliedValid = true;
                var skeleton = this.skeleton;

                var parent = this.parent;
                if (parent == null) { // Root bone.
                    var rotationY = rotation + 90 + shearY, sx = skeleton.ScaleX, sy = skeleton.ScaleY;
                    this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX * sx;
                    this.b = Spine.MathUtils.CosDeg(rotationY) * scaleY * sx;
                    this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX * sy;
                    this.d = Spine.MathUtils.SinDeg(rotationY) * scaleY * sy;
                    this.worldX = x * sx + skeleton.x;
                    this.worldY = y * sy + skeleton.y;
                    return;
                }

                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                this.worldX = pa * x + pb * y + parent.worldX;
                this.worldY = pc * x + pd * y + parent.worldY;

                switch (this.data.transformMode) {
                    case Spine.TransformMode.Normal: 
                        {
                            var rotationY1 = rotation + 90 + shearY;
                            var la = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            var lb = Spine.MathUtils.CosDeg(rotationY1) * scaleY;
                            var lc = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            var ld = Spine.MathUtils.SinDeg(rotationY1) * scaleY;
                            this.a = pa * la + pb * lc;
                            this.b = pa * lb + pb * ld;
                            this.c = pc * la + pd * lc;
                            this.d = pc * lb + pd * ld;
                            return;
                        }
                    case Spine.TransformMode.OnlyTranslation: 
                        {
                            var rotationY2 = rotation + 90 + shearY;
                            this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            this.b = Spine.MathUtils.CosDeg(rotationY2) * scaleY;
                            this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            this.d = Spine.MathUtils.SinDeg(rotationY2) * scaleY;
                            break;
                        }
                    case Spine.TransformMode.NoRotationOrReflection: 
                        {
                            var s = pa * pa + pc * pc, prx;
                            if (s > 0.0001) {
                                s = Math.abs(pa * pd - pb * pc) / s;
                                pa /= skeleton.ScaleX;
                                pc /= skeleton.ScaleY;
                                pb = pc * s;
                                pd = pa * s;
                                prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                            } else {
                                pa = 0;
                                pc = 0;
                                prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                            }
                            var rx = rotation + shearX - prx;
                            var ry = rotation + shearY - prx + 90;
                            var la1 = Spine.MathUtils.CosDeg(rx) * scaleX;
                            var lb1 = Spine.MathUtils.CosDeg(ry) * scaleY;
                            var lc1 = Spine.MathUtils.SinDeg(rx) * scaleX;
                            var ld1 = Spine.MathUtils.SinDeg(ry) * scaleY;
                            this.a = pa * la1 - pb * lc1;
                            this.b = pa * lb1 - pb * ld1;
                            this.c = pc * la1 + pd * lc1;
                            this.d = pc * lb1 + pd * ld1;
                            break;
                        }
                    case Spine.TransformMode.NoScale: 
                    case Spine.TransformMode.NoScaleOrReflection: 
                        {
                            var cos = Spine.MathUtils.CosDeg(rotation), sin = Spine.MathUtils.SinDeg(rotation);
                            var za = (pa * cos + pb * sin) / skeleton.ScaleX;
                            var zc = (pc * cos + pd * sin) / skeleton.ScaleY;
                            var s1 = Math.sqrt(za * za + zc * zc);
                            if (s1 > 1E-05) {
                                s1 = 1 / s1;
                            }
                            za *= s1;
                            zc *= s1;
                            s1 = Math.sqrt(za * za + zc * zc);
                            if (this.data.transformMode === Spine.TransformMode.NoScale && (pa * pd - pb * pc < 0) !== (skeleton.ScaleX < 0 !== skeleton.ScaleY < 0)) {
                                s1 = -s1;
                            }

                            var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                            var zb = Spine.MathUtils.Cos(r) * s1;
                            var zd = Spine.MathUtils.Sin(r) * s1;
                            var la2 = Spine.MathUtils.CosDeg(shearX) * scaleX;
                            var lb2 = Spine.MathUtils.CosDeg(90 + shearY) * scaleY;
                            var lc2 = Spine.MathUtils.SinDeg(shearX) * scaleX;
                            var ld2 = Spine.MathUtils.SinDeg(90 + shearY) * scaleY;
                            this.a = za * la2 + zb * lc2;
                            this.b = za * lb2 + zb * ld2;
                            this.c = zc * la2 + zd * lc2;
                            this.d = zc * lb2 + zd * ld2;
                            break;
                        }
                }

                this.a *= skeleton.ScaleX;
                this.b *= skeleton.ScaleX;
                this.c *= skeleton.ScaleY;
                this.d *= skeleton.ScaleY;
            },
            /*Spine.Bone.UpdateWorldTransform$1 end.*/

            /*Spine.Bone.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Bone#SetToSetupPose", this ); }

                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.scaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY;
            },
            /*Spine.Bone.SetToSetupPose end.*/

            /*Spine.Bone.UpdateAppliedTransform start.*/
            /**
             * Computes the individual applied transform values from the world transform. This can be useful to perform processing using
             the applied transform after the world transform has been modified directly (eg, by a constraint)..
             Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation.
             *
             * @instance
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateAppliedTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateAppliedTransform", this ); }

                this.appliedValid = true;
                var parent = this.parent;
                if (parent == null) {
                    this.ax = this.worldX;
                    this.ay = this.worldY;
                    this.arotation = Spine.MathUtils.Atan2(this.c, this.a) * Spine.MathUtils.RadDeg;
                    this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
                    this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
                    this.ashearX = 0;
                    this.ashearY = Spine.MathUtils.Atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * Spine.MathUtils.RadDeg;
                    return;
                }
                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                var pid = 1 / (pa * pd - pb * pc);
                var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
                this.ax = (dx * pd * pid - dy * pb * pid);
                this.ay = (dy * pa * pid - dx * pc * pid);
                var ia = pid * pd;
                var id = pid * pa;
                var ib = pid * pb;
                var ic = pid * pc;
                var ra = ia * this.a - ib * this.c;
                var rb = ia * this.b - ib * this.d;
                var rc = id * this.c - ic * this.a;
                var rd = id * this.d - ic * this.b;
                this.ashearX = 0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Spine.MathUtils.Atan2(ra * rb + rc * rd, det) * Spine.MathUtils.RadDeg;
                    this.arotation = Spine.MathUtils.Atan2(rc, ra) * Spine.MathUtils.RadDeg;
                } else {
                    this.ascaleX = 0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Spine.MathUtils.Atan2(rd, rb) * Spine.MathUtils.RadDeg;
                }
            },
            /*Spine.Bone.UpdateAppliedTransform end.*/

            /*Spine.Bone.WorldToLocal start.*/
            WorldToLocal: function (worldX, worldY, localX, localY) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocal", this ); }

                var a = this.a, b = this.b, c = this.c, d = this.d;
                var invDet = 1 / (a * d - b * c);
                var x = worldX - this.worldX, y = worldY - this.worldY;
                localX.v = (x * d * invDet - y * b * invDet);
                localY.v = (y * a * invDet - x * c * invDet);
            },
            /*Spine.Bone.WorldToLocal end.*/

            /*Spine.Bone.LocalToWorld start.*/
            LocalToWorld: function (localX, localY, worldX, worldY) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorld", this ); }

                worldX.v = localX * this.a + localY * this.b + this.worldX;
                worldY.v = localX * this.c + localY * this.d + this.worldY;
            },
            /*Spine.Bone.LocalToWorld end.*/

            /*Spine.Bone.WorldToLocalRotation start.*/
            WorldToLocalRotation: function (worldRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotation", this ); }

                var sin = Spine.MathUtils.SinDeg(worldRotation), cos = Spine.MathUtils.CosDeg(worldRotation);
                return Spine.MathUtils.Atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * Spine.MathUtils.RadDeg + this.rotation - this.shearX;
            },
            /*Spine.Bone.WorldToLocalRotation end.*/

            /*Spine.Bone.LocalToWorldRotation start.*/
            LocalToWorldRotation: function (localRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorldRotation", this ); }

                localRotation -= this.rotation - this.shearX;
                var sin = Spine.MathUtils.SinDeg(localRotation), cos = Spine.MathUtils.CosDeg(localRotation);
                return Spine.MathUtils.Atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * Spine.MathUtils.RadDeg;
            },
            /*Spine.Bone.LocalToWorldRotation end.*/

            /*Spine.Bone.RotateWorld start.*/
            /**
             * Rotates the world transform the specified amount and sets isAppliedValid to false.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    degrees    Degrees.
             * @return  {void}
             */
            RotateWorld: function (degrees) {
if ( TRACE ) { TRACE( "Spine.Bone#RotateWorld", this ); }

                var a = this.a, b = this.b, c = this.c, d = this.d;
                var cos = Spine.MathUtils.CosDeg(degrees), sin = Spine.MathUtils.SinDeg(degrees);
                this.a = cos * a - sin * c;
                this.b = cos * b - sin * d;
                this.c = sin * a + cos * c;
                this.d = sin * b + cos * d;
                this.appliedValid = false;
            },
            /*Spine.Bone.RotateWorld end.*/

            /*Spine.Bone.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Bone#toString", this ); }

                return this.data.name;
            },
            /*Spine.Bone.toString end.*/


        },
        overloads: {
            "UpdateWorldTransform(float, float, float, float, float, float, float)": "UpdateWorldTransform$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Bone end.*/

    /*Spine.VertexAttachment start.*/
    /**
     * &gt;An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's
     {@link }.
     *
     * @abstract
     * @public
     * @class Spine.VertexAttachment
     * @augments Spine.Attachment
     */
    Bridge.define("Spine.VertexAttachment", {
        inherits: [Spine.Attachment],
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            bones: null,
            vertices: null,
            worldVerticesLength: 0,
            deformAttachment: null
        },
        props: {
            /**
             * Gets a unique ID for this attachment.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.VertexAttachment
             * @function Id
             * @type number
             */
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Id#get", this ); }

                    return this.id;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#get", this ); }

                    return this.bones;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#set", this ); }

                    this.bones = value;
                }
            },
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#get", this ); }

                    return this.vertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#set", this ); }

                    this.vertices = value;
                }
            },
            WorldVerticesLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#get", this ); }

                    return this.worldVerticesLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#set", this ); }

                    this.worldVerticesLength = value;
                }
            },
            /**
             * Deform keys for the deform attachment are also applied to this attachment.
             May be null if no deform keys should be applied.
             *
             * @instance
             * @public
             * @memberof Spine.VertexAttachment
             * @function DeformAttachment
             * @type Spine.VertexAttachment
             */
            DeformAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#DeformAttachment#get", this ); }

                    return this.deformAttachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#DeformAttachment#set", this ); }

                    this.deformAttachment = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.ctor.call(this, name);

                this.deformAttachment = this;
                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = (Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t))) & 65535) << 11;
                }
            }
        },
        methods: {
            /*Spine.VertexAttachment.ComputeWorldVertices$1 start.*/
            ComputeWorldVertices$1: function (slot, worldVertices) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices$1", this ); }

                this.ComputeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0);
            },
            /*Spine.VertexAttachment.ComputeWorldVertices$1 end.*/

            /*Spine.VertexAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's local {@link } to world coordinates. If the slot's {@link } is
             not empty, it is used to deform the vertices.
             <p />
             See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
             Runtimes Guide.
             *
             * @instance
             * @public
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.Slot}        slot             
             * @param   {number}            start            The index of the first {@link } value to transform. Each vertex has 2 values, x and y.
             * @param   {number}            count            The number of world vertex values to output. Must be less than or equal to {@link } - start.
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to <b>worldVertices</b> + <b>worldVertices</b>.
             * @param   {number}            offset           The <b>offset</b> index to begin writing values.
             * @param   {number}            stride           The number of <b>stride</b> entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                count = (offset + Bridge.Int.mul((count >> 1), stride)) | 0;
                var skeleton = slot.bone.skeleton;
                var deformArray = slot.deform;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.Count > 0) {
                        vertices = deformArray.Items;
                    }
                    var bone = slot.bone;
                    var x = bone.worldX, y = bone.worldY;
                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    for (var vv = start, w = offset; w < count; vv = (vv + 2) | 0, w = (w + stride) | 0) {
                        var vx = vertices[vv], vy = vertices[((vv + 1) | 0)];
                        worldVertices[w] = vx * a + vy * b + x;
                        worldVertices[((w + 1) | 0)] = vx * c + vy * d + y;
                    }
                    return;
                }
                var v = 0, skip = 0;
                for (var i = 0; i < start; i = (i + 2) | 0) {
                    var n = bones[v];
                    v = (v + (((n + 1) | 0))) | 0;
                    skip = (skip + n) | 0;
                }
                var skeletonBones = skeleton.bones.Items;
                if (deformArray.Count === 0) {
                    for (var w1 = offset, b1 = Bridge.Int.mul(skip, 3); w1 < count; w1 = (w1 + stride) | 0) {
                        var wx = 0, wy = 0;
                        var n1 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n1 = (n1 + v) | 0;
                        for (; v < n1; v = (v + 1) | 0, b1 = (b1 + 3) | 0) {
                            var bone1 = skeletonBones[bones[v]];
                            var vx1 = vertices[b1], vy1 = vertices[((b1 + 1) | 0)], weight = vertices[((b1 + 2) | 0)];
                            wx += (vx1 * bone1.a + vy1 * bone1.b + bone1.worldX) * weight;
                            wy += (vx1 * bone1.c + vy1 * bone1.d + bone1.worldY) * weight;
                        }
                        worldVertices[w1] = wx;
                        worldVertices[((w1 + 1) | 0)] = wy;
                    }
                } else {
                    var deform = deformArray.Items;
                    for (var w2 = offset, b2 = Bridge.Int.mul(skip, 3), f = skip << 1; w2 < count; w2 = (w2 + stride) | 0) {
                        var wx1 = 0, wy1 = 0;
                        var n2 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n2 = (n2 + v) | 0;
                        for (; v < n2; v = (v + 1) | 0, b2 = (b2 + 3) | 0, f = (f + 2) | 0) {
                            var bone2 = skeletonBones[bones[v]];
                            var vx2 = vertices[b2] + deform[f], vy2 = vertices[((b2 + 1) | 0)] + deform[((f + 1) | 0)], weight1 = vertices[((b2 + 2) | 0)];
                            wx1 += (vx2 * bone2.a + vy2 * bone2.b + bone2.worldX) * weight1;
                            wy1 += (vx2 * bone2.c + vy2 * bone2.d + bone2.worldY) * weight1;
                        }
                        worldVertices[w2] = wx1;
                        worldVertices[((w2 + 1) | 0)] = wy1;
                    }
                }
            },
            /*Spine.VertexAttachment.ComputeWorldVertices end.*/

            /*Spine.VertexAttachment.CopyTo start.*/
            /**
             * Does not copy id (generated) or name (set on construction).
             *
             * @instance
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.VertexAttachment}    attachment
             * @return  {void}
             */
            CopyTo: function (attachment) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#CopyTo", this ); }

                if (this.bones != null) {
                    attachment.bones = System.Array.init(this.bones.length, 0, System.Int32);
                    System.Array.copy(this.bones, 0, attachment.bones, 0, this.bones.length);
                } else {
                    attachment.bones = null;
                }

                if (this.vertices != null) {
                    attachment.vertices = System.Array.init(this.vertices.length, 0, System.Single);
                    System.Array.copy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
                } else {
                    attachment.vertices = null;
                }

                attachment.worldVerticesLength = this.worldVerticesLength;
                attachment.deformAttachment = this.deformAttachment;
            },
            /*Spine.VertexAttachment.CopyTo end.*/


        },
        overloads: {
            "ComputeWorldVertices(Slot, float[])": "ComputeWorldVertices$1"
        }
    });
    /*Spine.VertexAttachment end.*/

    /*Spine.CurveTimeline start.*/
    /**
     * The base class for timelines that use interpolation between key frame values.
     *
     * @abstract
     * @public
     * @class Spine.CurveTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.CurveTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                LINEAR: 0,
                STEPPED: 0,
                BEZIER: 0,
                BEZIER_SIZE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#init", this ); }

                    this.LINEAR = 0;
                    this.STEPPED = 1;
                    this.BEZIER = 2;
                    this.BEZIER_SIZE = 19;
                }
            }
        },
        fields: {
            curves: null
        },
        props: {
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.CurveTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#FrameCount#get", this ); }

                    return ((((Bridge.Int.div(this.curves.length, Spine.CurveTimeline.BEZIER_SIZE)) | 0) + 1) | 0);
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#ctor", this ); }

                this.$initialize();
                if (frameCount <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("frameCount must be > 0: ");
                }
                this.curves = System.Array.init(Bridge.Int.mul((((frameCount - 1) | 0)), Spine.CurveTimeline.BEZIER_SIZE), 0, System.Single);
            }
        },
        methods: {
            /*Spine.CurveTimeline.SetLinear start.*/
            /**
             * Sets the specified key frame to linear interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {void}
             */
            SetLinear: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetLinear", this ); }

                this.curves[Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE)] = Spine.CurveTimeline.LINEAR;
            },
            /*Spine.CurveTimeline.SetLinear end.*/

            /*Spine.CurveTimeline.SetStepped start.*/
            /**
             * Sets the specified key frame to stepped interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {void}
             */
            SetStepped: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetStepped", this ); }

                this.curves[Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE)] = Spine.CurveTimeline.STEPPED;
            },
            /*Spine.CurveTimeline.SetStepped end.*/

            /*Spine.CurveTimeline.GetCurveType start.*/
            /**
             * Returns the interpolation type for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex
             * @return  {number}                  Linear is 0, stepped is 1, Bezier is 2.
             */
            GetCurveType: function (frameIndex) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurveType", this ); }

                var index = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                if (index === this.curves.length) {
                    return Spine.CurveTimeline.LINEAR;
                }
                var type = this.curves[index];
                if (type === Spine.CurveTimeline.LINEAR) {
                    return Spine.CurveTimeline.LINEAR;
                }
                if (type === Spine.CurveTimeline.STEPPED) {
                    return Spine.CurveTimeline.STEPPED;
                }
                return Spine.CurveTimeline.BEZIER;
            },
            /*Spine.CurveTimeline.GetCurveType end.*/

            /*Spine.CurveTimeline.SetCurve start.*/
            /**
             * Sets the specified key frame to Bezier interpolation. <pre><code>cx1</code></pre> and <pre><code>cx2</code></pre> are from 0 to 1,
             representing the percent of time between the two key frames. <pre><code>cy1</code></pre> and <pre><code>cy2</code></pre> are the percent of the
             difference between the key frame's values.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    cx1           
             * @param   {number}    cy1           
             * @param   {number}    cx2           
             * @param   {number}    cy2
             * @return  {void}
             */
            SetCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetCurve", this ); }

                var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
                var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.166666672, dfy = cy1 * 0.3 + tmpy + dddfy * 0.166666672;

                var i = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                var curves = this.curves;
                curves[Bridge.identity(i, ((i = (i + 1) | 0)))] = Spine.CurveTimeline.BEZIER;

                var x = dfx, y = dfy;
                for (var n = (((i + Spine.CurveTimeline.BEZIER_SIZE) | 0) - 1) | 0; i < n; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    x += dfx;
                    y += dfy;
                }
            },
            /*Spine.CurveTimeline.SetCurve end.*/

            /*Spine.CurveTimeline.GetCurvePercent start.*/
            /**
             * Returns the interpolated percentage for the specified key frame and linear percentage.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    percent
             * @return  {number}
             */
            GetCurvePercent: function (frameIndex, percent) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurvePercent", this ); }

                percent = Spine.MathUtils.Clamp(percent, 0, 1);
                var curves = this.curves;
                var i = Bridge.Int.mul(frameIndex, Spine.CurveTimeline.BEZIER_SIZE);
                var type = curves[i];
                if (type === Spine.CurveTimeline.LINEAR) {
                    return percent;
                }
                if (type === Spine.CurveTimeline.STEPPED) {
                    return 0;
                }
                i = (i + 1) | 0;
                var x = 0;
                for (var start = i, n = (((i + Spine.CurveTimeline.BEZIER_SIZE) | 0) - 1) | 0; i < n; i = (i + 2) | 0) {
                    x = curves[i];
                    if (x >= percent) {
                        if (i === start) {
                            return curves[((i + 1) | 0)] * percent / x;
                        } // First point is 0,0.
                        var prevX = curves[((i - 2) | 0)], prevY = curves[((i - 1) | 0)];
                        return prevY + (curves[((i + 1) | 0)] - prevY) * (percent - prevX) / (x - prevX);
                    }
                }
                var y = curves[((i - 1) | 0)];
                return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
            },
            /*Spine.CurveTimeline.GetCurvePercent end.*/


        }
    });
    /*Spine.CurveTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    /**
     * Changes a skeleton's {@link }.
     *
     * @public
     * @class Spine.DrawOrderTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.DrawOrderTimeline", {
        inherits: [Spine.Timeline],
        fields: {
            frames: null,
            drawOrders: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#PropertyId#get", this ); }

                    return (134217728);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.DrawOrderTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DrawOrderTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The draw order for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DrawOrderTimeline
             * @function DrawOrders
             * @type Array.<Array.<number>>
             * @see {@link Timeline.setFrame(int, float, int[])}
             */
            DrawOrders: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#get", this ); }

                    return this.drawOrders;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#set", this ); }

                    this.drawOrders = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.drawOrders = System.Array.init(frameCount, null, System.Array.type(System.Int32));
            }
        },
        methods: {
            /*Spine.DrawOrderTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the draw order for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.DrawOrderTimeline
             * @memberof Spine.DrawOrderTimeline
             * @param   {number}            frameIndex    
             * @param   {number}            time          
             * @param   {Array.<number>}    drawOrder     For each slot in {@link } the index of the new draw order. May be null to use setup pose
                             draw order..
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, drawOrder) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.drawOrders[frameIndex] = drawOrder;
            },
            /*Spine.DrawOrderTimeline.SetFrame end.*/

            /*Spine.DrawOrderTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Apply", this ); }

                var drawOrder = skeleton.drawOrder;
                var slots = skeleton.slots;
                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                    }
                    return;
                }

                var frame;
                if (time >= frames[((frames.length - 1) | 0)]) {
                    frame = (frames.length - 1) | 0;
                } else {
                    frame = (Spine.Animation.BinarySearch(frames, time) - 1) | 0;
                }

                var drawOrderToSetupIndex = this.drawOrders[frame];
                if (drawOrderToSetupIndex == null) {
                    System.Array.copy(slots.Items, 0, drawOrder.Items, 0, slots.Count);
                } else {
                    var drawOrderItems = drawOrder.Items;
                    var slotsItems = slots.Items;
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i = (i + 1) | 0) {
                        drawOrderItems[i] = slotsItems[drawOrderToSetupIndex[i]];
                    }
                }
            },
            /*Spine.DrawOrderTimeline.Apply end.*/


        }
    });
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.EventTimeline start.*/
    /**
     * Fires an {@link } when specific animation times are reached.
     *
     * @public
     * @class Spine.EventTimeline
     * @implements  Spine.Timeline
     */
    Bridge.define("Spine.EventTimeline", {
        inherits: [Spine.Timeline],
        fields: {
            frames: null,
            events: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#PropertyId#get", this ); }

                    return (117440512);
                }
            },
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventTimeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.EventTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The event for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.EventTimeline
             * @function Events
             * @type Array.<Spine.Event>
             */
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#set", this ); }

                    this.events = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#ctor", this ); }

                this.$initialize();
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.events = System.Array.init(frameCount, null, Spine.Event);
            }
        },
        methods: {
            /*Spine.EventTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the event for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {number}         frameIndex    
             * @param   {Spine.Event}    e
             * @return  {void}
             */
            SetFrame: function (frameIndex, e) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#SetFrame", this ); }

                this.frames[frameIndex] = e.Time;
                this.events[frameIndex] = e;
            },
            /*Spine.EventTimeline.SetFrame end.*/

            /*Spine.EventTimeline.Apply start.*/
            /**
             * Fires events for frames &gt; <pre><code>lastTime</code></pre> and &lt;= <pre><code>time</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {Spine.Skeleton}         skeleton       
             * @param   {number}                 lastTime       
             * @param   {number}                 time           
             * @param   {Spine.ExposedList$1}    firedEvents    
             * @param   {number}                 alpha          
             * @param   {Spine.MixBlend}         blend          
             * @param   {Spine.MixDirection}     direction
             * @return  {void}
             */
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Apply", this ); }

                if (firedEvents == null) {
                    return;
                }
                var frames = this.frames;
                var frameCount = frames.length;

                if (lastTime > time) { // Fire events after last time for looped animations.
                    this.Apply(skeleton, lastTime, 2147483647, firedEvents, alpha, blend, direction);
                    lastTime = -1.0;
                } else if (lastTime >= frames[((frameCount - 1) | 0)]) {
                    return;
                }
                if (time < frames[0]) {
                    return;
                } // Time is before first frame.

                var frame;
                if (lastTime < frames[0]) {
                    frame = 0;
                } else {
                    frame = Spine.Animation.BinarySearch(frames, lastTime);
                    var frameTime = frames[frame];
                    while (frame > 0) { // Fire multiple events with the same frame.
                        if (frames[((frame - 1) | 0)] !== frameTime) {
                            break;
                        }
                        frame = (frame - 1) | 0;
                    }
                }
                for (; frame < frameCount && time >= frames[frame]; frame = (frame + 1) | 0) {
                    firedEvents.Add(this.events[frame]);
                }
            },
            /*Spine.EventTimeline.Apply end.*/


        }
    });
    /*Spine.EventTimeline end.*/

    /*Spine.IkConstraint start.*/
    /**
     * <p>Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of
     the last bone is as close to the target bone as possible.</p><p>See <a href="http://esotericsoftware.com/spine-ik-constraints">IK constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.IkConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.IkConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            methods: {
                /*Spine.IkConstraint.Apply$1:static start.*/
                /**
                 * Applies 1 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    bone        
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {boolean}       compress    
                 * @param   {boolean}       stretch     
                 * @param   {boolean}       uniform     
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply$1: function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply$1", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        p, 
                        pa, 
                        pb, 
                        pc, 
                        pd, 
                        rotationIK, 
                        tx, 
                        ty, 
                        $t, 
                        s, 
                        sa, 
                        sc, 
                        x, 
                        y, 
                        d, 
                        sx, 
                        sy, 
                        b, 
                        dd, 
                        s1, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4], $step);
                                switch ($step) {
                                    case 0: {
                                        if (!bone.appliedValid) {
                                            bone.UpdateAppliedTransform();
                                        }
                                        p = bone.parent;

                                        pa = p.a;
                                        pb = p.b;
                                        pc = p.c;
                                        pd = p.d;
                                        rotationIK = -bone.ashearX - bone.arotation;
                                        tx = 0;
                                        ty = 0;

                                        $t = bone.data.transformMode;
                                        if ($t === Spine.TransformMode.OnlyTranslation) {
                                            $step = 1;
                                            continue;
                                        }
                                        else if ($t === Spine.TransformMode.NoRotationOrReflection) {
                                            $step = 2;
                                            continue;
                                        }
                                        else  {
                                            $step = 3;
                                            continue;
                                        }
                                        $step = 4;
                                        continue;
                                    }
                                    case 1: {
                                        tx = targetX - bone.worldX;
                                        ty = targetY - bone.worldY;
                                        $step = 4;
                                        continue;
                                    }
                                    case 2: {
                                        s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
                                        sa = pa / bone.skeleton.ScaleX;
                                        sc = pc / bone.skeleton.ScaleY;
                                        pb = -sc * s * bone.skeleton.ScaleX;
                                        pd = sa * s * bone.skeleton.ScaleY;
                                        rotationIK += Math.atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                        $step = 3;
                                        continue;// Fall through.
                                    }
                                    case 3: {
                                        x = targetX - p.worldX;
                                        y = targetY - p.worldY;
                                        d = pa * pd - pb * pc;
                                        tx = (x * pd - y * pb) / d - bone.ax;
                                        ty = (y * pa - x * pc) / d - bone.ay;
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        rotationIK += Math.atan2(ty, tx) * Spine.MathUtils.RadDeg;
                                        if (bone.ascaleX < 0) {
                                            rotationIK += 180;
                                        }
                                        if (rotationIK > 180) {
                                            rotationIK -= 360;
                                        } else {
                                            if (rotationIK < -180) {
                                                rotationIK += 360;
                                            }
                                        }

                                        sx = bone.ascaleX;
                                        sy = bone.ascaleY;
                                        if (compress || stretch) {
                                            switch (bone.data.transformMode) {
                                                case Spine.TransformMode.NoScale: 
                                                    tx = targetX - bone.worldX;
                                                    ty = targetY - bone.worldY;
                                                    break;
                                                case Spine.TransformMode.NoScaleOrReflection: 
                                                    tx = targetX - bone.worldX;
                                                    ty = targetY - bone.worldY;
                                                    break;
                                            }
                                            b = bone.data.length * sx;
                                            dd = Math.sqrt(tx * tx + ty * ty);
                                            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {
                                                s1 = (dd / b - 1) * alpha + 1;
                                                sx *= s1;
                                                if (uniform) {
                                                    sy *= s1;
                                                }
                                            }
                                        }
                                        bone.UpdateWorldTransform$1(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply$1:static end.*/

                /*Spine.IkConstraint.Apply:static start.*/
                /**
                 * Applies 2 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    parent      
                 * @param   {Spine.Bone}    child       A direct descendant of the parent bone.
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {number}        bendDir     
                 * @param   {boolean}       stretch     
                 * @param   {number}        softness    
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply: function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        px, 
                        py, 
                        psx, 
                        sx, 
                        psy, 
                        csx, 
                        os1, 
                        os2, 
                        s2, 
                        cx, 
                        cy, 
                        cwx, 
                        cwy, 
                        a, 
                        b, 
                        c, 
                        d, 
                        u, 
                        pp, 
                        id, 
                        x, 
                        y, 
                        dx, 
                        dy, 
                        l1, 
                        l2, 
                        a1, 
                        a2, 
                        tx, 
                        ty, 
                        dd, 
                        td, 
                        sd, 
                        p, 
                        cos, 
                        aa, 
                        bb, 
                        ta, 
                        c1, 
                        c2, 
                        q, 
                        r0, 
                        r1, 
                        r, 
                        minAngle, 
                        minX, 
                        minDist, 
                        minY, 
                        maxAngle, 
                        maxX, 
                        maxDist, 
                        maxY, 
                        os, 
                        rotation, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,6,7,8], $step);
                                switch ($step) {
                                    case 0: {
                                        if (alpha === 0) {
                                            child.UpdateWorldTransform();
                                            return;
                                        }
                                        if (!parent.appliedValid) {
                                            parent.UpdateAppliedTransform();
                                        }
                                        if (!child.appliedValid) {
                                            child.UpdateAppliedTransform();
                                        }
                                        px = parent.ax;
                                        py = parent.ay;
                                        psx = parent.ascaleX;
                                        sx = psx;
                                        psy = parent.ascaleY;
                                        csx = child.ascaleX;
                                        if (psx < 0) {
                                            psx = -psx;
                                            os1 = 180;
                                            s2 = -1;
                                        } else {
                                            os1 = 0;
                                            s2 = 1;
                                        }
                                        if (psy < 0) {
                                            psy = -psy;
                                            s2 = (-s2) | 0;
                                        }
                                        if (csx < 0) {
                                            csx = -csx;
                                            os2 = 180;
                                        } else {
                                            os2 = 0;
                                        }
                                        cx = child.ax;
                                        a = parent.a;
                                        b = parent.b;
                                        c = parent.c;
                                        d = parent.d;
                                        u = Math.abs(psx - psy) <= 0.0001;
                                        if (!u) {
                                            cy = 0;
                                            cwx = a * cx + parent.worldX;
                                            cwy = c * cx + parent.worldY;
                                        } else {
                                            cy = child.ay;
                                            cwx = a * cx + b * cy + parent.worldX;
                                            cwy = c * cx + d * cy + parent.worldY;
                                        }
                                        pp = parent.parent;
                                        a = pp.a;
                                        b = pp.b;
                                        c = pp.c;
                                        d = pp.d;
                                        id = 1 / (a * d - b * c);
                                        x = cwx - pp.worldX;
                                        y = cwy - pp.worldY;
                                        dx = (x * d - y * b) * id - px;
                                        dy = (y * a - x * c) * id - py;
                                        l1 = Math.sqrt(dx * dx + dy * dy);
                                        l2 = child.data.length * csx;
                                        if (l1 < 0.0001) {
                                            Spine.IkConstraint.Apply$1(parent, targetX, targetY, false, stretch, false, alpha);
                                            child.UpdateWorldTransform$1(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                            return;
                                        }
                                        x = targetX - pp.worldX;
                                        y = targetY - pp.worldY;
                                        tx = (x * d - y * b) * id - px;
                                        ty = (y * a - x * c) * id - py;
                                        dd = tx * tx + ty * ty;
                                        if (softness !== 0) {
                                            softness *= psx * (csx + 1) / 2;
                                            td = Math.sqrt(dd);
                                            sd = td - l1 - l2 * psx + softness;
                                            if (sd > 0) {
                                                p = Math.min(1, sd / (softness * 2)) - 1;
                                                p = (sd - softness * (1 - p * p)) / td;
                                                tx -= p * tx;
                                                ty -= p * ty;
                                                dd = tx * tx + ty * ty;
                                            }
                                        }
                                        if (u) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 2;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        l2 *= psx;
                                        cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                                        if (cos < -1) {
                                            cos = -1;
                                        } else {
                                            if (cos > 1) {
                                                cos = 1;
                                                if (stretch) {
                                                    sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
                                                }
                                            }
                                        }
                                        a2 = Math.acos(cos) * bendDir;
                                        a = l1 + l2 * cos;
                                        b = l2 * Math.sin(a2);
                                        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        a = psx * l2;
                                        b = psy * l2;
                                        aa = a * a;
                                        bb = b * b;
                                        ta = Math.atan2(ty, tx);
                                        c = bb * l1 * l1 + aa * dd - aa * bb;
                                        c1 = -2 * bb * l1;
                                        c2 = bb - aa;
                                        d = c1 * c1 - 4 * c2 * c;
                                        if (d >= 0) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                    }
                                    case 3: {
                                        q = Math.sqrt(d);
                                        if (c1 < 0) {
                                            q = -q;
                                        }
                                        q = -(c1 + q) / 2;
                                        r0 = q / c2;
                                        r1 = c / q;
                                        r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                                        if (r * r <= dd) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        y = Math.sqrt(dd - r * r) * bendDir;
                                        a1 = ta - Math.atan2(y, r);
                                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                                        $step = 8;
                                        continue;// break outer;
                                        $step = 5;
                                        continue;
                                    }

                                    case 6: {
                                        minAngle = Spine.MathUtils.PI;
                                        minX = l1 - a;
                                        minDist = minX * minX;
                                        minY = 0;
                                        maxAngle = 0;
                                        maxX = l1 + a;
                                        maxDist = maxX * maxX;
                                        maxY = 0;
                                        c = -a * l1 / (aa - bb);
                                        if (c >= -1 && c <= 1) {
                                            c = Math.acos(c);
                                            x = a * Math.cos(c) + l1;
                                            y = b * Math.sin(c);
                                            d = x * x + y * y;
                                            if (d < minDist) {
                                                minAngle = c;
                                                minDist = d;
                                                minX = x;
                                                minY = y;
                                            }
                                            if (d > maxDist) {
                                                maxAngle = c;
                                                maxDist = d;
                                                maxX = x;
                                                maxY = y;
                                            }
                                        }
                                        if (dd <= (minDist + maxDist) / 2) {
                                            a1 = ta - Math.atan2(minY * bendDir, minX);
                                            a2 = minAngle * bendDir;
                                        } else {
                                            a1 = ta - Math.atan2(maxY * bendDir, maxX);
                                            a2 = maxAngle * bendDir;
                                        }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    case 8: {
                                        os = Math.atan2(cy, cx) * s2;
                                        rotation = parent.arotation;
                                        a1 = (a1 - os) * Spine.MathUtils.RadDeg + os1 - rotation;
                                        if (a1 > 180) {
                                            a1 -= 360;
                                        } else {
                                            if (a1 < -180) {
                                                a1 += 360;
                                            }
                                        }
                                        parent.UpdateWorldTransform$1(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
                                        rotation = child.arotation;
                                        a2 = ((a2 + os) * Spine.MathUtils.RadDeg - child.ashearX) * s2 + os2 - rotation;
                                        if (a2 > 180) {
                                            a2 -= 360;
                                        } else {
                                            if (a2 < -180) {
                                                a2 += 360;
                                            }
                                        }
                                        child.UpdateWorldTransform$1(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            mix: 0,
            softness: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this IK constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the distance from the maximum reach of the bones that rotation will slow.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * Controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
              and the parent bone has local nonuniform scale, stretch is not applied.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The IK constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Data
             * @type Spine.IkConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.mix = 1;
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.mix = data.mix;
                this.softness = data.softness;
                this.bendDirection = data.bendDirection;
                this.compress = data.compress;
                this.stretch = data.stretch;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = skeleton.FindBone(data.target.name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.IkConstraint
             * @memberof Spine.IkConstraint
             * @param   {Spine.IkConstraint}    constraint    
             * @param   {Spine.Skeleton}        skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.mix = constraint.mix;
                this.softness = constraint.softness;
                this.bendDirection = constraint.bendDirection;
                this.compress = constraint.compress;
                this.stretch = constraint.stretch;
            }
        },
        methods: {
            /*Spine.IkConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.IkConstraint
             * @memberof Spine.IkConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.IkConstraint.Apply end.*/

            /*Spine.IkConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Update", this ); }

                var target = this.target;
                var bones = this.bones;
                switch (bones.Count) {
                    case 1: 
                        Spine.IkConstraint.Apply$1(bones.Items[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                        break;
                    case 2: 
                        Spine.IkConstraint.Apply(bones.Items[0], bones.Items[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
                        break;
                }
            },
            /*Spine.IkConstraint.Update end.*/

            /*Spine.IkConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.IkConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    /**
     * Stores the setup pose for an IkConstraint.
     *
     * @public
     * @class Spine.IkConstraintData
     * @augments Spine.ConstraintData
     */
    Bridge.define("Spine.IkConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            uniform: false,
            mix: 0,
            softness: 0
        },
        props: {
            /**
             * The bones that are constrained by this IK Constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraintData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Target
             * @type Spine.BoneData
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constraint and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the distance from the maximum reach of the bones that rotation will slow.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * Controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * When true, and only a single bone is being constrained,
             if the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true, if the target is out of range, the parent bone is scaled on the X axis to reach it.
             If the bone has local nonuniform scale, stretching is not applied.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            /**
             * When true, only a single bone is being constrained and Compress or Stretch is used,
             the bone is scaled both on the X and Y axes.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Uniform
             * @type boolean
             */
            Uniform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#get", this ); }

                    return this.uniform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#set", this ); }

                    this.uniform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.bendDirection = 1;
                this.mix = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.IkConstraintData end.*/

    /*Spine.PathConstraint start.*/
    /**
     * <p>Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the
     constrained bones so they follow a {@link PathAttachment}.</p><p>See <a href="http://esotericsoftware.com/spine-path-constraints">Path constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.PathConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.PathConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                NONE: 0,
                BEFORE: 0,
                AFTER: 0,
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                    this.NONE = -1;
                    this.BEFORE = -2;
                    this.AFTER = -3;
                    this.Epsilon = 1E-05;
                }
            },
            methods: {
                /*Spine.PathConstraint.AddBeforePosition:static start.*/
                AddBeforePosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddBeforePosition", this ); }

                    var x1 = temp[i], y1 = temp[((i + 1) | 0)], dx = temp[((i + 2) | 0)] - x1, dy = temp[((i + 3) | 0)] - y1, r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddBeforePosition:static end.*/

                /*Spine.PathConstraint.AddAfterPosition:static start.*/
                AddAfterPosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddAfterPosition", this ); }

                    var x1 = temp[((i + 2) | 0)], y1 = temp[((i + 3) | 0)], dx = x1 - temp[i], dy = y1 - temp[((i + 1) | 0)], r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddAfterPosition:static end.*/

                /*Spine.PathConstraint.AddCurvePosition:static start.*/
                AddCurvePosition: function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddCurvePosition", this ); }

                    if (p < Spine.PathConstraint.Epsilon || isNaN(p)) {
                        output[o] = x1;
                        output[((o + 1) | 0)] = y1;
                        output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        return;
                    }
                    var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
                    var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
                    var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                    output[o] = x;
                    output[((o + 1) | 0)] = y;
                    if (tangents) {
                        if (p < 0.001) {
                            output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        } else {
                            output[((o + 2) | 0)] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
                        }
                    }
                },
                /*Spine.PathConstraint.AddCurvePosition:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            position: 0,
            spacing: 0,
            rotateMix: 0,
            translateMix: 0,
            active: false,
            spaces: null,
            positions: null,
            world: null,
            curves: null,
            lengths: null,
            segments: null
        },
        props: {
            /**
             * The position along the path.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Position
             * @type number
             */
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#set", this ); }

                    this.position = value;
                }
            },
            /**
             * The spacing between bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Spacing
             * @type number
             */
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function RotateMix
             * @type number
             */
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translations.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function TranslateMix
             * @type number
             */
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            /**
             * The bones that will be modified by this path constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The slot whose path attachment will be used to constrained the bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Target
             * @type Spine.Slot
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The path constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Data
             * @type Spine.PathConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                this.spaces = new (Spine.ExposedList$1(System.Single)).ctor();
                this.positions = new (Spine.ExposedList$1(System.Single)).ctor();
                this.world = new (Spine.ExposedList$1(System.Single)).ctor();
                this.curves = new (Spine.ExposedList$1(System.Single)).ctor();
                this.lengths = new (Spine.ExposedList$1(System.Single)).ctor();
                this.segments = System.Array.init(10, 0, System.Single);
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.Bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = skeleton.FindSlot(data.target.name);
                this.position = data.position;
                this.spacing = data.spacing;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.PathConstraint
             * @memberof Spine.PathConstraint
             * @param   {Spine.PathConstraint}    constraint    
             * @param   {Spine.Skeleton}          skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.slots.Items)[constraint.target.data.index];
                this.position = constraint.position;
                this.spacing = constraint.spacing;
                this.rotateMix = constraint.rotateMix;
                this.translateMix = constraint.translateMix;
            }
        },
        methods: {
            /*Spine.PathConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.PathConstraint
             * @memberof Spine.PathConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.PathConstraint.Apply end.*/

            /*Spine.PathConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Update", this ); }

                var attachment = Bridge.as(this.target.Attachment, Spine.PathAttachment);
                if (attachment == null) {
                    return;
                }

                var rotateMix = this.rotateMix, translateMix = this.translateMix;
                var translate = translateMix > 0, rotate = rotateMix > 0;
                if (!translate && !rotate) {
                    return;
                }

                var data = this.data;
                var percentSpacing = data.spacingMode === Spine.SpacingMode.Percent;
                var rotateMode = data.rotateMode;
                var tangents = rotateMode === Spine.RotateMode.Tangent, scale = rotateMode === Spine.RotateMode.ChainScale;
                var boneCount = this.bones.Count, spacesCount = tangents ? boneCount : ((boneCount + 1) | 0);
                var bonesItems = this.bones.Items;
                var spaces = this.spaces.Resize(spacesCount), lengths = null;
                var spacing = this.spacing;
                if (scale || !percentSpacing) {
                    if (scale) {
                        lengths = this.lengths.Resize(boneCount);
                    }
                    var lengthSpacing = data.spacingMode === Spine.SpacingMode.Length;
                    for (var i = 0, n = (spacesCount - 1) | 0; i < n; ) {
                        var bone = bonesItems[i];
                        var setupLength = bone.data.length;
                        if (setupLength < Spine.PathConstraint.Epsilon) {
                            if (scale) {
                                lengths.Items[i] = 0;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = 0;
                        } else if (percentSpacing) {
                            if (scale) {
                                var x = setupLength * bone.a, y = setupLength * bone.c;
                                var length = Math.sqrt(x * x + y * y);
                                lengths.Items[i] = length;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = spacing;
                        } else {
                            var x1 = setupLength * bone.a, y1 = setupLength * bone.c;
                            var length1 = Math.sqrt(x1 * x1 + y1 * y1);
                            if (scale) {
                                lengths.Items[i] = length1;
                            }
                            spaces.Items[((i = (i + 1) | 0))] = (lengthSpacing ? setupLength + spacing : spacing) * length1 / setupLength;
                        }
                    }
                } else {
                    for (var i1 = 1; i1 < spacesCount; i1 = (i1 + 1) | 0) {
                        spaces.Items[i1] = spacing;
                    }
                }

                var positions = this.ComputeWorldPositions(attachment, spacesCount, tangents, data.positionMode === Spine.PositionMode.Percent, percentSpacing);
                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
                var tip;
                if (offsetRotation === 0) {
                    tip = rotateMode === Spine.RotateMode.Chain;
                } else {
                    tip = false;
                    var p = this.target.bone;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                }
                for (var i2 = 0, p1 = 3; i2 < boneCount; i2 = (i2 + 1) | 0, p1 = (p1 + 3) | 0) {
                    var bone1 = bonesItems[i2];
                    bone1.worldX += (boneX - bone1.worldX) * translateMix;
                    bone1.worldY += (boneY - bone1.worldY) * translateMix;
                    var x2 = positions[p1], y2 = positions[((p1 + 1) | 0)], dx = x2 - boneX, dy = y2 - boneY;
                    if (scale) {
                        var length2 = lengths.Items[i2];
                        if (length2 >= Spine.PathConstraint.Epsilon) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length2 - 1) * rotateMix + 1;
                            bone1.a *= s;
                            bone1.c *= s;
                        }
                    }
                    boneX = x2;
                    boneY = y2;
                    if (rotate) {
                        var a = bone1.a, b = bone1.b, c = bone1.c, d = bone1.d, r, cos, sin;
                        if (tangents) {
                            r = positions[((p1 - 1) | 0)];
                        } else {
                            if (spaces.Items[((i2 + 1) | 0)] < Spine.PathConstraint.Epsilon) {
                                r = positions[((p1 + 2) | 0)];
                            } else {
                                r = Spine.MathUtils.Atan2(dy, dx);
                            }
                        }
                        r -= Spine.MathUtils.Atan2(c, a);
                        if (tip) {
                            cos = Spine.MathUtils.Cos(r);
                            sin = Spine.MathUtils.Sin(r);
                            var length3 = bone1.data.length;
                            boneX += (length3 * (cos * a - sin * c) - dx) * rotateMix;
                            boneY += (length3 * (sin * a + cos * c) - dy) * rotateMix;
                        } else {
                            r += offsetRotation;
                        }
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        cos = Spine.MathUtils.Cos(r);
                        sin = Spine.MathUtils.Sin(r);
                        bone1.a = cos * a - sin * c;
                        bone1.b = cos * b - sin * d;
                        bone1.c = sin * a + cos * c;
                        bone1.d = sin * b + cos * d;
                    }
                    bone1.appliedValid = false;
                }
            },
            /*Spine.PathConstraint.Update end.*/

            /*Spine.PathConstraint.ComputeWorldPositions start.*/
            ComputeWorldPositions: function (path, spacesCount, tangents, percentPosition, percentSpacing) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ComputeWorldPositions", this ); }


                var target = this.target;
                var position = this.position;
                var spacesItems = this.spaces.Items, output = this.positions.Resize(((Bridge.Int.mul(spacesCount, 3) + 2) | 0)).Items, world;
                var closed = path.Closed;
                var verticesLength = path.WorldVerticesLength, curveCount = (Bridge.Int.div(verticesLength, 6)) | 0, prevCurve = Spine.PathConstraint.NONE;
                var pathLength = 0;

                if (!path.ConstantSpeed) {
                    var lengths = path.Lengths;
                    curveCount = (curveCount - (closed ? 1 : 2)) | 0;
                    pathLength = lengths[curveCount];
                    if (percentPosition) {
                        position *= pathLength;
                    }
                    if (percentSpacing) {
                        for (var i = 1; i < spacesCount; i = (i + 1) | 0) {
                            spacesItems[i] *= pathLength;
                        }
                    }
                    world = this.world.Resize(8).Items;
                    for (var i1 = 0, o = 0, curve = 0; i1 < spacesCount; i1 = (i1 + 1) | 0, o = (o + 3) | 0) {
                        var space = spacesItems[i1];
                        position += space;
                        var p = position;

                        if (closed) {
                            p %= pathLength;
                            if (p < 0) {
                                p += pathLength;
                            }
                            curve = 0;
                        } else if (p < 0) {
                            if (prevCurve !== Spine.PathConstraint.BEFORE) {
                                prevCurve = Spine.PathConstraint.BEFORE;
                                path.ComputeWorldVertices(target, 2, 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddBeforePosition(p, world, 0, output, o);
                            continue;
                        } else if (p > pathLength) {
                            if (prevCurve !== Spine.PathConstraint.AFTER) {
                                prevCurve = Spine.PathConstraint.AFTER;
                                path.ComputeWorldVertices(target, ((verticesLength - 6) | 0), 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddAfterPosition(p - pathLength, world, 0, output, o);
                            continue;
                        }

                        // Determine curve containing position.
                        for (; ; curve = (curve + 1) | 0) {
                            var length = lengths[curve];
                            if (p > length) {
                                continue;
                            }
                            if (curve === 0) {
                                p /= length;
                            } else {
                                var prev = lengths[((curve - 1) | 0)];
                                p = (p - prev) / (length - prev);
                            }
                            break;
                        }
                        if (curve !== prevCurve) {
                            prevCurve = curve;
                            if (closed && curve === curveCount) {
                                path.ComputeWorldVertices(target, ((verticesLength - 4) | 0), 4, world, 0, 2);
                                path.ComputeWorldVertices(target, 0, 4, world, 4, 2);
                            } else {
                                path.ComputeWorldVertices(target, ((Bridge.Int.mul(curve, 6) + 2) | 0), 8, world, 0, 2);
                            }
                        }
                        Spine.PathConstraint.AddCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], output, o, tangents || (i1 > 0 && space < Spine.PathConstraint.Epsilon));
                    }
                    return output;
                }

                // World vertices.
                if (closed) {
                    verticesLength = (verticesLength + 2) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, ((verticesLength - 4) | 0), world, 0, 2);
                    path.ComputeWorldVertices(target, 0, 2, world, ((verticesLength - 4) | 0), 2);
                    world[((verticesLength - 2) | 0)] = world[0];
                    world[((verticesLength - 1) | 0)] = world[1];
                } else {
                    curveCount = (curveCount - 1) | 0;
                    verticesLength = (verticesLength - 4) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, verticesLength, world, 0, 2);
                }

                // Curve lengths.
                var curves = this.curves.Resize(curveCount).Items;
                pathLength = 0;
                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
                var tmpx, tmpy, dddfx, dddfy, ddfx, ddfy, dfx, dfy;
                for (var i2 = 0, w = 2; i2 < curveCount; i2 = (i2 + 1) | 0, w = (w + 6) | 0) {
                    cx1 = world[w];
                    cy1 = world[((w + 1) | 0)];
                    cx2 = world[((w + 2) | 0)];
                    cy2 = world[((w + 3) | 0)];
                    x2 = world[((w + 4) | 0)];
                    y2 = world[((w + 5) | 0)];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.166666672;
                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.166666672;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i2] = pathLength;
                    x1 = x2;
                    y1 = y2;
                }
                if (percentPosition) {
                    position *= pathLength;
                } else {
                    position *= pathLength / path.lengths[((curveCount - 1) | 0)];
                }

                if (percentSpacing) {
                    for (var i3 = 1; i3 < spacesCount; i3 = (i3 + 1) | 0) {
                        spacesItems[i3] *= pathLength;
                    }
                }

                var segments = this.segments;
                var curveLength = 0;
                for (var i4 = 0, o1 = 0, curve1 = 0, segment = 0; i4 < spacesCount; i4 = (i4 + 1) | 0, o1 = (o1 + 3) | 0) {
                    var space1 = spacesItems[i4];
                    position += space1;
                    var p1 = position;

                    if (closed) {
                        p1 %= pathLength;
                        if (p1 < 0) {
                            p1 += pathLength;
                        }
                        curve1 = 0;
                    } else if (p1 < 0) {
                        Spine.PathConstraint.AddBeforePosition(p1, world, 0, output, o1);
                        continue;
                    } else if (p1 > pathLength) {
                        Spine.PathConstraint.AddAfterPosition(p1 - pathLength, world, ((verticesLength - 4) | 0), output, o1);
                        continue;
                    }

                    // Determine curve containing position.
                    for (; ; curve1 = (curve1 + 1) | 0) {
                        var length1 = curves[curve1];
                        if (p1 > length1) {
                            continue;
                        }
                        if (curve1 === 0) {
                            p1 /= length1;
                        } else {
                            var prev1 = curves[((curve1 - 1) | 0)];
                            p1 = (p1 - prev1) / (length1 - prev1);
                        }
                        break;
                    }

                    // Curve segment lengths.
                    if (curve1 !== prevCurve) {
                        prevCurve = curve1;
                        var ii = Bridge.Int.mul(curve1, 6);
                        x1 = world[ii];
                        y1 = world[((ii + 1) | 0)];
                        cx1 = world[((ii + 2) | 0)];
                        cy1 = world[((ii + 3) | 0)];
                        cx2 = world[((ii + 4) | 0)];
                        cy2 = world[((ii + 5) | 0)];
                        x2 = world[((ii + 6) | 0)];
                        y2 = world[((ii + 7) | 0)];
                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                        ddfx = tmpx * 2 + dddfx;
                        ddfy = tmpy * 2 + dddfy;
                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.166666672;
                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.166666672;
                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[0] = curveLength;
                        for (ii = 1; ii < 8; ii = (ii + 1) | 0) {
                            dfx += ddfx;
                            dfy += ddfy;
                            ddfx += dddfx;
                            ddfy += dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[ii] = curveLength;
                        }
                        dfx += ddfx;
                        dfy += ddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[8] = curveLength;
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[9] = curveLength;
                        segment = 0;
                    }

                    // Weight by segment length.
                    p1 *= curveLength;
                    for (; ; segment = (segment + 1) | 0) {
                        var length2 = segments[segment];
                        if (p1 > length2) {
                            continue;
                        }
                        if (segment === 0) {
                            p1 /= length2;
                        } else {
                            var prev2 = segments[((segment - 1) | 0)];
                            p1 = segment + (p1 - prev2) / (length2 - prev2);
                        }
                        break;
                    }
                    Spine.PathConstraint.AddCurvePosition(p1 * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o1, tangents || (i4 > 0 && space1 < Spine.PathConstraint.Epsilon));
                }
                return output;
            },
            /*Spine.PathConstraint.ComputeWorldPositions end.*/


        }
    });
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    Bridge.define("Spine.PathConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            positionMode: 0,
            spacingMode: 0,
            rotateMode: 0,
            offsetRotation: 0,
            position: 0,
            spacing: 0,
            rotateMix: 0,
            translateMix: 0
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            PositionMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#get", this ); }

                    return this.positionMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#set", this ); }

                    this.positionMode = value;
                }
            },
            SpacingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#get", this ); }

                    return this.spacingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#set", this ); }

                    this.spacingMode = value;
                }
            },
            RotateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#get", this ); }

                    return this.rotateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#set", this ); }

                    this.rotateMode = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#set", this ); }

                    this.position = value;
                }
            },
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.PathConstraintData end.*/

    /*Spine.PointAttachment start.*/
    
    Bridge.define("Spine.PointAttachment", {
        inherits: [Spine.Attachment],
        fields: {
            x: 0,
            y: 0,
            rotation: 0
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.PointAttachment.ComputeWorldPosition start.*/
            ComputeWorldPosition: function (bone, ox, oy) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldPosition", this ); }

                bone.LocalToWorld(this.x, this.y, ox, oy);
            },
            /*Spine.PointAttachment.ComputeWorldPosition end.*/

            /*Spine.PointAttachment.ComputeWorldRotation start.*/
            ComputeWorldRotation: function (bone) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldRotation", this ); }

                var cos = Spine.MathUtils.CosDeg(this.rotation), sin = Spine.MathUtils.SinDeg(this.rotation);
                var ix = cos * bone.a + sin * bone.b;
                var iy = cos * bone.c + sin * bone.d;
                return Spine.MathUtils.Atan2(iy, ix) * Spine.MathUtils.RadDeg;
            },
            /*Spine.PointAttachment.ComputeWorldRotation end.*/

            /*Spine.PointAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Copy", this ); }

                var copy = new Spine.PointAttachment(this.Name);
                copy.x = this.x;
                copy.y = this.y;
                copy.rotation = this.rotation;
                return copy;
            },
            /*Spine.PointAttachment.Copy end.*/


        }
    });
    /*Spine.PointAttachment end.*/

    /*Spine.Pow start.*/
    Bridge.define("Spine.Pow", {
        inherits: [Spine.IInterpolation],
        fields: {
            Power: 0
        },
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.Pow#ctor", this ); }

                this.$initialize();
                Spine.IInterpolation.ctor.call(this);
                this.Power = power;
            }
        },
        methods: {
            /*Spine.Pow.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Pow#Apply$1", this ); }

                if (a <= 0.5) {
                    return Math.pow(a * 2, this.Power) / 2;
                }
                return Math.pow((a - 1) * 2, this.Power) / (this.Power % 2 === 0 ? -2 : 2) + 1;
            },
            /*Spine.Pow.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.Pow end.*/

    /*Spine.RegionAttachment start.*/
    /**
     * Attachment that displays a texture region.
     *
     * @public
     * @class Spine.RegionAttachment
     * @augments Spine.Attachment
     * @implements  Spine.IHasRendererObject
     */
    Bridge.define("Spine.RegionAttachment", {
        inherits: [Spine.Attachment,Spine.IHasRendererObject],
        statics: {
            fields: {
                BLX: 0,
                BLY: 0,
                ULX: 0,
                ULY: 0,
                URX: 0,
                URY: 0,
                BRX: 0,
                BRY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                    this.BLX = 0;
                    this.BLY = 1;
                    this.ULX = 2;
                    this.ULY = 3;
                    this.URX = 4;
                    this.URY = 5;
                    this.BRX = 6;
                    this.BRY = 7;
                }
            }
        },
        fields: {
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            width: 0,
            height: 0,
            regionOffsetX: 0,
            regionOffsetY: 0,
            regionWidth: 0,
            regionHeight: 0,
            regionOriginalWidth: 0,
            regionOriginalHeight: 0,
            offset: null,
            uvs: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            Path: null,
            RendererObject: null
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#set", this ); }

                    this.height = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            RegionOffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetX#get", this ); }

                    return this.regionOffsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetX#set", this ); }

                    this.regionOffsetX = value;
                }
            },
            RegionOffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetY#get", this ); }

                    return this.regionOffsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOffsetY#set", this ); }

                    this.regionOffsetY = value;
                }
            },
            RegionWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionWidth#get", this ); }

                    return this.regionWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionWidth#set", this ); }

                    this.regionWidth = value;
                }
            },
            RegionHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionHeight#get", this ); }

                    return this.regionHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionHeight#set", this ); }

                    this.regionHeight = value;
                }
            },
            RegionOriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalWidth#get", this ); }

                    return this.regionOriginalWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalWidth#set", this ); }

                    this.regionOriginalWidth = value;
                }
            },
            RegionOriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalHeight#get", this ); }

                    return this.regionOriginalHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#RegionOriginalHeight#set", this ); }

                    this.regionOriginalHeight = value;
                }
            },
            Offset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Offset#get", this ); }

                    return this.offset;
                }
            },
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UVs#get", this ); }

                    return this.uvs;
                }
            }
        },
        alias: ["RendererObject", "Spine$IHasRendererObject$RendererObject"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.offset = System.Array.init(8, 0, System.Single);
                this.uvs = System.Array.init(8, 0, System.Single);
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.RegionAttachment.UpdateOffset start.*/
            UpdateOffset: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UpdateOffset", this ); }

                var width = this.width;
                var height = this.height;
                var localX2 = width * 0.5;
                var localY2 = height * 0.5;
                var localX = -localX2;
                var localY = -localY2;
                if (this.regionOriginalWidth !== 0) { // if (region != null)
                    localX += this.regionOffsetX / this.regionOriginalWidth * width;
                    localY += this.regionOffsetY / this.regionOriginalHeight * height;
                    localX2 -= (this.regionOriginalWidth - this.regionOffsetX - this.regionWidth) / this.regionOriginalWidth * width;
                    localY2 -= (this.regionOriginalHeight - this.regionOffsetY - this.regionHeight) / this.regionOriginalHeight * height;
                }
                var scaleX = this.scaleX;
                var scaleY = this.scaleY;
                localX *= scaleX;
                localY *= scaleY;
                localX2 *= scaleX;
                localY2 *= scaleY;
                var rotation = this.rotation;
                var cos = Spine.MathUtils.CosDeg(rotation);
                var sin = Spine.MathUtils.SinDeg(rotation);
                var x = this.x;
                var y = this.y;
                var localXCos = localX * cos + x;
                var localXSin = localX * sin;
                var localYCos = localY * cos + y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[Spine.RegionAttachment.BLX] = localXCos - localYSin;
                offset[Spine.RegionAttachment.BLY] = localYCos + localXSin;
                offset[Spine.RegionAttachment.ULX] = localXCos - localY2Sin;
                offset[Spine.RegionAttachment.ULY] = localY2Cos + localXSin;
                offset[Spine.RegionAttachment.URX] = localX2Cos - localY2Sin;
                offset[Spine.RegionAttachment.URY] = localY2Cos + localX2Sin;
                offset[Spine.RegionAttachment.BRX] = localX2Cos - localYSin;
                offset[Spine.RegionAttachment.BRY] = localYCos + localX2Sin;
            },
            /*Spine.RegionAttachment.UpdateOffset end.*/

            /*Spine.RegionAttachment.SetUVs start.*/
            SetUVs: function (u, v, u2, v2, rotate) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#SetUVs", this ); }

                var uvs = this.uvs;
                // UV values differ from RegionAttachment.java
                if (rotate) {
                    uvs[Spine.RegionAttachment.URX] = u;
                    uvs[Spine.RegionAttachment.URY] = v2;
                    uvs[Spine.RegionAttachment.BRX] = u;
                    uvs[Spine.RegionAttachment.BRY] = v;
                    uvs[Spine.RegionAttachment.BLX] = u2;
                    uvs[Spine.RegionAttachment.BLY] = v;
                    uvs[Spine.RegionAttachment.ULX] = u2;
                    uvs[Spine.RegionAttachment.ULY] = v2;
                } else {
                    uvs[Spine.RegionAttachment.ULX] = u;
                    uvs[Spine.RegionAttachment.ULY] = v2;
                    uvs[Spine.RegionAttachment.URX] = u;
                    uvs[Spine.RegionAttachment.URY] = v;
                    uvs[Spine.RegionAttachment.BRX] = u2;
                    uvs[Spine.RegionAttachment.BRY] = v;
                    uvs[Spine.RegionAttachment.BLX] = u2;
                    uvs[Spine.RegionAttachment.BLY] = v2;
                }
            },
            /*Spine.RegionAttachment.SetUVs end.*/

            /*Spine.RegionAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's four vertices to world coordinates.
             *
             * @instance
             * @public
             * @this Spine.RegionAttachment
             * @memberof Spine.RegionAttachment
             * @param   {Spine.Bone}        bone             The parent bone.
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to offset + 8.
             * @param   {number}            offset           The worldVertices index to begin writing values.
             * @param   {number}            stride           The number of worldVertices entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (bone, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                var vertexOffset = this.offset;
                var bwx = bone.worldX, bwy = bone.worldY;
                var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                var offsetX, offsetY;

                // Vertex order is different from RegionAttachment.java
                offsetX = vertexOffset[Spine.RegionAttachment.BRX]; // 0
                offsetY = vertexOffset[Spine.RegionAttachment.BRY]; // 1
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // bl
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.BLX]; // 2
                offsetY = vertexOffset[Spine.RegionAttachment.BLY]; // 3
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ul
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.ULX]; // 4
                offsetY = vertexOffset[Spine.RegionAttachment.ULY]; // 5
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ur
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.URX]; // 6
                offsetY = vertexOffset[Spine.RegionAttachment.URY]; // 7
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // br
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                //offset += stride;
            },
            /*Spine.RegionAttachment.ComputeWorldVertices end.*/

            /*Spine.RegionAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Copy", this ); }

                var copy = new Spine.RegionAttachment(this.Name);
                copy.RendererObject = this.RendererObject;
                copy.regionOffsetX = this.regionOffsetX;
                copy.regionOffsetY = this.regionOffsetY;
                copy.regionWidth = this.regionWidth;
                copy.regionHeight = this.regionHeight;
                copy.regionOriginalWidth = this.regionOriginalWidth;
                copy.regionOriginalHeight = this.regionOriginalHeight;
                copy.Path = this.Path;
                copy.x = this.x;
                copy.y = this.y;
                copy.scaleX = this.scaleX;
                copy.scaleY = this.scaleY;
                copy.rotation = this.rotation;
                copy.width = this.width;
                copy.height = this.height;
                System.Array.copy(this.uvs, 0, copy.uvs, 0, 8);
                System.Array.copy(this.offset, 0, copy.offset, 0, 8);
                copy.r = this.r;
                copy.g = this.g;
                copy.b = this.b;
                copy.a = this.a;
                return copy;
            },
            /*Spine.RegionAttachment.Copy end.*/


        }
    });
    /*Spine.RegionAttachment end.*/

    /*Spine.Skin+SkinEntryComparer start.*/
    Bridge.define("Spine.Skin.SkinEntryComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.Skin.SkinEntry)],
        $kind: "nested class",
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#init", this ); }

                    this.Instance = new Spine.Skin.SkinEntryComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2: function (e1, e2) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2", this ); }

                if (e1.SlotIndex !== e2.SlotIndex) {
                    return false;
                }
                if (!System.String.equals(e1.Name, e2.Name, 4)) {
                    return false;
                }
                return true;
            },
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$equals2 end.*/

            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2: function (e) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntryComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2", this ); }

                return ((Bridge.getHashCode(e.Name) + Bridge.Int.mul(e.SlotIndex, 37)) | 0);
            },
            /*Spine.Skin+SkinEntryComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinEntry$getHashCode2 end.*/


        }
    });
    /*Spine.Skin+SkinEntryComparer end.*/

    /*Spine.TrackEntry start.*/
    /**
     * <p>Stores settings and other state for the playback of an animation on an {@link } track.</p><p>References to a track entry must not be kept after the {@link } event occurs.</p>
     *
     * @public
     * @class Spine.TrackEntry
     * @implements  Spine.Pool$1.IPoolable
     */
    Bridge.define("Spine.TrackEntry", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#inherits", this ); }
 return [Spine.Pool$1.IPoolable(Spine.TrackEntry)]; },
        fields: {
            animation: null,
            next: null,
            mixingFrom: null,
            mixingTo: null,
            trackIndex: 0,
            loop: false,
            holdPrevious: false,
            eventThreshold: 0,
            attachmentThreshold: 0,
            drawOrderThreshold: 0,
            animationStart: 0,
            animationEnd: 0,
            animationLast: 0,
            nextAnimationLast: 0,
            delay: 0,
            trackTime: 0,
            trackLast: 0,
            nextTrackLast: 0,
            trackEnd: 0,
            timeScale: 0,
            alpha: 0,
            mixTime: 0,
            mixDuration: 0,
            interruptAlpha: 0,
            totalAlpha: 0,
            mixBlend: 0,
            timelineMode: null,
            timelineHoldMix: null,
            timelinesRotation: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            /**
             * The index of the track where this entry is either current or queued.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function TrackIndex
             * @type number
             * @see {@link AnimationState.GetCurrent(int)}
             */
            TrackIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackIndex#get", this ); }

                    return this.trackIndex;
                }
            },
            /**
             * The animation to apply for this track entry.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Animation
             * @type Spine.Animation
             */
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Animation#get", this ); }

                    return this.animation;
                }
            },
            /**
             * If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
             duration.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Loop
             * @type boolean
             */
            Loop: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#get", this ); }

                    return this.loop;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#set", this ); }

                    this.loop = value;
                }
            },
            /**
             * <p>Seconds to postpone playing the animation. When this track entry is the current track entry, <pre><code>Delay</code></pre>
             postpones incrementing the {@link }. When this track entry is queued, <pre><code>Delay</code></pre> is the time from
             the start of the previous animation to when this track entry will become the current track entry (ie when the previous
             track entry {@link } &gt;= this track entry's <pre><code>Delay</code></pre>).</p><p>{@link } affects the delay.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Delay
             * @type number
             */
            Delay: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#get", this ); }

                    return this.delay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#set", this ); }

                    this.delay = value;
                }
            },
            /**
             * Current time in seconds this track entry has been the current track entry. The track time determines
             {@link }. The track time can be set to start the animation at a time other than 0, without affecting
             looping.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackTime
             * @type number
             */
            TrackTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#get", this ); }

                    return this.trackTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#set", this ); }

                    this.trackTime = value;
                }
            },
            /**
             * <p>The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
             value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
             is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
             properties keyed by the animation are set to the setup pose and the track is cleared.</p><p>It may be desired to use {@link }  rather than have the animation
             abruptly cease being applied.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackEnd
             * @type number
             */
            TrackEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#get", this ); }

                    return this.trackEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#set", this ); }

                    this.trackEnd = value;
                }
            },
            
            AnimationStart: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#get", this ); }

                    return this.animationStart;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#set", this ); }

                    this.animationStart = value;
                }
            },
            /**
             * Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
             loop back to {@link } at this time. Defaults to the animation {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationEnd
             * @type number
             */
            AnimationEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#get", this ); }

                    return this.animationEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#set", this ); }

                    this.animationEnd = value;
                }
            },
            /**
             * The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
             animation is applied, event timelines will fire all events between the <pre><code>AnimationLast</code></pre> time (exclusive) and
             <pre><code>AnimationTime</code></pre> (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
             is applied.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationLast
             * @type number
             */
            AnimationLast: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#get", this ); }

                    return this.animationLast;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#set", this ); }

                    this.animationLast = value;
                    this.nextAnimationLast = value;
                }
            },
            /**
             * Uses {@link } to compute the <pre><code>AnimationTime</code></pre>, which is between {@link }
             and {@link }. When the <pre><code>TrackTime</code></pre> is 0, the <pre><code>AnimationTime</code></pre> is equal to the
             <pre><code>AnimationStart</code></pre> time.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function AnimationTime
             * @type number
             */
            AnimationTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationTime#get", this ); }

                    if (this.loop) {
                        var duration = this.animationEnd - this.animationStart;
                        if (duration === 0) {
                            return this.animationStart;
                        }
                        return (this.trackTime % duration) + this.animationStart;
                    }
                    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
                }
            },
            
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            
            Alpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#get", this ); }

                    return this.alpha;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#set", this ); }

                    this.alpha = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>EventThreshold</code></pre>, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
             timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function EventThreshold
             * @type number
             */
            EventThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#get", this ); }

                    return this.eventThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#set", this ); }

                    this.eventThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>AttachmentThreshold</code></pre>, attachment timelines are applied while this animation is being mixed out. Defaults to
             0, so attachment timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AttachmentThreshold
             * @type number
             */
            AttachmentThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#get", this ); }

                    return this.attachmentThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#set", this ); }

                    this.attachmentThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>DrawOrderThreshold</code></pre>, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
             so draw order timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function DrawOrderThreshold
             * @type number
             */
            DrawOrderThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#get", this ); }

                    return this.drawOrderThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#set", this ); }

                    this.drawOrderThreshold = value;
                }
            },
            /**
             * The animation queued to start after this animation, or null. <pre><code>Next</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Next
             * @type Spine.TrackEntry
             */
            Next: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Next#get", this ); }

                    return this.next;
                }
            },
            /**
             * Returns true if at least one loop has been completed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function IsComplete
             * @type boolean
             * @see {@link TrackEntry.Complete}
             */
            IsComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsComplete#get", this ); }

                    return this.trackTime >= this.animationEnd - this.animationStart;
                }
            },
            /**
             * Seconds from 0 to the {@link } when mixing from the previous animation to this animation. May be
             slightly more than <pre><code>MixDuration</code></pre> when the mix is complete.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixTime
             * @type number
             */
            MixTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#get", this ); }

                    return this.mixTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#set", this ); }

                    this.mixTime = value;
                }
            },
            /**
             * <p>Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
             {@link } based on the animation before this animation (if any).</p><p>The <pre><code>MixDuration</code></pre> can be set manually rather than use the value from
             {@link }. In that case, the <pre><code>MixDuration</code></pre> can be set for a new
              track entry only before {@link } is first called.</p><p>When using <seealso cref="AnimationState.AddAnimation(int, Animation, bool, float)" /> with a <pre><code>Delay</code></pre> &lt;= 0, note the
              {@link } is set using the mix duration from the {@link }, not a mix duration set
              afterward.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixDuration
             * @type number
             * @see {@link AnimationState.AddAnimation(int, Animation, bool, float)}
             */
            MixDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#get", this ); }

                    return this.mixDuration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#set", this ); }

                    this.mixDuration = value;
                }
            },
            /**
             * <p>Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link }, which
             replaces the values from the lower tracks with the animation values. {@link } adds the animation values to
             the values from the lower tracks.</p><p>The <pre><code>MixBlend</code></pre> can be set for a new track entry only before {@link } is first
              called.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixBlend
             * @type Spine.MixBlend
             */
            MixBlend: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#get", this ); }

                    return this.mixBlend;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#set", this ); }

                    this.mixBlend = value;
                }
            },
            /**
             * The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
             mixing is currently occuring. When mixing from multiple animations, <pre><code>MixingFrom</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingFrom
             * @type Spine.TrackEntry
             */
            MixingFrom: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingFrom#get", this ); }

                    return this.mixingFrom;
                }
            },
            /**
             * The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
             currently occuring. When mixing to multiple animations, <pre><code>MixingTo</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingTo
             * @type Spine.TrackEntry
             */
            MixingTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingTo#get", this ); }

                    return this.mixingTo;
                }
            },
            /**
             * <p>If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
             of being mixed out.</p><p>When mixing between animations that key the same property, if a lower track also keys that property then the value will
             briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
             while the second animation mixes from 0% to 100%. Setting <pre><code>HoldPrevious</code></pre> to true applies the first animation
             at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
             keys the property, only when a higher track also keys the property.</p><p>Snapping will occur if <pre><code>HoldPrevious</code></pre> is true and this animation does not key all the same properties as the
             previous animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function HoldPrevious
             * @type boolean
             */
            HoldPrevious: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#get", this ); }

                    return this.holdPrevious;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#set", this ); }

                    this.holdPrevious = value;
                }
            }
        },
        alias: ["Reset", "Spine$Pool$1$IPoolable$Spine$TrackEntry$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#init", this ); }

                this.timeScale = 1.0;
                this.mixBlend = Spine.MixBlend.Replace;
                this.timelineMode = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.timelineHoldMix = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.timelinesRotation = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.TrackEntry.OnStart start.*/
            OnStart: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(this);
                }
            },
            /*Spine.TrackEntry.OnStart end.*/

            /*Spine.TrackEntry.OnInterrupt start.*/
            OnInterrupt: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(this);
                }
            },
            /*Spine.TrackEntry.OnInterrupt end.*/

            /*Spine.TrackEntry.OnEnd start.*/
            OnEnd: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(this);
                }
            },
            /*Spine.TrackEntry.OnEnd end.*/

            /*Spine.TrackEntry.OnDispose start.*/
            OnDispose: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(this);
                }
            },
            /*Spine.TrackEntry.OnDispose end.*/

            /*Spine.TrackEntry.OnComplete start.*/
            OnComplete: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(this);
                }
            },
            /*Spine.TrackEntry.OnComplete end.*/

            /*Spine.TrackEntry.OnEvent start.*/
            OnEvent: function (e) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(this, e);
                }
            },
            /*Spine.TrackEntry.OnEvent end.*/

            /*Spine.TrackEntry.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reset", this ); }

                this.next = null;
                this.mixingFrom = null;
                this.mixingTo = null;
                this.animation = null;
                // replaces 'listener = null;' since delegates are used for event callbacks
                this.Start = null;
                this.Interrupt = null;
                this.End = null;
                this.Dispose = null;
                this.Complete = null;
                this.Event = null;
                this.timelineMode.Clear();
                this.timelineHoldMix.Clear();
                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.Reset end.*/

            /*Spine.TrackEntry.ResetRotationDirections start.*/
            /**
             * <p>Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
             long way around when using {@link } and starting animations on other tracks.</p><p>Mixing with {@link } involves finding a rotation between two others, which has two possible solutions:
             the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
             way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
             long way. TrackEntry chooses the short way the first time it is applied and remembers that direction.</p>
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @return  {void}
             */
            ResetRotationDirections: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ResetRotationDirections", this ); }

                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.ResetRotationDirections end.*/

            /*Spine.TrackEntry.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#toString", this ); }

                return this.animation == null ? "<none>" : this.animation.name;
            },
            /*Spine.TrackEntry.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TrackEntry end.*/

    /*Spine.TransformConstraint start.*/
    /**
     * <p>Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained
     bones to match that of the target bone.</p><p>See <a href="http://esotericsoftware.com/spine-transform-constraints">Transform constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.TransformConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.TransformConstraint", {
        inherits: [Spine.IUpdatable],
        fields: {
            data: null,
            bones: null,
            target: null,
            rotateMix: 0,
            translateMix: 0,
            scaleMix: 0,
            shearMix: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this transform constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The target bone whose world transform will be copied to the constrained bones.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function RotateMix
             * @type number
             */
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translations.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function TranslateMix
             * @type number
             */
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scales.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function ScaleMix
             * @type number
             */
            ScaleMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ScaleMix#get", this ); }

                    return this.scaleMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ScaleMix#set", this ); }

                    this.scaleMix = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scales.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function ShearMix
             * @type number
             */
            ShearMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ShearMix#get", this ); }

                    return this.shearMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ShearMix#set", this ); }

                    this.shearMix = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The transform constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Data
             * @type Spine.TransformConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
                this.scaleMix = data.scaleMix;
                this.shearMix = data.shearMix;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(skeleton.FindBone(boneData.name));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.target = skeleton.FindBone(data.target.name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraint
             * @memberof Spine.TransformConstraint
             * @param   {Spine.TransformConstraint}    constraint    
             * @param   {Spine.Skeleton}               skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.rotateMix = constraint.rotateMix;
                this.translateMix = constraint.translateMix;
                this.scaleMix = constraint.scaleMix;
                this.shearMix = constraint.shearMix;
            }
        },
        methods: {
            /*Spine.TransformConstraint.Apply start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraint
             * @memberof Spine.TransformConstraint
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Apply", this ); }

                this.Update();
            },
            /*Spine.TransformConstraint.Apply end.*/

            /*Spine.TransformConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Update", this ); }

                if (this.data.local) {
                    if (this.data.relative) {
                        this.ApplyRelativeLocal();
                    } else {
                        this.ApplyAbsoluteLocal();
                    }
                } else {
                    if (this.data.relative) {
                        this.ApplyRelativeWorld();
                    } else {
                        this.ApplyAbsoluteWorld();
                    }
                }
            },
            /*Spine.TransformConstraint.Update end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteWorld start.*/
            ApplyAbsoluteWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteWorld", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones.Items[i];
                    var modified = false;

                    if (rotateMix !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) - Spine.MathUtils.Atan2(c, a) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                        modified = true;
                    }

                    if (translateMix !== 0) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += (tx.v - bone.worldX) * translateMix;
                        bone.worldY += (ty.v - bone.worldY) * translateMix;
                        modified = true;
                    }

                    if (scaleMix > 0) {
                        var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                        if (s !== 0) {
                            s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * scaleMix) / s;
                        }
                        bone.a *= s;
                        bone.c *= s;
                        s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                        if (s !== 0) {
                            s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * scaleMix) / s;
                        }
                        bone.b *= s;
                        bone.d *= s;
                        modified = true;
                    }

                    if (shearMix > 0) {
                        var b1 = bone.b, d1 = bone.d;
                        var by = Spine.MathUtils.Atan2(d1, b1);
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta) - (by - Spine.MathUtils.Atan2(bone.c, bone.a));
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        r1 = by + (r1 + offsetShearY) * shearMix;
                        var s1 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s1;
                        bone.d = Spine.MathUtils.Sin(r1) * s1;
                        modified = true;
                    }

                    if (modified) {
                        bone.appliedValid = false;
                    }
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteWorld end.*/

            /*Spine.TransformConstraint.ApplyRelativeWorld start.*/
            ApplyRelativeWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeWorld", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones.Items[i];
                    var modified = false;

                    if (rotateMix !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= rotateMix;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                        modified = true;
                    }

                    if (translateMix !== 0) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += tx.v * translateMix;
                        bone.worldY += ty.v * translateMix;
                        modified = true;
                    }

                    if (scaleMix > 0) {
                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
                        bone.a *= s;
                        bone.c *= s;
                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
                        bone.b *= s;
                        bone.d *= s;
                        modified = true;
                    }

                    if (shearMix > 0) {
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta);
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        var b1 = bone.b, d1 = bone.d;
                        r1 = Spine.MathUtils.Atan2(d1, b1) + (r1 - 1.57079637 + offsetShearY) * shearMix;
                        var s1 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s1;
                        bone.d = Spine.MathUtils.Sin(r1) * s1;
                        modified = true;
                    }

                    if (modified) {
                        bone.appliedValid = false;
                    }
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeWorld end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteLocal start.*/
            ApplyAbsoluteLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteLocal", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid) {
                    target.UpdateAppliedTransform();
                }
                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (!bone.appliedValid) {
                        bone.UpdateAppliedTransform();
                    }

                    var rotation = bone.arotation;
                    if (rotateMix !== 0) {
                        var r = target.arotation - rotation + this.data.offsetRotation;
                        r -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r / 360))) | 0)), 360);
                        rotation += r * rotateMix;
                    }

                    var x = bone.ax, y = bone.ay;
                    if (translateMix !== 0) {
                        x += (target.ax - x + this.data.offsetX) * translateMix;
                        y += (target.ay - y + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix !== 0) {
                        if (scaleX !== 0) {
                            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
                        }
                        if (scaleY !== 0) {
                            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
                        }
                    }

                    var shearY = bone.ashearY;
                    if (shearMix !== 0) {
                        var r1 = target.ashearY - shearY + this.data.offsetShearY;
                        r1 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                        shearY += r1 * shearMix;
                    }

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteLocal end.*/

            /*Spine.TransformConstraint.ApplyRelativeLocal start.*/
            ApplyRelativeLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeLocal", this ); }

                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid) {
                    target.UpdateAppliedTransform();
                }
                var bonesItems = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bonesItems[i];
                    if (!bone.appliedValid) {
                        bone.UpdateAppliedTransform();
                    }

                    var rotation = bone.arotation;
                    if (rotateMix !== 0) {
                        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
                    }

                    var x = bone.ax, y = bone.ay;
                    if (translateMix !== 0) {
                        x += (target.ax + this.data.offsetX) * translateMix;
                        y += (target.ay + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix !== 0) {
                        scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;
                        scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;
                    }

                    var shearY = bone.ashearY;
                    if (shearMix !== 0) {
                        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
                    }

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeLocal end.*/

            /*Spine.TransformConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.TransformConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    Bridge.define("Spine.TransformConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            rotateMix: 0,
            translateMix: 0,
            scaleMix: 0,
            shearMix: 0,
            offsetRotation: 0,
            offsetX: 0,
            offsetY: 0,
            offsetScaleX: 0,
            offsetScaleY: 0,
            offsetShearY: 0,
            relative: false,
            local: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#RotateMix#get", this ); }

                    return this.rotateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#RotateMix#set", this ); }

                    this.rotateMix = value;
                }
            },
            TranslateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#TranslateMix#get", this ); }

                    return this.translateMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#TranslateMix#set", this ); }

                    this.translateMix = value;
                }
            },
            ScaleMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ScaleMix#get", this ); }

                    return this.scaleMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ScaleMix#set", this ); }

                    this.scaleMix = value;
                }
            },
            ShearMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ShearMix#get", this ); }

                    return this.shearMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ShearMix#set", this ); }

                    this.shearMix = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            OffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#get", this ); }

                    return this.offsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#set", this ); }

                    this.offsetX = value;
                }
            },
            OffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#get", this ); }

                    return this.offsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#set", this ); }

                    this.offsetY = value;
                }
            },
            OffsetScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#get", this ); }

                    return this.offsetScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#set", this ); }

                    this.offsetScaleX = value;
                }
            },
            OffsetScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#get", this ); }

                    return this.offsetScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#set", this ); }

                    this.offsetScaleY = value;
                }
            },
            OffsetShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#get", this ); }

                    return this.offsetShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#set", this ); }

                    this.offsetShearY = value;
                }
            },
            Relative: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#get", this ); }

                    return this.relative;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#set", this ); }

                    this.relative = value;
                }
            },
            Local: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#get", this ); }

                    return this.local;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#set", this ); }

                    this.local = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.TransformConstraintData end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }

                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.animation = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData).FindAnimation(this.animationName);
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === Spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === Spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    skin.GetAttachments$1(slotIndex, entryBuffer);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case Spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case Spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case Spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasRendererObject);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasRendererObject$RendererObject = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        if (Bridge.referenceEquals(other.mainTexture.name, name)) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                var $t;
                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slotIndex = skeleton.FindSlotIndex(this.slotName);
                    if (slotIndex >= 0) {
                        var slot = ($t = skeleton.slots.Items)[slotIndex];
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.GetAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.ComputeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.ScaleX * this.bone.skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.RendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.RendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.SetToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }

                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton(skeletonData), $t.ScaleX = this.initialFlipX ? -1 : 1, $t.ScaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                this.LateUpdate(); // Generate mesh for the first frame it exists.

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0].$clone(), updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                this.meshFilter.sharedMesh = currentMesh;
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                } // OnBecameVisible is called after LateUpdate()
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.FindSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }


                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterials[i]);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var c = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        c.material = material;
                        c.skeletonDataAsset = skeletonDataAsset;
                        c.Initialize(false);
                    }
                    return c;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            unscaledTime: false,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            rawImages: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null
        },
        events: {
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.timeScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.rawImages = new (System.Collections.Generic.List$1(UnityEngine.UI.RawImage)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.wasUpdatedAfterInit = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }


                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncRawImagesWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.UpdateMesh(true);
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }


                if (this.freeze) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.SyncRawImagesWithCanvasRenderers start.*/
            SyncRawImagesWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncRawImagesWithCanvasRenderers", this ); }

                var $t;
                this.rawImages.clear();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var rawImage = canvasRenderer.GetComponent(UnityEngine.UI.RawImage);
                        if (UnityEngine.MonoBehaviour.op_Equality(rawImage, null)) {
                            rawImage = canvasRenderer.gameObject.AddComponent(UnityEngine.UI.RawImage);
                            rawImage.maskable = this.maskable;
                            rawImage.raycastTarget = false;
                        }
                        this.rawImages.add(rawImage);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncRawImagesWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.Update(deltaTime);
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.UpdateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.FindSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                this.rectTransform.sizeDelta = UnityEngine.Vector2.FromVector3(size.$clone());
                this.rectTransform.pivot = p.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncRawImagesWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton(skeletonData), $t1.ScaleX = this.initialFlipX ? -1 : 1, $t1.ScaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                this.wasUpdatedAfterInit = false;
                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.startingLoop);
                    }
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function (keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                if (keepRendererCount === void 0) { keepRendererCount = false; }
                if (!this.IsValid) {
                    return;
                }

                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                var currentInstructions = this.currentInstructions;
                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer();
                } else {
                    this.UpdateMeshMultipleCanvasRenderers(currentInstructions, keepRendererCount);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                if (this.canvasRenderers.Count > 0) {
                    this.DisableUnusedCanvasRenderers(0);
                }

                var smartMesh = this.meshBuffers.GetNext();
                Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping && this.currentInstructions.submeshInstructions.Count > 0) {
                    this.meshGenerator.AddSubmesh(($t = this.currentInstructions.submeshInstructions.Items)[0].$clone(), updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.meshGenerator.ScaleVertexData(this.canvas.referencePixelsPerUnit);
                }
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                this.canvasRenderer.SetMesh(mesh);
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (this.currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = this.currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null) {
                            this.canvasRenderer.SetTexture(this.mainTexture);
                        }
                    }
                }

                //this.UpdateMaterial(); // note: This would allocate memory.
                this.usedRenderersCount = 0;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions, keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                var submeshCount = currentInstructions.submeshInstructions.Count;
                if (keepRendererCount && submeshCount !== this.usedRenderersCount) {
                    return;
                }
                this.EnsureCanvasRendererCount(submeshCount);
                this.EnsureMeshesCount(submeshCount);
                this.EnsureSeparatorPartCount();

                var c = this.canvas;
                var scale = (UnityEngine.Component.op_Equality(c, null)) ? 100 : c.referencePixelsPerUnit;

                // Generate meshes.
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);
                var separatorSlotGroupIndex = 0;
                var parent = this.separatorSlots.Count === 0 ? this.transform : this.separatorParts.getItem(0);

                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        this.separatorParts.getItem(p).position = this.transform.position.$clone();
                        this.separatorParts.getItem(p).rotation = this.transform.rotation.$clone();
                    }
                }

                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem.$clone());

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(scale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var submeshMaterial = submeshInstructionItem.material;
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (i >= this.usedRenderersCount) {
                        canvasRenderer.gameObject.SetActive(true);
                    }

                    canvasRenderer.SetMesh(targetMesh);
                    canvasRenderer.materialCount = 1;

                    if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform)) {
                        canvasRenderer.transform.SetParent(parent.transform, false);
                        canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                    }
                    canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }

                    if (useOriginalTextureAndMaterial) {
                        canvasRenderer.SetMaterial$1(this.materialForRendering, submeshMaterial.mainTexture);
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial)) {
                            usedMaterial.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }
                        canvasRenderer.SetMaterial$1(usedMaterial.v, usedTexture.v);
                    }
                }

                this.DisableUnusedCanvasRenderers(submeshCount);
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var rawImage = go.AddComponent(UnityEngine.UI.RawImage);
                    rawImage.maskable = this.maskable;
                    rawImage.raycastTarget = false;
                    this.rawImages.add(rawImage);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gather after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            canvas: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.canvas) ? this.canvas.referencePixelsPerUnit : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.Animation;
                var start = track.AnimationTime;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.Animation;
                var time = track.AnimationTime;
                return this.GetAnimationRootMotionInfo(track.Animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                if (UnityEngine.Component.op_Inequality(this.GetComponent(UnityEngine.CanvasRenderer), null)) {
                    this.canvas = this.GetComponentInParent(UnityEngine.Canvas);
                }
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.animationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                // Apply mix alpha to the delta position (based on AnimationState.cs).
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    currentDelta.v = currentDelta.v.$clone().scale( mixAndAlpha );
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    currentDelta.v = currentDelta.v.$clone().scale( mix );
                }
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText     
                 * @param   {Array.<UnityEngine.Material>}    materials     
                 * @param   {boolean}                         initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool)" />
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        if (atlasLines[i].trim().length === 0) {
                            pages.add(System.String.replaceAll(atlasLines[((i + 1) | 0)].trim(), ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches. <seealso cref="Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)" />
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText     
                 * @param   {Array.<UnityEngine.Texture2D>}    textures      
                 * @param   {UnityEngine.Shader}               shader        
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    var oa = Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize);

                    return oa;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @return  {Spine.Atlas}        The atlas or null if it could not be loaded.
             */
            GetAtlas: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.materials == null || this.materials.length === 0) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", new Spine.Unity.MaterialsTextureLoader(this));
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.FindRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (!region.rotate) {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    } else {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    return System.String.isNullOrEmpty(hierarchy.name) ? null : skeletonData.FindSkin(hierarchy.skin).GetAttachment(skeletonData.FindSlotIndex(hierarchy.slot), hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*ThirdParties.Truongtv.SoundManager.Bgm start.*/
    Bridge.define("ThirdParties.Truongtv.SoundManager.Bgm", {
        inherits: [ThirdParties.Truongtv.SoundManager.BaseAudio],
        statics: {
            fields: {
                instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#Instance#get", this ); }

                        return ThirdParties.Truongtv.SoundManager.Bgm.instance;
                    }
                }
            }
        },
        methods: {
            /*ThirdParties.Truongtv.SoundManager.Bgm.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#Awake", this ); }

                ThirdParties.Truongtv.SoundManager.BaseAudio.prototype.Awake.call(this);
                if (UnityEngine.MonoBehaviour.op_Inequality(ThirdParties.Truongtv.SoundManager.Bgm.instance, null)) {
                    UnityEngine.MonoBehaviour.Destroy(ThirdParties.Truongtv.SoundManager.Bgm.instance.gameObject);
                }
                ThirdParties.Truongtv.SoundManager.Bgm.instance = this;
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.Awake end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#Start", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange = Bridge.fn.combine(ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.Start end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#OnDestroy", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange = Bridge.fn.remove(ThirdParties.Truongtv.SoundManager.SoundManager.OnBgmSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.OnDestroy end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.OnSettingChange start.*/
            OnSettingChange: function (isOn) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#OnSettingChange", this ); }

                this.AudioSource.mute = !isOn;
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.OnSettingChange end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.IsPlaying start.*/
            IsPlaying: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#IsPlaying", this ); }

                return this.AudioSource.isPlaying;
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.IsPlaying end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.IsPlayingClip start.*/
            IsPlayingClip: function (clip) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#IsPlayingClip", this ); }

                return Bridge.referenceEquals(this.AudioSource.clip, clip);
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.IsPlayingClip end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.Play start.*/
            Play: function (clip) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#Play", this ); }

                this.AudioSource.mute = !ThirdParties.Truongtv.SoundManager.SoundManager.IsBgm();
                this.PlayLoop(clip);
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.Play end.*/

            /*ThirdParties.Truongtv.SoundManager.Bgm.Stop$1 start.*/
            Stop$1: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Bgm#Stop$1", this ); }

                if (UnityEngine.Object.op_Implicit(this.AudioSource)) {
                    this.AudioSource.Stop();
                    this.AudioSource.clip = null;
                }
            },
            /*ThirdParties.Truongtv.SoundManager.Bgm.Stop$1 end.*/


        },
        overloads: {
            "Stop()": "Stop$1"
        }
    });
    /*ThirdParties.Truongtv.SoundManager.Bgm end.*/

    /*ThirdParties.Truongtv.SoundManager.Sfx start.*/
    Bridge.define("ThirdParties.Truongtv.SoundManager.Sfx", {
        inherits: [ThirdParties.Truongtv.SoundManager.BaseAudio],
        methods: {
            /*ThirdParties.Truongtv.SoundManager.Sfx.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Sfx#Start", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange = Bridge.fn.combine(ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
            },
            /*ThirdParties.Truongtv.SoundManager.Sfx.Start end.*/

            /*ThirdParties.Truongtv.SoundManager.Sfx.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Sfx#OnDestroy", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange = Bridge.fn.remove(ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
            },
            /*ThirdParties.Truongtv.SoundManager.Sfx.OnDestroy end.*/

            /*ThirdParties.Truongtv.SoundManager.Sfx.OnSettingChange start.*/
            OnSettingChange: function (isOn) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Sfx#OnSettingChange", this ); }

                this.AudioSource.mute = !isOn;
            },
            /*ThirdParties.Truongtv.SoundManager.Sfx.OnSettingChange end.*/

            /*ThirdParties.Truongtv.SoundManager.Sfx.Play start.*/
            Play: function (clip, isLoop, delay, complete) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.Sfx#Play", this ); }

                if (isLoop === void 0) { isLoop = false; }
                if (delay === void 0) { delay = 0.0; }
                if (complete === void 0) { complete = null; }
                this.AudioSource.mute = !ThirdParties.Truongtv.SoundManager.SoundManager.IsSfx();
                if (isLoop) {
                    this.PlayLoop(clip);
                    return;
                }
                this.PlayOnceShot(clip, delay, complete);
            },
            /*ThirdParties.Truongtv.SoundManager.Sfx.Play end.*/


        }
    });
    /*ThirdParties.Truongtv.SoundManager.Sfx end.*/

    /*ThirdParties.Truongtv.SoundManager.SimpleAudio start.*/
    Bridge.define("ThirdParties.Truongtv.SoundManager.SimpleAudio", {
        inherits: [ThirdParties.Truongtv.SoundManager.BaseAudio],
        fields: {
            autoPlay: false,
            loop: false
        },
        methods: {
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#Start", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange = Bridge.fn.combine(ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
                this.AudioSource.loop = this.loop;
                if (this.autoPlay) {
                    this.AudioSource.Play();
                }
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Start end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#OnDestroy", this ); }

                ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange = Bridge.fn.remove(ThirdParties.Truongtv.SoundManager.SoundManager.OnSfxSettingChange, Bridge.fn.cacheBind(this, this.OnSettingChange));
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.OnDestroy end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.OnSettingChange start.*/
            OnSettingChange: function (isOn) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#OnSettingChange", this ); }

                this.AudioSource.mute = !isOn;
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.OnSettingChange end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Play start.*/
            Play: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#Play", this ); }

                this.AudioSource.Play();
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Play end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Play$1 start.*/
            Play$1: function (clip, isLoop) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#Play$1", this ); }

                if (isLoop === void 0) { isLoop = false; }
                this.AudioSource.loop = isLoop;
                this.AudioSource.clip = clip;
                this.AudioSource.Play();
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Play$1 end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.SetLoop start.*/
            SetLoop: function (auto) {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#SetLoop", this ); }

                this.AudioSource.loop = auto;
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.SetLoop end.*/

            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Stop$1 start.*/
            Stop$1: function () {
if ( TRACE ) { TRACE( "ThirdParties.Truongtv.SoundManager.SimpleAudio#Stop$1", this ); }

                this.AudioSource.Stop();
                this.AudioSource.clip = null;
            },
            /*ThirdParties.Truongtv.SoundManager.SimpleAudio.Stop$1 end.*/


        },
        overloads: {
            "Play(AudioClip, bool)": "Play$1",
            "Stop()": "Stop$1"
        }
    });
    /*ThirdParties.Truongtv.SoundManager.SimpleAudio end.*/

    /*Spine.BoundingBoxAttachment start.*/
    /**
     * Attachment that has a polygon for bounds checking.
     *
     * @public
     * @class Spine.BoundingBoxAttachment
     * @augments Spine.VertexAttachment
     */
    Bridge.define("Spine.BoundingBoxAttachment", {
        inherits: [Spine.VertexAttachment],
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.BoundingBoxAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#Copy", this ); }

                var copy = new Spine.BoundingBoxAttachment(this.Name);
                this.CopyTo(copy);
                return copy;
            },
            /*Spine.BoundingBoxAttachment.Copy end.*/


        }
    });
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    Bridge.define("Spine.ClippingAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            endSlot: null
        },
        props: {
            EndSlot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#get", this ); }

                    return this.endSlot;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#set", this ); }

                    this.endSlot = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.ClippingAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#Copy", this ); }

                var copy = new Spine.ClippingAttachment(this.Name);
                this.CopyTo(copy);
                copy.endSlot = this.endSlot;
                return copy;
            },
            /*Spine.ClippingAttachment.Copy end.*/


        }
    });
    /*Spine.ClippingAttachment end.*/

    /*Spine.ColorTimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.ColorTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.ColorTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_R: 0,
                PREV_G: 0,
                PREV_B: 0,
                PREV_A: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.PREV_TIME = -5;
                    this.PREV_R = -4;
                    this.PREV_G = -3;
                    this.PREV_B = -2;
                    this.PREV_A = -1;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                }
            }
        },
        fields: {
            slotIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#PropertyId#get", this ); }

                    return (((83886080) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.ColorTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds, red, green, blue, and alpha values for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.ColorTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.ColorTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.ColorTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, red, green, blue, and alpha for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.ColorTimeline
             * @memberof Spine.ColorTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    r             
             * @param   {number}    g             
             * @param   {number}    b             
             * @param   {number}    a
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, r, g, b, a) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.ColorTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.ColorTimeline.R) | 0)] = r;
                this.frames[((frameIndex + Spine.ColorTimeline.G) | 0)] = g;
                this.frames[((frameIndex + Spine.ColorTimeline.B) | 0)] = b;
                this.frames[((frameIndex + Spine.ColorTimeline.A) | 0)] = a;
            },
            /*Spine.ColorTimeline.SetFrame end.*/

            /*Spine.ColorTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ColorTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var slotData = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = slotData.r;
                            slot.g = slotData.g;
                            slot.b = slotData.b;
                            slot.a = slotData.a;
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slotData.r - slot.r) * alpha;
                            slot.g += (slotData.g - slot.g) * alpha;
                            slot.b += (slotData.b - slot.b) * alpha;
                            slot.a += (slotData.a - slot.a) * alpha;
                            slot.ClampColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a;
                if (time >= frames[((frames.length - Spine.ColorTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    r = frames[((i + Spine.ColorTimeline.PREV_R) | 0)];
                    g = frames[((i + Spine.ColorTimeline.PREV_G) | 0)];
                    b = frames[((i + Spine.ColorTimeline.PREV_B) | 0)];
                    a = frames[((i + Spine.ColorTimeline.PREV_A) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.ColorTimeline.ENTRIES);
                    r = frames[((frame + Spine.ColorTimeline.PREV_R) | 0)];
                    g = frames[((frame + Spine.ColorTimeline.PREV_G) | 0)];
                    b = frames[((frame + Spine.ColorTimeline.PREV_B) | 0)];
                    a = frames[((frame + Spine.ColorTimeline.PREV_A) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.ColorTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.ColorTimeline.PREV_TIME) | 0)] - frameTime));

                    r += (frames[((frame + Spine.ColorTimeline.R) | 0)] - r) * percent;
                    g += (frames[((frame + Spine.ColorTimeline.G) | 0)] - g) * percent;
                    b += (frames[((frame + Spine.ColorTimeline.B) | 0)] - b) * percent;
                    a += (frames[((frame + Spine.ColorTimeline.A) | 0)] - a) * percent;
                }
                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.ClampColor();
                } else {
                    var br, bg, bb, ba;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                    }
                    slot.r = br + ((r - br) * alpha);
                    slot.g = bg + ((g - bg) * alpha);
                    slot.b = bb + ((b - bb) * alpha);
                    slot.a = ba + ((a - ba) * alpha);
                    slot.ClampColor();
                }
            },
            /*Spine.ColorTimeline.Apply end.*/


        }
    });
    /*Spine.ColorTimeline end.*/

    /*Spine.DeformTimeline start.*/
    /**
     * Changes a slot's {@link } to deform a {@link }.
     *
     * @public
     * @class Spine.DeformTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.DeformTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachment: null,
            frames: null,
            frameVertices: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#PropertyId#get", this ); }

                    return (((((805306368) + this.attachment.id) | 0) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The attachment that will be deformed.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Attachment
             * @type Spine.VertexAttachment
             */
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#set", this ); }

                    this.attachment = value;
                }
            },
            /**
             * The time in seconds for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            },
            /**
             * The vertices for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.DeformTimeline
             * @function Vertices
             * @type Array.<Array.<number>>
             */
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#get", this ); }

                    return this.frameVertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#set", this ); }

                    this.frameVertices = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(frameCount, 0, System.Single);
                this.frameVertices = System.Array.init(frameCount, null, System.Array.type(System.Single));
            }
        },
        methods: {
            /*Spine.DeformTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the vertices for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.DeformTimeline
             * @memberof Spine.DeformTimeline
             * @param   {number}            frameIndex    
             * @param   {number}            time          
             * @param   {Array.<number>}    vertices      Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights.
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, vertices) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SetFrame", this ); }

                this.frames[frameIndex] = time;
                this.frameVertices[frameIndex] = vertices;
            },
            /*Spine.DeformTimeline.SetFrame end.*/

            /*Spine.DeformTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var vertexAttachment = Bridge.as(slot.attachment, Spine.VertexAttachment);
                if (vertexAttachment == null || !Bridge.referenceEquals(vertexAttachment.DeformAttachment, this.attachment)) {
                    return;
                }

                var deformArray = slot.Deform;
                if (deformArray.Count === 0) {
                    blend = Spine.MixBlend.Setup;
                }

                var frameVertices = this.frameVertices;
                var vertexCount = frameVertices[0].length;
                var frames = this.frames;
                var deform;

                if (time < frames[0]) { // Time is before first frame.

                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            deformArray.Clear();
                            return;
                        case Spine.MixBlend.First: 
                            if (alpha === 1) {
                                deformArray.Clear();
                                return;
                            }
                            // deformArray.SetSize(vertexCount) // Ensure size and preemptively set count.
                            if (deformArray.Capacity < vertexCount) {
                                deformArray.Capacity = vertexCount;
                            }
                            deformArray.Count = vertexCount;
                            deform = deformArray.Items;
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions.
                                var setupVertices = vertexAttachment.vertices;
                                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                    deform[i] += (setupVertices[i] - deform[i]) * alpha;
                                }
                            } else {
                                // Weighted deform offsets.
                                alpha = 1 - alpha;
                                for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                                    deform[i1] *= alpha;
                                }
                            }
                            return;
                        default: 
                            return;
                    }

                }

                // deformArray.SetSize(vertexCount) // Ensure size and preemptively set count.
                if (deformArray.Capacity < vertexCount) {
                    deformArray.Capacity = vertexCount;
                }
                deformArray.Count = vertexCount;
                deform = deformArray.Items;

                if (time >= frames[((frames.length - 1) | 0)]) { // Time is after last frame.

                    var lastVertices = frameVertices[((frames.length - 1) | 0)];
                    if (alpha === 1) {
                        if (blend === Spine.MixBlend.Add) {
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions, no alpha.
                                var setupVertices1 = vertexAttachment.vertices;
                                for (var i2 = 0; i2 < vertexCount; i2 = (i2 + 1) | 0) {
                                    deform[i2] += lastVertices[i2] - setupVertices1[i2];
                                }
                            } else {
                                // Weighted deform offsets, no alpha.
                                for (var i3 = 0; i3 < vertexCount; i3 = (i3 + 1) | 0) {
                                    deform[i3] += lastVertices[i3];
                                }
                            }
                        } else {
                            // Vertex positions or deform offsets, no alpha.
                            System.Array.copy(lastVertices, 0, deform, 0, vertexCount);
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                {
                                    if (vertexAttachment.bones == null) {
                                        // Unweighted vertex positions, with alpha.
                                        var setupVertices2 = vertexAttachment.vertices;
                                        for (var i4 = 0; i4 < vertexCount; i4 = (i4 + 1) | 0) {
                                            var setup = setupVertices2[i4];
                                            deform[i4] = setup + (lastVertices[i4] - setup) * alpha;
                                        }
                                    } else {
                                        // Weighted deform offsets, with alpha.
                                        for (var i5 = 0; i5 < vertexCount; i5 = (i5 + 1) | 0) {
                                            deform[i5] = lastVertices[i5] * alpha;
                                        }
                                    }
                                    break;
                                }
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                // Vertex positions or deform offsets, with alpha.
                                for (var i6 = 0; i6 < vertexCount; i6 = (i6 + 1) | 0) {
                                    deform[i6] += (lastVertices[i6] - deform[i6]) * alpha;
                                }
                                break;
                            case Spine.MixBlend.Add: 
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, no alpha.
                                    var setupVertices3 = vertexAttachment.vertices;
                                    for (var i7 = 0; i7 < vertexCount; i7 = (i7 + 1) | 0) {
                                        deform[i7] += (lastVertices[i7] - setupVertices3[i7]) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, alpha.
                                    for (var i8 = 0; i8 < vertexCount; i8 = (i8 + 1) | 0) {
                                        deform[i8] += lastVertices[i8] * alpha;
                                    }
                                }
                                break;
                        }
                    }
                    return;
                }

                // Interpolate between the previous frame and the current frame.
                var frame = Spine.Animation.BinarySearch(frames, time);
                var prevVertices = frameVertices[((frame - 1) | 0)];
                var nextVertices = frameVertices[frame];
                var frameTime = frames[frame];
                var percent = this.GetCurvePercent(((frame - 1) | 0), 1 - (time - frameTime) / (frames[((frame - 1) | 0)] - frameTime));

                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        if (vertexAttachment.bones == null) {
                            // Unweighted vertex positions, no alpha.
                            var setupVertices4 = vertexAttachment.vertices;
                            for (var i9 = 0; i9 < vertexCount; i9 = (i9 + 1) | 0) {
                                var prev = prevVertices[i9];
                                deform[i9] += prev + (nextVertices[i9] - prev) * percent - setupVertices4[i9];
                            }
                        } else {
                            // Weighted deform offsets, no alpha.
                            for (var i10 = 0; i10 < vertexCount; i10 = (i10 + 1) | 0) {
                                var prev1 = prevVertices[i10];
                                deform[i10] += prev1 + (nextVertices[i10] - prev1) * percent;
                            }
                        }
                    } else {
                        // Vertex positions or deform offsets, no alpha.
                        for (var i11 = 0; i11 < vertexCount; i11 = (i11 + 1) | 0) {
                            var prev2 = prevVertices[i11];
                            deform[i11] = prev2 + (nextVertices[i11] - prev2) * percent;
                        }
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, with alpha.
                                    var setupVertices5 = vertexAttachment.vertices;
                                    for (var i12 = 0; i12 < vertexCount; i12 = (i12 + 1) | 0) {
                                        var prev3 = prevVertices[i12], setup1 = setupVertices5[i12];
                                        deform[i12] = setup1 + (prev3 + (nextVertices[i12] - prev3) * percent - setup1) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, with alpha.
                                    for (var i13 = 0; i13 < vertexCount; i13 = (i13 + 1) | 0) {
                                        var prev4 = prevVertices[i13];
                                        deform[i13] = (prev4 + (nextVertices[i13] - prev4) * percent) * alpha;
                                    }
                                }
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                // Vertex positions or deform offsets, with alpha.
                                for (var i14 = 0; i14 < vertexCount; i14 = (i14 + 1) | 0) {
                                    var prev5 = prevVertices[i14];
                                    deform[i14] += (prev5 + (nextVertices[i14] - prev5) * percent - deform[i14]) * alpha;
                                }
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            {
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, with alpha.
                                    var setupVertices6 = vertexAttachment.vertices;
                                    for (var i15 = 0; i15 < vertexCount; i15 = (i15 + 1) | 0) {
                                        var prev6 = prevVertices[i15];
                                        deform[i15] += (prev6 + (nextVertices[i15] - prev6) * percent - setupVertices6[i15]) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, with alpha.
                                    for (var i16 = 0; i16 < vertexCount; i16 = (i16 + 1) | 0) {
                                        var prev7 = prevVertices[i16];
                                        deform[i16] += (prev7 + (nextVertices[i16] - prev7) * percent) * alpha;
                                    }
                                }
                                break;
                            }
                    }
                }
            },
            /*Spine.DeformTimeline.Apply end.*/


        }
    });
    /*Spine.DeformTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    /**
     * Changes an IK constraint's {@link }, {@link },
     {@link }, {@link }, and {@link }.
     *
     * @public
     * @class Spine.IkConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.IkConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_MIX: 0,
                PREV_SOFTNESS: 0,
                PREV_BEND_DIRECTION: 0,
                PREV_COMPRESS: 0,
                PREV_STRETCH: 0,
                MIX: 0,
                SOFTNESS: 0,
                BEND_DIRECTION: 0,
                COMPRESS: 0,
                STRETCH: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#init", this ); }

                    this.ENTRIES = 6;
                    this.PREV_TIME = -6;
                    this.PREV_MIX = -5;
                    this.PREV_SOFTNESS = -4;
                    this.PREV_BEND_DIRECTION = -3;
                    this.PREV_COMPRESS = -2;
                    this.PREV_STRETCH = -1;
                    this.MIX = 1;
                    this.SOFTNESS = 2;
                    this.BEND_DIRECTION = 3;
                    this.COMPRESS = 4;
                    this.STRETCH = 5;
                }
            }
        },
        fields: {
            ikConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#PropertyId#get", this ); }

                    return (((150994944) + this.ikConstraintIndex) | 0);
                }
            },
            /**
             * The index of the IK constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintTimeline
             * @function IkConstraintIndex
             * @type number
             */
            IkConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#get", this ); }

                    return this.ikConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.ikConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.IkConstraintTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.IkConstraintTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.IkConstraintTimeline
             * @memberof Spine.IkConstraintTimeline
             * @param   {number}     frameIndex       
             * @param   {number}     time             
             * @param   {number}     mix              
             * @param   {number}     softness         
             * @param   {number}     bendDirection    
             * @param   {boolean}    compress         
             * @param   {boolean}    stretch
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.IkConstraintTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.MIX) | 0)] = mix;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.SOFTNESS) | 0)] = softness;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.BEND_DIRECTION) | 0)] = bendDirection;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.COMPRESS) | 0)] = compress ? 1 : 0;
                this.frames[((frameIndex + Spine.IkConstraintTimeline.STRETCH) | 0)] = stretch ? 1 : 0;
            },
            /*Spine.IkConstraintTimeline.SetFrame end.*/

            /*Spine.IkConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.ikConstraints.Items)[this.ikConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mix = constraint.data.mix;
                            constraint.softness = constraint.data.softness;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                    }
                    return;
                }

                if (time >= frames[((frames.length - Spine.IkConstraintTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    if (blend === Spine.MixBlend.Setup) {
                        constraint.mix = constraint.data.mix + (frames[((frames.length + Spine.IkConstraintTimeline.PREV_MIX) | 0)] - constraint.data.mix) * alpha;
                        constraint.softness = constraint.data.softness + (frames[((frames.length + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)] - constraint.data.softness) * alpha;
                        if (direction === Spine.MixDirection.Out) {
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                        } else {
                            constraint.bendDirection = Bridge.Int.clip32(frames[((frames.length + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                            constraint.compress = frames[((frames.length + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                            constraint.stretch = frames[((frames.length + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                        }
                    } else {
                        constraint.mix += (frames[((frames.length + Spine.IkConstraintTimeline.PREV_MIX) | 0)] - constraint.mix) * alpha;
                        constraint.softness += (frames[((frames.length + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)] - constraint.softness) * alpha;
                        if (direction === Spine.MixDirection.In) {
                            constraint.bendDirection = Bridge.Int.clip32(frames[((frames.length + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                            constraint.compress = frames[((frames.length + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                            constraint.stretch = frames[((frames.length + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                        }
                    }
                    return;
                }

                // Interpolate between the previous frame and the current frame.
                var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.IkConstraintTimeline.ENTRIES);
                var mix = frames[((frame + Spine.IkConstraintTimeline.PREV_MIX) | 0)];
                var softness = frames[((frame + Spine.IkConstraintTimeline.PREV_SOFTNESS) | 0)];
                var frameTime = frames[frame];
                var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.IkConstraintTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.IkConstraintTimeline.PREV_TIME) | 0)] - frameTime));

                if (blend === Spine.MixBlend.Setup) {
                    constraint.mix = constraint.data.mix + (mix + (frames[((frame + Spine.IkConstraintTimeline.MIX) | 0)] - mix) * percent - constraint.data.mix) * alpha;
                    constraint.softness = constraint.data.softness + (softness + (frames[((frame + Spine.IkConstraintTimeline.SOFTNESS) | 0)] - softness) * percent - constraint.data.softness) * alpha;
                    if (direction === Spine.MixDirection.Out) {
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                    } else {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((frame + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((frame + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((frame + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                    }
                } else {
                    constraint.mix += (mix + (frames[((frame + Spine.IkConstraintTimeline.MIX) | 0)] - mix) * percent - constraint.mix) * alpha;
                    constraint.softness += (softness + (frames[((frame + Spine.IkConstraintTimeline.SOFTNESS) | 0)] - softness) * percent - constraint.softness) * alpha;
                    if (direction === Spine.MixDirection.In) {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((frame + Spine.IkConstraintTimeline.PREV_BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((frame + Spine.IkConstraintTimeline.PREV_COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((frame + Spine.IkConstraintTimeline.PREV_STRETCH) | 0)] !== 0;
                    }
                }
            },
            /*Spine.IkConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.MeshAttachment start.*/
    /**
     * Attachment that displays a texture region using a mesh.
     *
     * @public
     * @class Spine.MeshAttachment
     * @augments Spine.VertexAttachment
     * @implements  Spine.IHasRendererObject
     */
    Bridge.define("Spine.MeshAttachment", {
        inherits: [Spine.VertexAttachment,Spine.IHasRendererObject],
        fields: {
            regionOffsetX: 0,
            regionOffsetY: 0,
            regionWidth: 0,
            regionHeight: 0,
            regionOriginalWidth: 0,
            regionOriginalHeight: 0,
            parentMesh: null,
            uvs: null,
            regionUVs: null,
            triangles: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            hulllength: 0,
            Path: null,
            RendererObject: null,
            RegionU: 0,
            RegionV: 0,
            RegionU2: 0,
            RegionV2: 0,
            RegionRotate: false,
            RegionDegrees: 0,
            Edges: null,
            Width: 0,
            Height: 0
        },
        props: {
            HullLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#get", this ); }

                    return this.hulllength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#set", this ); }

                    this.hulllength = value;
                }
            },
            RegionUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#get", this ); }

                    return this.regionUVs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#set", this ); }

                    this.regionUVs = value;
                }
            },
            /**
             * The UV pair for each vertex, normalized within the entire texture. <seealso cref="MeshAttachment.UpdateUVs" />
             *
             * @instance
             * @public
             * @memberof Spine.MeshAttachment
             * @function UVs
             * @type Array.<number>
             * @see {@link MeshAttachment.UpdateUVs}
             */
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#get", this ); }

                    return this.uvs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#set", this ); }

                    this.uvs = value;
                }
            },
            Triangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#get", this ); }

                    return this.triangles;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#set", this ); }

                    this.triangles = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            RegionOffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetX#get", this ); }

                    return this.regionOffsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetX#set", this ); }

                    this.regionOffsetX = value;
                }
            },
            RegionOffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetY#get", this ); }

                    return this.regionOffsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOffsetY#set", this ); }

                    this.regionOffsetY = value;
                }
            },
            RegionWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionWidth#get", this ); }

                    return this.regionWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionWidth#set", this ); }

                    this.regionWidth = value;
                }
            },
            RegionHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionHeight#get", this ); }

                    return this.regionHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionHeight#set", this ); }

                    this.regionHeight = value;
                }
            },
            RegionOriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalWidth#get", this ); }

                    return this.regionOriginalWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalWidth#set", this ); }

                    this.regionOriginalWidth = value;
                }
            },
            RegionOriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalHeight#get", this ); }

                    return this.regionOriginalHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionOriginalHeight#set", this ); }

                    this.regionOriginalHeight = value;
                }
            },
            ParentMesh: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#get", this ); }

                    return this.parentMesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#set", this ); }

                    this.parentMesh = value;
                    if (value != null) {
                        this.bones = value.bones;
                        this.vertices = value.vertices;
                        this.worldVerticesLength = value.worldVerticesLength;
                        this.regionUVs = value.regionUVs;
                        this.triangles = value.triangles;
                        this.HullLength = value.HullLength;
                        this.Edges = value.Edges;
                        this.Width = value.Width;
                        this.Height = value.Height;
                    }
                }
            }
        },
        alias: ["RendererObject", "Spine$IHasRendererObject$RendererObject"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.MeshAttachment.UpdateUVs start.*/
            UpdateUVs: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UpdateUVs", this ); }

                var regionUVs = this.regionUVs;
                if (this.uvs == null || this.uvs.length !== regionUVs.length) {
                    this.uvs = System.Array.init(regionUVs.length, 0, System.Single);
                }
                var uvs = this.uvs;
                var u = this.RegionU, v = this.RegionV, width = 0, height = 0;

                if (this.RegionDegrees === 90) {
                    var textureHeight = this.regionWidth / (this.RegionV2 - this.RegionV);
                    var textureWidth = this.regionHeight / (this.RegionU2 - this.RegionU);
                    u -= (this.RegionOriginalHeight - this.RegionOffsetY - this.RegionHeight) / textureWidth;
                    v -= (this.RegionOriginalWidth - this.RegionOffsetX - this.RegionWidth) / textureHeight;
                    width = this.RegionOriginalHeight / textureWidth;
                    height = this.RegionOriginalWidth / textureHeight;

                    for (var i = 0, n = uvs.length; i < n; i = (i + 2) | 0) {
                        uvs[i] = u + regionUVs[((i + 1) | 0)] * width;
                        uvs[((i + 1) | 0)] = v + (1 - regionUVs[i]) * height;
                    }
                } else if (this.RegionDegrees === 180) {
                    var textureWidth1 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight1 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= (this.RegionOriginalWidth - this.RegionOffsetX - this.RegionWidth) / textureWidth1;
                    v -= this.RegionOffsetY / textureHeight1;
                    width = this.RegionOriginalWidth / textureWidth1;
                    height = this.RegionOriginalHeight / textureHeight1;

                    for (var i1 = 0, n1 = uvs.length; i1 < n1; i1 = (i1 + 2) | 0) {
                        uvs[i1] = u + (1 - regionUVs[i1]) * width;
                        uvs[((i1 + 1) | 0)] = v + (1 - regionUVs[((i1 + 1) | 0)]) * height;
                    }
                } else if (this.RegionDegrees === 270) {
                    var textureWidth2 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight2 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= this.RegionOffsetY / textureWidth2;
                    v -= this.RegionOffsetX / textureHeight2;
                    width = this.RegionOriginalHeight / textureWidth2;
                    height = this.RegionOriginalWidth / textureHeight2;

                    for (var i2 = 0, n2 = uvs.length; i2 < n2; i2 = (i2 + 2) | 0) {
                        uvs[i2] = u + (1 - regionUVs[((i2 + 1) | 0)]) * width;
                        uvs[((i2 + 1) | 0)] = v + regionUVs[i2] * height;
                    }
                } else {
                    var textureWidth3 = this.regionWidth / (this.RegionU2 - this.RegionU);
                    var textureHeight3 = this.regionHeight / (this.RegionV2 - this.RegionV);
                    u -= this.RegionOffsetX / textureWidth3;
                    v -= (this.RegionOriginalHeight - this.RegionOffsetY - this.RegionHeight) / textureHeight3;
                    width = this.RegionOriginalWidth / textureWidth3;
                    height = this.RegionOriginalHeight / textureHeight3;

                    for (var i3 = 0, n3 = uvs.length; i3 < n3; i3 = (i3 + 2) | 0) {
                        uvs[i3] = u + regionUVs[i3] * width;
                        uvs[((i3 + 1) | 0)] = v + regionUVs[((i3 + 1) | 0)] * height;
                    }
                }
            },
            /*Spine.MeshAttachment.UpdateUVs end.*/

            /*Spine.MeshAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Copy", this ); }

                if (this.parentMesh != null) {
                    return this.NewLinkedMesh();
                }

                var copy = new Spine.MeshAttachment(this.Name);
                copy.RendererObject = this.RendererObject;
                copy.regionOffsetX = this.regionOffsetX;
                copy.regionOffsetY = this.regionOffsetY;
                copy.regionWidth = this.regionWidth;
                copy.regionHeight = this.regionHeight;
                copy.regionOriginalWidth = this.regionOriginalWidth;
                copy.regionOriginalHeight = this.regionOriginalHeight;
                copy.RegionRotate = this.RegionRotate;
                copy.RegionDegrees = this.RegionDegrees;
                copy.RegionU = this.RegionU;
                copy.RegionV = this.RegionV;
                copy.RegionU2 = this.RegionU2;
                copy.RegionV2 = this.RegionV2;

                copy.Path = this.Path;
                copy.r = this.r;
                copy.g = this.g;
                copy.b = this.b;
                copy.a = this.a;

                this.CopyTo(copy);
                copy.regionUVs = System.Array.init(this.regionUVs.length, 0, System.Single);
                System.Array.copy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
                copy.uvs = System.Array.init(this.uvs.length, 0, System.Single);
                System.Array.copy(this.uvs, 0, copy.uvs, 0, this.uvs.length);
                copy.triangles = System.Array.init(this.triangles.length, 0, System.Int32);
                System.Array.copy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
                copy.HullLength = this.HullLength;

                // Nonessential.
                if (this.Edges != null) {
                    copy.Edges = System.Array.init(this.Edges.length, 0, System.Int32);
                    System.Array.copy(this.Edges, 0, copy.Edges, 0, this.Edges.length);
                }
                copy.Width = this.Width;
                copy.Height = this.Height;
                return copy;
            },
            /*Spine.MeshAttachment.Copy end.*/

            /*Spine.MeshAttachment.NewLinkedMesh start.*/
            
            NewLinkedMesh: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#NewLinkedMesh", this ); }

                var mesh = new Spine.MeshAttachment(this.Name);
                mesh.RendererObject = this.RendererObject;
                mesh.regionOffsetX = this.regionOffsetX;
                mesh.regionOffsetY = this.regionOffsetY;
                mesh.regionWidth = this.regionWidth;
                mesh.regionHeight = this.regionHeight;
                mesh.regionOriginalWidth = this.regionOriginalWidth;
                mesh.regionOriginalHeight = this.regionOriginalHeight;
                mesh.RegionDegrees = this.RegionDegrees;
                mesh.RegionRotate = this.RegionRotate;
                mesh.RegionU = this.RegionU;
                mesh.RegionV = this.RegionV;
                mesh.RegionU2 = this.RegionU2;
                mesh.RegionV2 = this.RegionV2;

                mesh.Path = this.Path;
                mesh.r = this.r;
                mesh.g = this.g;
                mesh.b = this.b;
                mesh.a = this.a;

                mesh.deformAttachment = this.deformAttachment;
                mesh.ParentMesh = this.parentMesh != null ? this.parentMesh : this;
                mesh.UpdateUVs();
                return mesh;
            },
            /*Spine.MeshAttachment.NewLinkedMesh end.*/


        }
    });
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    Bridge.define("Spine.PathAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            lengths: null,
            closed: false,
            constantSpeed: false
        },
        props: {
            /**
             * The length in the setup pose from the start of the path to the end of each curve.
             *
             * @instance
             * @public
             * @memberof Spine.PathAttachment
             * @function Lengths
             * @type Array.<number>
             */
            Lengths: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#get", this ); }

                    return this.lengths;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#set", this ); }

                    this.lengths = value;
                }
            },
            Closed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#get", this ); }

                    return this.closed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#set", this ); }

                    this.closed = value;
                }
            },
            ConstantSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#get", this ); }

                    return this.constantSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#set", this ); }

                    this.constantSpeed = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, name);
            }
        },
        methods: {
            /*Spine.PathAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Copy", this ); }

                var copy = new Spine.PathAttachment(this.Name);
                this.CopyTo(copy);
                copy.lengths = System.Array.init(this.lengths.length, 0, System.Single);
                System.Array.copy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
                copy.closed = this.closed;
                copy.constantSpeed = this.constantSpeed;
                return copy;
            },
            /*Spine.PathAttachment.Copy end.*/


        }
    });
    /*Spine.PathAttachment end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    /**
     * Changes a path constraint's mixes.
     *
     * @public
     * @class Spine.PathConstraintMixTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.PathConstraintMixTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATE: 0,
                PREV_TRANSLATE: 0,
                ROTATE: 0,
                TRANSLATE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.PREV_TIME = -3;
                    this.PREV_ROTATE = -2;
                    this.PREV_TRANSLATE = -1;
                    this.ROTATE = 1;
                    this.TRANSLATE = 2;
                }
            }
        },
        fields: {
            pathConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PropertyId#get", this ); }

                    return (((218103808) + this.pathConstraintIndex) | 0);
                }
            },
            /**
             * The index of the path constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintMixTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.pathConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, rotate mix, and translate mix for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintMixTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.PathConstraintMixTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.PathConstraintMixTimeline.SetFrame start.*/
            /**
             * The time in seconds, rotate mix, and translate mix for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.PathConstraintMixTimeline
             * @memberof Spine.PathConstraintMixTimeline
             * @param   {number}    frameIndex      
             * @param   {number}    time            
             * @param   {number}    rotateMix       
             * @param   {number}    translateMix
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, rotateMix, translateMix) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.PathConstraintMixTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.PathConstraintMixTimeline.ROTATE) | 0)] = rotateMix;
                this.frames[((frameIndex + Spine.PathConstraintMixTimeline.TRANSLATE) | 0)] = translateMix;
            },
            /*Spine.PathConstraintMixTimeline.SetFrame end.*/

            /*Spine.PathConstraintMixTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.rotateMix = constraint.data.rotateMix;
                            constraint.translateMix = constraint.data.translateMix;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
                            return;
                    }
                    return;
                }

                var rotate, translate;
                if (time >= frames[((frames.length - Spine.PathConstraintMixTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    rotate = frames[((frames.length + Spine.PathConstraintMixTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frames.length + Spine.PathConstraintMixTimeline.PREV_TRANSLATE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintMixTimeline.ENTRIES);
                    rotate = frames[((frame + Spine.PathConstraintMixTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frame + Spine.PathConstraintMixTimeline.PREV_TRANSLATE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintMixTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintMixTimeline.PREV_TIME) | 0)] - frameTime));

                    rotate += (frames[((frame + Spine.PathConstraintMixTimeline.ROTATE) | 0)] - rotate) * percent;
                    translate += (frames[((frame + Spine.PathConstraintMixTimeline.TRANSLATE) | 0)] - translate) * percent;
                }

                if (blend === Spine.MixBlend.Setup) {
                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                }
            },
            /*Spine.PathConstraintMixTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintPositionTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.PathConstraintPositionTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_VALUE: 0,
                VALUE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#init", this ); }

                    this.ENTRIES = 2;
                    this.PREV_TIME = -2;
                    this.PREV_VALUE = -1;
                    this.VALUE = 1;
                }
            }
        },
        fields: {
            pathConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PropertyId#get", this ); }

                    return (((184549376) + this.pathConstraintIndex) | 0);
                }
            },
            /**
             * The index of the path constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintPositionTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.pathConstraintIndex = value;
                }
            },
            /**
             * The time in seconds and path constraint position for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintPositionTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.PathConstraintPositionTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.PathConstraintPositionTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and path constraint position for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.PathConstraintPositionTimeline
             * @memberof Spine.PathConstraintPositionTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    position
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, position) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.PathConstraintPositionTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.PathConstraintPositionTimeline.VALUE) | 0)] = position;
            },
            /*Spine.PathConstraintPositionTimeline.SetFrame end.*/

            /*Spine.PathConstraintPositionTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.position = constraint.data.position;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.position += (constraint.data.position - constraint.position) * alpha;
                            return;
                    }
                    return;
                }

                var position;
                if (time >= frames[((frames.length - Spine.PathConstraintPositionTimeline.ENTRIES) | 0)]) {
                    position = frames[((frames.length + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintPositionTimeline.ENTRIES);
                    position = frames[((frame + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintPositionTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintPositionTimeline.PREV_TIME) | 0)] - frameTime));

                    position += (frames[((frame + Spine.PathConstraintPositionTimeline.VALUE) | 0)] - position) * percent;
                }
                if (blend === Spine.MixBlend.Setup) {
                    constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
                } else {
                    constraint.position += (position - constraint.position) * alpha;
                }
            },
            /*Spine.PathConstraintPositionTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PowOut start.*/
    Bridge.define("Spine.PowOut", {
        inherits: [Spine.Pow],
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.PowOut#ctor", this ); }

                this.$initialize();
                Spine.Pow.ctor.call(this, power);
            }
        },
        methods: {
            /*Spine.PowOut.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.PowOut#Apply$1", this ); }

                return Math.pow(a - 1, this.Power) * (this.Power % 2 === 0 ? -1 : 1) + 1;
            },
            /*Spine.PowOut.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.PowOut end.*/

    /*Spine.RotateTimeline start.*/
    /**
     * Changes a bone's local {@link }.
     *
     * @public
     * @class Spine.RotateTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.RotateTimeline", {
        inherits: [Spine.CurveTimeline,Spine.IBoneTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATION: 0,
                ROTATION: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#init", this ); }

                    this.ENTRIES = 2;
                    this.PREV_TIME = -2;
                    this.PREV_ROTATION = -1;
                    this.ROTATION = 1;
                }
            }
        },
        fields: {
            boneIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#PropertyId#get", this ); }

                    return (((0) + this.boneIndex) | 0);
                }
            },
            /**
             * The index of the bone in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.RotateTimeline
             * @function BoneIndex
             * @type number
             */
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.boneIndex = value;
                }
            },
            /**
             * The time in seconds and rotation in degrees for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.RotateTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "BoneIndex", "Spine$IBoneTimeline$BoneIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(frameCount << 1, 0, System.Single);
            }
        },
        methods: {
            /*Spine.RotateTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds and the rotation in degrees for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.RotateTimeline
             * @memberof Spine.RotateTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    degrees
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, degrees) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#SetFrame", this ); }

                frameIndex = frameIndex << 1;
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.RotateTimeline.ROTATION) | 0)] = degrees;
            },
            /*Spine.RotateTimeline.SetFrame end.*/

            /*Spine.RotateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Apply", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    bone, 
                    $t, 
                    frames, 
                    r, 
                    r1, 
                    frame, 
                    prevRotation, 
                    frameTime, 
                    percent, 
                    r2, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10], $step);
                            switch ($step) {
                                case 0: {
                                    bone = ($t = skeleton.bones.Items)[this.boneIndex];
                                    if (!bone.active) {
                                        return;
                                    }
                                    frames = this.frames;
                                    if (time < frames[0]) { // Time is before first frame.
                                        switch (blend) {
                                            case Spine.MixBlend.Setup: 
                                                bone.rotation = bone.data.rotation;
                                                return;
                                            case Spine.MixBlend.First: 
                                                r = bone.data.rotation - bone.rotation;
                                                bone.rotation += (r - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r / 360))) | 0)), 360)) * alpha;
                                                return;
                                        }
                                        return;
                                    }

                                    if (time >= frames[((frames.length - Spine.RotateTimeline.ENTRIES) | 0)]) {
                                        $step = 1;
                                        continue;
                                    } 
                                    $step = 6;
                                    continue;
                                }
                                case 1: {
                                    // Time is after last frame.
                                    r1 = frames[((frames.length + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                                    if (blend === Spine.MixBlend.Setup) {
                                        $step = 2;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.First || blend === Spine.MixBlend.Replace) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.Add) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    bone.rotation = bone.data.rotation + r1 * alpha;
                                    $step = 5;
                                    continue;
                                }
                                case 3: {
                                    r1 += bone.data.rotation - bone.rotation;
                                    r1 -= Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r1 / 360))) | 0)), 360);
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    bone.rotation += r1 * alpha;
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    return;
                                }
                                case 6: {
                                    // Interpolate between the previous frame and the current frame.
                                    frame = Spine.Animation.BinarySearch$1(frames, time, Spine.RotateTimeline.ENTRIES);
                                    prevRotation = frames[((frame + Spine.RotateTimeline.PREV_ROTATION) | 0)];
                                    frameTime = frames[frame];
                                    percent = this.GetCurvePercent((((frame >> 1) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.RotateTimeline.PREV_TIME) | 0)] - frameTime));
                                    // scope for 'r' to prevent compile error.
                                    r2 = frames[((frame + Spine.RotateTimeline.ROTATION) | 0)] - prevRotation;
                                    r2 = prevRotation + (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * percent;
                                    if (blend === Spine.MixBlend.Setup) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.First || blend === Spine.MixBlend.Replace) {
                                        $step = 8;
                                        continue;
                                    }
                                    else if (blend === Spine.MixBlend.Add) {
                                        $step = 9;
                                        continue;
                                    }
                                    $step = 10;
                                    continue;
                                }
                                case 7: {
                                    bone.rotation = bone.data.rotation + (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * alpha;
                                    $step = 10;
                                    continue;
                                }
                                case 8: {
                                    r2 += bone.data.rotation - bone.rotation;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    bone.rotation += (r2 - Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - r2 / 360))) | 0)), 360)) * alpha;
                                    $step = 10;
                                    continue;
                                }
                                case 10: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.RotateTimeline.Apply end.*/


        }
    });
    /*Spine.RotateTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    
    Bridge.define("Spine.TranslateTimeline", {
        inherits: [Spine.CurveTimeline,Spine.IBoneTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_X: 0,
                PREV_Y: 0,
                X: 0,
                Y: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.PREV_TIME = -3;
                    this.PREV_X = -2;
                    this.PREV_Y = -1;
                    this.X = 1;
                    this.Y = 2;
                }
            }
        },
        fields: {
            boneIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#PropertyId#get", this ); }

                    return (((16777216) + this.boneIndex) | 0);
                }
            },
            /**
             * The index of the bone in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TranslateTimeline
             * @function BoneIndex
             * @type number
             */
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.boneIndex = value;
                }
            },
            /**
             * The time in seconds, x, and y values for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.TranslateTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "BoneIndex", "Spine$IBoneTimeline$BoneIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TranslateTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TranslateTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, x, and y values for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.TranslateTimeline
             * @memberof Spine.TranslateTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    x             
             * @param   {number}    y
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, x, y) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TranslateTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TranslateTimeline.X) | 0)] = x;
                this.frames[((frameIndex + Spine.TranslateTimeline.Y) | 0)] = y;
            },
            /*Spine.TranslateTimeline.SetFrame end.*/

            /*Spine.TranslateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            return;
                        case Spine.MixBlend.First: 
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x += (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent;
                    y += (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.x = bone.data.x + x * alpha;
                        bone.y = bone.data.y + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.x += (bone.data.x + x - bone.x) * alpha;
                        bone.y += (bone.data.y + y - bone.y) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.x += x * alpha;
                        bone.y += y * alpha;
                        break;
                }
            },
            /*Spine.TranslateTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    /**
     * Changes a transform constraint's mixes.
     *
     * @public
     * @class Spine.TransformConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.TransformConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_ROTATE: 0,
                PREV_TRANSLATE: 0,
                PREV_SCALE: 0,
                PREV_SHEAR: 0,
                ROTATE: 0,
                TRANSLATE: 0,
                SCALE: 0,
                SHEAR: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.PREV_TIME = -5;
                    this.PREV_ROTATE = -4;
                    this.PREV_TRANSLATE = -3;
                    this.PREV_SCALE = -2;
                    this.PREV_SHEAR = -1;
                    this.ROTATE = 1;
                    this.TRANSLATE = 2;
                    this.SCALE = 3;
                    this.SHEAR = 4;
                }
            }
        },
        fields: {
            transformConstraintIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#PropertyId#get", this ); }

                    return (((167772160) + this.transformConstraintIndex) | 0);
                }
            },
            /**
             * The index of the transform constraint slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintTimeline
             * @function TransformConstraintIndex
             * @type number
             */
            TransformConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#get", this ); }

                    return this.transformConstraintIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.transformConstraintIndex = value;
                }
            },
            /**
             * The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Frames#get", this ); }

                    return this.frames;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Frames#set", this ); }

                    this.frames = value;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TransformConstraintTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TransformConstraintTimeline.SetFrame start.*/
            /**
             * The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraintTimeline
             * @memberof Spine.TransformConstraintTimeline
             * @param   {number}    frameIndex      
             * @param   {number}    time            
             * @param   {number}    rotateMix       
             * @param   {number}    translateMix    
             * @param   {number}    scaleMix        
             * @param   {number}    shearMix
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TransformConstraintTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.ROTATE) | 0)] = rotateMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.TRANSLATE) | 0)] = translateMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.SCALE) | 0)] = scaleMix;
                this.frames[((frameIndex + Spine.TransformConstraintTimeline.SHEAR) | 0)] = shearMix;
            },
            /*Spine.TransformConstraintTimeline.SetFrame end.*/

            /*Spine.TransformConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.transformConstraints.Items)[this.transformConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var data = constraint.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.rotateMix = data.rotateMix;
                            constraint.translateMix = data.translateMix;
                            constraint.scaleMix = data.scaleMix;
                            constraint.shearMix = data.shearMix;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
                            return;
                    }
                    return;
                }

                var rotate, translate, scale, shear;
                if (time >= frames[((frames.length - Spine.TransformConstraintTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    rotate = frames[((i + Spine.TransformConstraintTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((i + Spine.TransformConstraintTimeline.PREV_TRANSLATE) | 0)];
                    scale = frames[((i + Spine.TransformConstraintTimeline.PREV_SCALE) | 0)];
                    shear = frames[((i + Spine.TransformConstraintTimeline.PREV_SHEAR) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TransformConstraintTimeline.ENTRIES);
                    rotate = frames[((frame + Spine.TransformConstraintTimeline.PREV_ROTATE) | 0)];
                    translate = frames[((frame + Spine.TransformConstraintTimeline.PREV_TRANSLATE) | 0)];
                    scale = frames[((frame + Spine.TransformConstraintTimeline.PREV_SCALE) | 0)];
                    shear = frames[((frame + Spine.TransformConstraintTimeline.PREV_SHEAR) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TransformConstraintTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TransformConstraintTimeline.PREV_TIME) | 0)] - frameTime));

                    rotate += (frames[((frame + Spine.TransformConstraintTimeline.ROTATE) | 0)] - rotate) * percent;
                    translate += (frames[((frame + Spine.TransformConstraintTimeline.TRANSLATE) | 0)] - translate) * percent;
                    scale += (frames[((frame + Spine.TransformConstraintTimeline.SCALE) | 0)] - scale) * percent;
                    shear += (frames[((frame + Spine.TransformConstraintTimeline.SHEAR) | 0)] - shear) * percent;
                }
                if (blend === Spine.MixBlend.Setup) {
                    var data1 = constraint.data;
                    constraint.rotateMix = data1.rotateMix + (rotate - data1.rotateMix) * alpha;
                    constraint.translateMix = data1.translateMix + (translate - data1.translateMix) * alpha;
                    constraint.scaleMix = data1.scaleMix + (scale - data1.scaleMix) * alpha;
                    constraint.shearMix = data1.shearMix + (shear - data1.shearMix) * alpha;
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
                    constraint.shearMix += (shear - constraint.shearMix) * alpha;
                }
            },
            /*Spine.TransformConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.TwoColorTimeline start.*/
    /**
     * Changes a slot's {@link } and {@link } for two color tinting.
     *
     * @public
     * @class Spine.TwoColorTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.TwoColorTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                PREV_TIME: 0,
                PREV_R: 0,
                PREV_G: 0,
                PREV_B: 0,
                PREV_A: 0,
                PREV_R2: 0,
                PREV_G2: 0,
                PREV_B2: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#init", this ); }

                    this.ENTRIES = 8;
                    this.PREV_TIME = -8;
                    this.PREV_R = -7;
                    this.PREV_G = -6;
                    this.PREV_B = -5;
                    this.PREV_A = -4;
                    this.PREV_R2 = -3;
                    this.PREV_G2 = -2;
                    this.PREV_B2 = -1;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                    this.R2 = 5;
                    this.G2 = 6;
                    this.B2 = 7;
                }
            }
        },
        fields: {
            slotIndex: 0,
            frames: null
        },
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#PropertyId#get", this ); }

                    return (((234881024) + this.slotIndex) | 0);
                }
            },
            /**
             * The index of the slot in {@link } that will be changed.
             *
             * @instance
             * @public
             * @memberof Spine.TwoColorTimeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SlotIndex#set", this ); }

                    if (value < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index must be >= 0.");
                    }
                    this.slotIndex = value;
                }
            },
            /**
             * The time in seconds, red, green, blue, and alpha values for each key frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TwoColorTimeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#Frames#get", this ); }

                    return this.frames;
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "SlotIndex", "Spine$ISlotTimeline$SlotIndex",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount);
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, Spine.TwoColorTimeline.ENTRIES), 0, System.Single);
            }
        },
        methods: {
            /*Spine.TwoColorTimeline.SetFrame start.*/
            /**
             * Sets the time in seconds, light, and dark colors for the specified key frame..
             *
             * @instance
             * @public
             * @this Spine.TwoColorTimeline
             * @memberof Spine.TwoColorTimeline
             * @param   {number}    frameIndex    
             * @param   {number}    time          
             * @param   {number}    r             
             * @param   {number}    g             
             * @param   {number}    b             
             * @param   {number}    a             
             * @param   {number}    r2            
             * @param   {number}    g2            
             * @param   {number}    b2
             * @return  {void}
             */
            SetFrame: function (frameIndex, time, r, g, b, a, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#SetFrame", this ); }

                frameIndex = Bridge.Int.mul(frameIndex, Spine.TwoColorTimeline.ENTRIES);
                this.frames[frameIndex] = time;
                this.frames[((frameIndex + Spine.TwoColorTimeline.R) | 0)] = r;
                this.frames[((frameIndex + Spine.TwoColorTimeline.G) | 0)] = g;
                this.frames[((frameIndex + Spine.TwoColorTimeline.B) | 0)] = b;
                this.frames[((frameIndex + Spine.TwoColorTimeline.A) | 0)] = a;
                this.frames[((frameIndex + Spine.TwoColorTimeline.R2) | 0)] = r2;
                this.frames[((frameIndex + Spine.TwoColorTimeline.G2) | 0)] = g2;
                this.frames[((frameIndex + Spine.TwoColorTimeline.B2) | 0)] = b2;
            },
            /*Spine.TwoColorTimeline.SetFrame end.*/

            /*Spine.TwoColorTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TwoColorTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    var slotData = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            //	slot.color.set(slot.data.color);
                            //	slot.darkColor.set(slot.data.darkColor);
                            slot.r = slotData.r;
                            slot.g = slotData.g;
                            slot.b = slotData.b;
                            slot.a = slotData.a;
                            slot.ClampColor();
                            slot.r2 = slotData.r2;
                            slot.g2 = slotData.g2;
                            slot.b2 = slotData.b2;
                            slot.ClampSecondColor();
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - slotData.r) * alpha;
                            slot.g += (slot.g - slotData.g) * alpha;
                            slot.b += (slot.b - slotData.b) * alpha;
                            slot.a += (slot.a - slotData.a) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - slotData.r2) * alpha;
                            slot.g2 += (slot.g2 - slotData.g2) * alpha;
                            slot.b2 += (slot.b2 - slotData.b2) * alpha;
                            slot.ClampSecondColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a, r2, g2, b2;
                if (time >= frames[((frames.length - Spine.TwoColorTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    var i = frames.length;
                    r = frames[((i + Spine.TwoColorTimeline.PREV_R) | 0)];
                    g = frames[((i + Spine.TwoColorTimeline.PREV_G) | 0)];
                    b = frames[((i + Spine.TwoColorTimeline.PREV_B) | 0)];
                    a = frames[((i + Spine.TwoColorTimeline.PREV_A) | 0)];
                    r2 = frames[((i + Spine.TwoColorTimeline.PREV_R2) | 0)];
                    g2 = frames[((i + Spine.TwoColorTimeline.PREV_G2) | 0)];
                    b2 = frames[((i + Spine.TwoColorTimeline.PREV_B2) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TwoColorTimeline.ENTRIES);
                    r = frames[((frame + Spine.TwoColorTimeline.PREV_R) | 0)];
                    g = frames[((frame + Spine.TwoColorTimeline.PREV_G) | 0)];
                    b = frames[((frame + Spine.TwoColorTimeline.PREV_B) | 0)];
                    a = frames[((frame + Spine.TwoColorTimeline.PREV_A) | 0)];
                    r2 = frames[((frame + Spine.TwoColorTimeline.PREV_R2) | 0)];
                    g2 = frames[((frame + Spine.TwoColorTimeline.PREV_G2) | 0)];
                    b2 = frames[((frame + Spine.TwoColorTimeline.PREV_B2) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TwoColorTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TwoColorTimeline.PREV_TIME) | 0)] - frameTime));

                    r += (frames[((frame + Spine.TwoColorTimeline.R) | 0)] - r) * percent;
                    g += (frames[((frame + Spine.TwoColorTimeline.G) | 0)] - g) * percent;
                    b += (frames[((frame + Spine.TwoColorTimeline.B) | 0)] - b) * percent;
                    a += (frames[((frame + Spine.TwoColorTimeline.A) | 0)] - a) * percent;
                    r2 += (frames[((frame + Spine.TwoColorTimeline.R2) | 0)] - r2) * percent;
                    g2 += (frames[((frame + Spine.TwoColorTimeline.G2) | 0)] - g2) * percent;
                    b2 += (frames[((frame + Spine.TwoColorTimeline.B2) | 0)] - b2) * percent;
                }
                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.ClampColor();
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                    slot.ClampSecondColor();
                } else {
                    var br, bg, bb, ba, br2, bg2, bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                        br2 = slot.data.r2;
                        bg2 = slot.data.g2;
                        bb2 = slot.data.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + ((r - br) * alpha);
                    slot.g = bg + ((g - bg) * alpha);
                    slot.b = bb + ((b - bb) * alpha);
                    slot.a = ba + ((a - ba) * alpha);
                    slot.ClampColor();
                    slot.r2 = br2 + ((r2 - br2) * alpha);
                    slot.g2 = bg2 + ((g2 - bg2) * alpha);
                    slot.b2 = bb2 + ((b2 - bb2) * alpha);
                    slot.ClampSecondColor();
                }
            },
            /*Spine.TwoColorTimeline.Apply end.*/


        }
    });
    /*Spine.TwoColorTimeline end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.GetCurrent(0);
                        return entry == null ? null : entry.Animation.Name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.GetCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.ClearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(value);
                        if (animationObject != null) {
                            this.state.SetAnimation(0, animationObject, this.loop);
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.ClearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.loop);
                    }
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }


                this.Update(UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.Update(deltaTime);
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.UpdateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            }
        },
        alias: [
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }

                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.UpdateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.UpdateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintSpacingTimeline
     * @augments Spine.PathConstraintPositionTimeline
     */
    Bridge.define("Spine.PathConstraintSpacingTimeline", {
        inherits: [Spine.PathConstraintPositionTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#PropertyId#get", this ); }

                    return (((201326592) + this.pathConstraintIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#ctor", this ); }

                this.$initialize();
                Spine.PathConstraintPositionTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.PathConstraintSpacingTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.spacing = constraint.data.spacing;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
                            return;
                    }
                    return;
                }

                var spacing;
                if (time >= frames[((frames.length - Spine.PathConstraintPositionTimeline.ENTRIES) | 0)]) {
                    spacing = frames[((frames.length + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.PathConstraintPositionTimeline.ENTRIES);
                    spacing = frames[((frame + Spine.PathConstraintPositionTimeline.PREV_VALUE) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.PathConstraintPositionTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.PathConstraintPositionTimeline.PREV_TIME) | 0)] - frameTime));

                    spacing += (frames[((frame + Spine.PathConstraintPositionTimeline.VALUE) | 0)] - spacing) * percent;
                }

                if (blend === Spine.MixBlend.Setup) {
                    constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
                } else {
                    constraint.spacing += (spacing - constraint.spacing) * alpha;
                }
            },
            /*Spine.PathConstraintSpacingTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    
    Bridge.define("Spine.ScaleTimeline", {
        inherits: [Spine.TranslateTimeline,Spine.IBoneTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#PropertyId#get", this ); }

                    return (((33554432) + this.boneIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#ctor", this ); }

                this.$initialize();
                Spine.TranslateTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.ScaleTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)] * bone.data.scaleX;
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)] * bone.data.scaleY;
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x = (x + (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent) * bone.data.scaleX;
                    y = (y + (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent) * bone.data.scaleY;
                }
                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleX += x - bone.data.scaleX;
                        bone.scaleY += y - bone.data.scaleY;
                    } else {
                        bone.scaleX = x;
                        bone.scaleY = y;
                    }
                } else {
                    // Mixing out uses sign of setup or current pose, else use sign of key.
                    var bx, by;
                    if (direction === Spine.MixDirection.Out) {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = bone.data.scaleX;
                                by = bone.data.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = bone.scaleX;
                                by = bone.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bx = bone.scaleX;
                                by = bone.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bone.data.scaleX) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - bone.data.scaleY) * alpha;
                                break;
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = Math.abs(bone.data.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.data.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = Math.abs(bone.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bx = Bridge.Int.sign(x);
                                by = Bridge.Int.sign(y);
                                bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
                                bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
                                break;
                        }
                    }
                }
            },
            /*Spine.ScaleTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleTimeline end.*/

    /*Spine.ShearTimeline start.*/
    /**
     * Changes a bone's local {@link } and {@link }.
     *
     * @public
     * @class Spine.ShearTimeline
     * @augments Spine.TranslateTimeline
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.ShearTimeline", {
        inherits: [Spine.TranslateTimeline,Spine.IBoneTimeline],
        props: {
            PropertyId: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#PropertyId#get", this ); }

                    return (((50331648) + this.boneIndex) | 0);
                }
            }
        },
        alias: [
            "PropertyId", "Spine$Timeline$PropertyId",
            "Apply", "Spine$Timeline$Apply"
        ],
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#ctor", this ); }

                this.$initialize();
                Spine.TranslateTimeline.ctor.call(this, frameCount);
            }
        },
        methods: {
            /*Spine.ShearTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                if (time >= frames[((frames.length - Spine.TranslateTimeline.ENTRIES) | 0)]) { // Time is after last frame.
                    x = frames[((frames.length + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frames.length + Spine.TranslateTimeline.PREV_Y) | 0)];
                } else {
                    // Interpolate between the previous frame and the current frame.
                    var frame = Spine.Animation.BinarySearch$1(frames, time, Spine.TranslateTimeline.ENTRIES);
                    x = frames[((frame + Spine.TranslateTimeline.PREV_X) | 0)];
                    y = frames[((frame + Spine.TranslateTimeline.PREV_Y) | 0)];
                    var frameTime = frames[frame];
                    var percent = this.GetCurvePercent(((((Bridge.Int.div(frame, Spine.TranslateTimeline.ENTRIES)) | 0) - 1) | 0), 1 - (time - frameTime) / (frames[((frame + Spine.TranslateTimeline.PREV_TIME) | 0)] - frameTime));

                    x = x + (frames[((frame + Spine.TranslateTimeline.X) | 0)] - x) * percent;
                    y = y + (frames[((frame + Spine.TranslateTimeline.Y) | 0)] - y) * percent;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearX = bone.data.shearX + x * alpha;
                        bone.shearY = bone.data.shearY + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearX += x * alpha;
                        bone.shearY += y * alpha;
                        break;
                }
            },
            /*Spine.ShearTimeline.Apply end.*/


        }
    });
    /*Spine.ShearTimeline end.*/

    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","System.Collections.Generic","UnityEngine.EventSystems","UnityEngine.UI","System.Collections","ThirdParties.Truongtv.SoundManager","SharpJson","Spine","System.IO","Spine.Collections","Spine.Unity","UnityEngine.Rendering","Spine.Unity.Deprecated","TMPro","Projects.Scripts.GamePlay.Building","Projects.Scripts.UIController","Projects.Scripts.GamePlay.CharacterController","Projects.Scripts.Models","UnityEngine.Events","Projects.Scripts.GamePlay.Sound","EpicToonFX","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*ETFXProjectileScript start.*/
    $m("ETFXProjectileScript", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"collideOffset","t":4,"rt":$n[0].Single,"sn":"collideOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Adjust if not using Sphere Collider")],"a":2,"n":"colliderRadius","t":4,"rt":$n[0].Single,"sn":"colliderRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"impactParticle","t":4,"rt":$n[1].GameObject,"sn":"impactParticle"},{"a":2,"n":"muzzleParticle","t":4,"rt":$n[1].GameObject,"sn":"muzzleParticle"},{"a":2,"n":"projectileParticle","t":4,"rt":$n[1].GameObject,"sn":"projectileParticle"}]}; }, $n);
    /*ETFXProjectileScript end.*/

    /*ETFXSceneManager start.*/
    $m("ETFXSceneManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"LoadScene2DDemo","t":8,"sn":"LoadScene2DDemo","rt":$n[0].Void},{"a":2,"n":"LoadSceneCards","t":8,"sn":"LoadSceneCards","rt":$n[0].Void},{"a":2,"n":"LoadSceneCombat","t":8,"sn":"LoadSceneCombat","rt":$n[0].Void},{"a":2,"n":"LoadSceneDecals","t":8,"sn":"LoadSceneDecals","rt":$n[0].Void},{"a":2,"n":"LoadSceneDecals2","t":8,"sn":"LoadSceneDecals2","rt":$n[0].Void},{"a":2,"n":"LoadSceneEmojis","t":8,"sn":"LoadSceneEmojis","rt":$n[0].Void},{"a":2,"n":"LoadSceneEmojis2","t":8,"sn":"LoadSceneEmojis2","rt":$n[0].Void},{"a":2,"n":"LoadSceneExplosions","t":8,"sn":"LoadSceneExplosions","rt":$n[0].Void},{"a":2,"n":"LoadSceneExplosions2","t":8,"sn":"LoadSceneExplosions2","rt":$n[0].Void},{"a":2,"n":"LoadSceneFire","t":8,"sn":"LoadSceneFire","rt":$n[0].Void},{"a":2,"n":"LoadSceneFire2","t":8,"sn":"LoadSceneFire2","rt":$n[0].Void},{"a":2,"n":"LoadSceneFire3","t":8,"sn":"LoadSceneFire3","rt":$n[0].Void},{"a":2,"n":"LoadSceneFireworks","t":8,"sn":"LoadSceneFireworks","rt":$n[0].Void},{"a":2,"n":"LoadSceneFlares","t":8,"sn":"LoadSceneFlares","rt":$n[0].Void},{"a":2,"n":"LoadSceneHealing","t":8,"sn":"LoadSceneHealing","rt":$n[0].Void},{"a":2,"n":"LoadSceneMagic","t":8,"sn":"LoadSceneMagic","rt":$n[0].Void},{"a":2,"n":"LoadSceneMagic2","t":8,"sn":"LoadSceneMagic2","rt":$n[0].Void},{"a":2,"n":"LoadSceneMagic3","t":8,"sn":"LoadSceneMagic3","rt":$n[0].Void},{"a":2,"n":"LoadSceneMainDemo","t":8,"sn":"LoadSceneMainDemo","rt":$n[0].Void},{"a":2,"n":"LoadSceneMissiles","t":8,"sn":"LoadSceneMissiles","rt":$n[0].Void},{"a":2,"n":"LoadSceneMoney","t":8,"sn":"LoadSceneMoney","rt":$n[0].Void},{"a":2,"n":"LoadScenePortals","t":8,"sn":"LoadScenePortals","rt":$n[0].Void},{"a":2,"n":"LoadScenePortals2","t":8,"sn":"LoadScenePortals2","rt":$n[0].Void},{"a":2,"n":"LoadScenePowerups","t":8,"sn":"LoadScenePowerups","rt":$n[0].Void},{"a":2,"n":"LoadScenePowerups2","t":8,"sn":"LoadScenePowerups2","rt":$n[0].Void},{"a":2,"n":"LoadSceneSparkles","t":8,"sn":"LoadSceneSparkles","rt":$n[0].Void},{"a":2,"n":"LoadSceneSwordCombat","t":8,"sn":"LoadSceneSwordCombat","rt":$n[0].Void},{"a":2,"n":"LoadSceneSwordCombat2","t":8,"sn":"LoadSceneSwordCombat2","rt":$n[0].Void},{"a":2,"n":"LoadSceneWind","t":8,"sn":"LoadSceneWind","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"GUIHide","t":4,"rt":$n[0].Boolean,"sn":"GUIHide","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GUIHide2","t":4,"rt":$n[0].Boolean,"sn":"GUIHide2","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GUIHide3","t":4,"rt":$n[0].Boolean,"sn":"GUIHide3","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GUIHide4","t":4,"rt":$n[0].Boolean,"sn":"GUIHide4","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*ETFXSceneManager end.*/

    /*ParticleEffectsLibrary start.*/
    $m("ParticleEffectsLibrary", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"GetCurrentPENameString","t":8,"sn":"GetCurrentPENameString","rt":$n[0].String},{"a":2,"n":"NextParticleEffect","t":8,"sn":"NextParticleEffect","rt":$n[0].Void},{"a":2,"n":"PreviousParticleEffect","t":8,"sn":"PreviousParticleEffect","rt":$n[0].Void},{"a":2,"n":"SpawnParticleEffect","t":8,"pi":[{"n":"positionInWorldToSpawn","pt":$n[1].Vector3,"ps":0}],"sn":"SpawnParticleEffect","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentParticleEffectIndex","t":4,"rt":$n[0].Int32,"sn":"CurrentParticleEffectIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CurrentParticleEffectNum","t":4,"rt":$n[0].Int32,"sn":"CurrentParticleEffectNum","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GlobalAccess","is":true,"t":4,"rt":ParticleEffectsLibrary,"sn":"GlobalAccess"},{"a":2,"n":"ParticleEffectLifetimes","t":4,"rt":$n[0].Array.type(System.Single),"sn":"ParticleEffectLifetimes"},{"a":2,"n":"ParticleEffectPrefabs","t":4,"rt":System.Array.type(UnityEngine.GameObject),"sn":"ParticleEffectPrefabs"},{"a":2,"n":"ParticleEffectSpawnOffsets","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"ParticleEffectSpawnOffsets"},{"a":2,"n":"TotalEffects","t":4,"rt":$n[0].Int32,"sn":"TotalEffects","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"currentActivePEList","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"currentActivePEList"},{"a":1,"n":"effectNameString","t":4,"rt":$n[0].String,"sn":"effectNameString"},{"a":1,"n":"spawnPosition","t":4,"rt":$n[1].Vector3,"sn":"spawnPosition"}]}; }, $n);
    /*ParticleEffectsLibrary end.*/

    /*ButtonTypes start.*/
    $m("ButtonTypes", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Next","is":true,"t":4,"rt":ButtonTypes,"sn":"Next","box":function ($v) { return Bridge.box($v, ButtonTypes, System.Enum.toStringFn(ButtonTypes));}},{"a":2,"n":"NotDefined","is":true,"t":4,"rt":ButtonTypes,"sn":"NotDefined","box":function ($v) { return Bridge.box($v, ButtonTypes, System.Enum.toStringFn(ButtonTypes));}},{"a":2,"n":"Previous","is":true,"t":4,"rt":ButtonTypes,"sn":"Previous","box":function ($v) { return Bridge.box($v, ButtonTypes, System.Enum.toStringFn(ButtonTypes));}}]}; }, $n);
    /*ButtonTypes end.*/

    /*PEButtonScript start.*/
    $m("PEButtonScript", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnButtonClicked","t":8,"sn":"OnButtonClicked","rt":$n[0].Void},{"a":2,"n":"OnPointerEnter","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerEnter","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerExit","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerExit","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"ButtonType","t":4,"rt":ButtonTypes,"sn":"ButtonType","box":function ($v) { return Bridge.box($v, ButtonTypes, System.Enum.toStringFn(ButtonTypes));}},{"a":1,"n":"myButton","t":4,"rt":$n[4].Button,"sn":"myButton"}]}; }, $n);
    /*PEButtonScript end.*/

    /*UICanvasManager start.*/
    $m("UICanvasManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ClearToolTip","t":8,"sn":"ClearToolTip","rt":$n[0].Void},{"a":1,"n":"SelectNextPE","t":8,"sn":"SelectNextPE","rt":$n[0].Void},{"a":1,"n":"SelectPreviousPE","t":8,"sn":"SelectPreviousPE","rt":$n[0].Void},{"a":1,"n":"SpawnCurrentParticleEffect","t":8,"sn":"SpawnCurrentParticleEffect","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UIButtonClick","t":8,"pi":[{"n":"buttonTypeClicked","pt":ButtonTypes,"ps":0}],"sn":"UIButtonClick","rt":$n[0].Void,"p":[ButtonTypes]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"UpdateToolTip","t":8,"pi":[{"n":"toolTipType","pt":ButtonTypes,"ps":0}],"sn":"UpdateToolTip","rt":$n[0].Void,"p":[ButtonTypes]},{"a":2,"n":"GlobalAccess","is":true,"t":4,"rt":UICanvasManager,"sn":"GlobalAccess"},{"a":2,"n":"MouseOverButton","t":4,"rt":$n[0].Boolean,"sn":"MouseOverButton","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PENameText","t":4,"rt":$n[4].Text,"sn":"PENameText"},{"a":2,"n":"ToolTipText","t":4,"rt":$n[4].Text,"sn":"ToolTipText"},{"a":1,"n":"rayHit","t":4,"rt":$n[1].RaycastHit,"sn":"rayHit"}]}; }, $n);
    /*UICanvasManager end.*/

    /*CameraFollower start.*/
    $m("CameraFollower", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"maxY","t":4,"rt":$n[0].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"target","t":4,"rt":$n[1].Transform,"sn":"target"}]}; }, $n);
    /*CameraFollower end.*/

    /*BrokenPlatform start.*/
    $m("BrokenPlatform", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"coll","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"breakDelay","t":4,"rt":$n[0].Single,"sn":"breakDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"breakDelayEffect","t":4,"rt":$n[1].ParticleSystem,"sn":"breakDelayEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"breakEffect","t":4,"rt":$n[1].ParticleSystem,"sn":"breakEffect"},{"a":2,"n":"platformAppearSound","t":4,"rt":$n[1].AudioClip,"sn":"platformAppearSound"},{"a":2,"n":"platformBreakingSound","t":4,"rt":$n[1].AudioClip,"sn":"platformBreakingSound"},{"a":2,"n":"platformExplodeSound","t":4,"rt":$n[1].AudioClip,"sn":"platformExplodeSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"respawnDelay","t":4,"rt":$n[0].Single,"sn":"respawnDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"respawnEffect","t":4,"rt":$n[1].ParticleSystem,"sn":"respawnEffect"},{"a":1,"n":"shaking","t":4,"rt":$n[0].Boolean,"sn":"shaking","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sprite","t":4,"rt":$n[1].Transform,"sn":"sprite"}]}; }, $n);
    /*BrokenPlatform end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Truongtv.Utilities.DontDestroyOnLoad start.*/
    $m("Truongtv.Utilities.DontDestroyOnLoad", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void}]}; }, $n);
    /*Truongtv.Utilities.DontDestroyOnLoad end.*/

    /*Truongtv.Utilities.Extended start.*/
    $m("Truongtv.Utilities.Extended", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsInLayerMask","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0},{"n":"layerMask","pt":$n[1].LayerMask,"ps":1}],"sn":"IsInLayerMask","rt":$n[0].Boolean,"p":[$n[1].GameObject,$n[1].LayerMask],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Truongtv.Utilities.Extended end.*/

    /*Truongtv.Utilities.Singleton$1 start.*/
    $m("Truongtv.Utilities.Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_instance","is":true,"t":4,"rt":T,"sn":"_instance"}]}; }, $n);
    /*Truongtv.Utilities.Singleton$1 end.*/

    /*ThirdParties.Truongtv.SoundManager.BaseAudio start.*/
    $m("ThirdParties.Truongtv.SoundManager.BaseAudio", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.AudioSource)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":3,"n":"PlayLoop","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0}],"sn":"PlayLoop","rt":$n[0].Void,"p":[$n[1].AudioClip]},{"a":3,"n":"PlayOnceShot","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1},{"n":"complete","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"PlayOnceShot","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Single,Function]},{"a":2,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"a":2,"n":"Stop","t":8,"sn":"Stop","rt":$n[0].Void},{"a":1,"n":"WaitToFinish","t":8,"pi":[{"n":"complete","dv":null,"o":true,"pt":Function,"ps":0}],"sn":"WaitToFinish","rt":$n[5].IEnumerator,"p":[Function]},{"a":3,"n":"AudioSource","t":4,"rt":$n[1].AudioSource,"sn":"AudioSource"}]}; }, $n);
    /*ThirdParties.Truongtv.SoundManager.BaseAudio end.*/

    /*ThirdParties.Truongtv.SoundManager.Bgm start.*/
    $m("ThirdParties.Truongtv.SoundManager.Bgm", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"IsPlaying","t":8,"sn":"IsPlaying","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsPlayingClip","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0}],"sn":"IsPlayingClip","rt":$n[0].Boolean,"p":[$n[1].AudioClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnSettingChange","t":8,"pi":[{"n":"isOn","pt":$n[0].Boolean,"ps":0}],"sn":"OnSettingChange","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Play","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0}],"sn":"Play","rt":$n[0].Void,"p":[$n[1].AudioClip]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Stop","t":8,"sn":"Stop$1","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[6].Bgm,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[6].Bgm,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"instance","is":true,"t":4,"rt":$n[6].Bgm,"sn":"instance"}]}; }, $n);
    /*ThirdParties.Truongtv.SoundManager.Bgm end.*/

    /*ThirdParties.Truongtv.SoundManager.Sfx start.*/
    $m("ThirdParties.Truongtv.SoundManager.Sfx", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnSettingChange","t":8,"pi":[{"n":"isOn","pt":$n[0].Boolean,"ps":0}],"sn":"OnSettingChange","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Play","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"isLoop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"complete","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"Play","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single,Function]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void}]}; }, $n);
    /*ThirdParties.Truongtv.SoundManager.Sfx end.*/

    /*ThirdParties.Truongtv.SoundManager.SimpleAudio start.*/
    $m("ThirdParties.Truongtv.SoundManager.SimpleAudio", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnSettingChange","t":8,"pi":[{"n":"isOn","pt":$n[0].Boolean,"ps":0}],"sn":"OnSettingChange","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Play","t":8,"sn":"Play","rt":$n[0].Void},{"a":2,"n":"Play","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"isLoop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Play$1","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean]},{"a":2,"n":"SetLoop","t":8,"pi":[{"n":"auto","pt":$n[0].Boolean,"ps":0}],"sn":"SetLoop","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Stop","t":8,"sn":"Stop$1","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"autoPlay","t":4,"rt":$n[0].Boolean,"sn":"autoPlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*ThirdParties.Truongtv.SoundManager.SimpleAudio end.*/

    /*ThirdParties.Truongtv.SoundManager.SoundManager start.*/
    $m("ThirdParties.Truongtv.SoundManager.SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"GetSfxInstance","t":8,"sn":"GetSfxInstance","rt":$n[6].Sfx},{"a":2,"n":"IsBgm","is":true,"t":8,"sn":"IsBgm","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsSfx","is":true,"t":8,"sn":"IsSfx","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Pause","t":8,"pi":[{"n":"isPause","pt":$n[0].Boolean,"ps":0}],"sn":"Pause","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"PlayBgm","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0}],"sn":"PlayBgm","rt":$n[0].Void,"p":[$n[1].AudioClip]},{"a":2,"n":"PlayButtonSound","t":8,"pi":[{"n":"complete","dv":null,"o":true,"pt":Function,"ps":0}],"sn":"PlayButtonSound","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"PlayPopupCloseSound","t":8,"sn":"PlayPopupCloseSound","rt":$n[0].Void},{"a":2,"n":"PlayPopupOpenSound","t":8,"sn":"PlayPopupOpenSound","rt":$n[0].Void},{"a":2,"n":"PlaySfx","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"isLoop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"onComplete","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"PlaySfx","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single,Function]},{"a":2,"n":"SetBgm","is":true,"t":8,"pi":[{"n":"isOn","pt":$n[0].Boolean,"ps":0}],"sn":"SetBgm","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetSfx","is":true,"t":8,"pi":[{"n":"isOn","pt":$n[0].Boolean,"ps":0}],"sn":"SetSfx","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[6].SoundManager,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[6].SoundManager,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"INSERT_KEY","is":true,"t":4,"rt":$n[0].String,"sn":"INSERT_KEY"},{"a":2,"n":"OnBgmSettingChange","is":true,"t":4,"rt":Function,"sn":"OnBgmSettingChange"},{"a":2,"n":"OnSfxSettingChange","is":true,"t":4,"rt":Function,"sn":"OnSfxSettingChange"},{"a":1,"n":"SOUND_BGM","is":true,"t":4,"rt":$n[0].String,"sn":"SOUND_BGM"},{"a":1,"n":"SOUND_SFX","is":true,"t":4,"rt":$n[0].String,"sn":"SOUND_SFX"},{"a":1,"n":"_instance","is":true,"t":4,"rt":$n[6].SoundManager,"sn":"_instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buttonSound","t":4,"rt":$n[1].AudioClip,"sn":"buttonSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"popupCloseSound","t":4,"rt":$n[1].AudioClip,"sn":"popupCloseSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"popupOpenSound","t":4,"rt":$n[1].AudioClip,"sn":"popupOpenSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sfxList","t":4,"rt":$n[2].List$1(ThirdParties.Truongtv.SoundManager.Sfx),"sn":"sfxList"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sfxPrefab","t":4,"rt":$n[6].Sfx,"sn":"sfxPrefab"}]}; }, $n);
    /*ThirdParties.Truongtv.SoundManager.SoundManager end.*/

    /*SharpJson.Lexer start.*/
    $m("SharpJson.Lexer", function () { return {"nested":[$n[7].Lexer.Token],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":1,"n":"GetLastIndexOfNumber","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetLastIndexOfNumber","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetNumberString","t":8,"sn":"GetNumberString","rt":$n[0].String},{"a":2,"n":"LookAhead","t":8,"sn":"LookAhead","rt":$n[7].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"NextToken","t":8,"sn":"NextToken","rt":$n[7].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":1,"n":"NextToken","is":true,"t":8,"pi":[{"n":"json","pt":$n[0].Array.type(System.Char),"ps":0},{"n":"index","ref":true,"pt":$n[0].Int32,"ps":1}],"sn":"NextToken","rt":$n[7].Lexer.Token,"p":[$n[0].Array.type(System.Char),$n[0].Int32],"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"ParseDoubleNumber","t":8,"sn":"ParseDoubleNumber","rt":$n[0].Double,"box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},{"a":2,"n":"ParseFloatNumber","t":8,"sn":"ParseFloatNumber","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ParseString","t":8,"sn":"ParseString","rt":$n[0].String},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SkipWhiteSpaces","t":8,"sn":"SkipWhiteSpaces","rt":$n[0].Void},{"a":2,"n":"hasError","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_hasError","t":8,"rt":$n[0].Boolean,"fg":"hasError","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"hasError"},{"a":2,"n":"lineNumber","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_lineNumber","t":8,"rt":$n[0].Int32,"fg":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_lineNumber","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"lineNumber"},"fn":"lineNumber"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"json","t":4,"rt":$n[0].Array.type(System.Char),"sn":"json"},{"a":1,"n":"stringBuffer","t":4,"rt":$n[0].Array.type(System.Char),"sn":"stringBuffer"},{"a":1,"n":"success","t":4,"rt":$n[0].Boolean,"sn":"success","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<lineNumber>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    $m("SharpJson.Lexer.Token", function () { return {"td":$n[7].Lexer,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Colon","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Colon","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Comma","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Comma","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyClose","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"CurlyClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyOpen","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"CurlyOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"False","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"False","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"None","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Null","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Null","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Number","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Number","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredClose","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"SquaredClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredOpen","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"SquaredOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"String","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"String","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"True","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"True","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}}]}; }, $n);
    /*SharpJson.Lexer+Token end.*/

    /*SharpJson.JsonDecoder start.*/
    $m("SharpJson.JsonDecoder", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decode","t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"Decode","rt":$n[0].Object,"p":[$n[0].String]},{"a":2,"n":"DecodeText","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"DecodeText","rt":$n[0].Object,"p":[$n[0].String]},{"a":1,"n":"EvalLexer","t":8,"pi":[{"n":"value","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"EvalLexer","rt":System.Object,"p":[System.Object]},{"a":1,"n":"ParseArray","t":8,"sn":"ParseArray","rt":$n[2].IList$1(System.Object)},{"a":1,"n":"ParseObject","t":8,"sn":"ParseObject","rt":$n[2].IDictionary$2(System.String,System.Object)},{"a":1,"n":"ParseValue","t":8,"sn":"ParseValue","rt":$n[0].Object},{"a":1,"n":"TriggerError","t":8,"pi":[{"n":"message","pt":$n[0].String,"ps":0}],"sn":"TriggerError","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"errorMessage","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_errorMessage","t":8,"rt":$n[0].String,"fg":"errorMessage"},"s":{"a":1,"n":"set_errorMessage","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"errorMessage"},"fn":"errorMessage"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"lexer","t":4,"rt":$n[7].Lexer,"sn":"lexer"},{"a":1,"backing":true,"n":"<errorMessage>k__BackingField","t":4,"rt":$n[0].String,"sn":"errorMessage"},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.JsonDecoder end.*/

    /*Spine.Animation start.*/
    $m("Spine.Animation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[8].ExposedList$1(Spine.Timeline),$n[0].Single],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"timelines","pt":$n[8].ExposedList$1(Spine.Timeline),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"loop","pt":$n[0].Boolean,"ps":3},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":4},{"n":"alpha","pt":$n[0].Single,"ps":5},{"n":"blend","pt":$n[8].MixBlend,"ps":6},{"n":"direction","pt":$n[8].MixDirection,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":4,"n":"BinarySearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"BinarySearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"HasTimeline","t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"HasTimeline","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"LinearSearch","is":true,"t":8,"pi":[{"n":"values","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"target","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"LinearSearch","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Duration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Duration"},"fn":"Duration"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Timelines","t":16,"rt":$n[8].ExposedList$1(Spine.Timeline),"g":{"a":2,"n":"get_Timelines","t":8,"rt":$n[8].ExposedList$1(Spine.Timeline),"fg":"Timelines"},"s":{"a":2,"n":"set_Timelines","t":8,"p":[$n[8].ExposedList$1(Spine.Timeline)],"rt":$n[0].Void,"fs":"Timelines"},"fn":"Timelines"},{"a":4,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"timelineIds","t":4,"rt":$n[2].HashSet$1(System.Int32),"sn":"timelineIds"},{"a":4,"n":"timelines","t":4,"rt":$n[8].ExposedList$1(Spine.Timeline),"sn":"timelines"}]}; }, $n);
    /*Spine.Animation end.*/

    /*Spine.Timeline start.*/
    $m("Spine.Timeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Spine$Timeline$Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"ab":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"Spine$Timeline$PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$Timeline$PropertyId"},{"a":1,"backing":true,"n":"<PropertyId>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$Timeline$PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Timeline end.*/

    /*Spine.MixBlend start.*/
    $m("Spine.MixBlend", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Add","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"First","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"First","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Replace","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Replace","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Setup","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Setup","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}}]}; }, $n);
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    $m("Spine.MixDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"In","is":true,"t":4,"rt":$n[8].MixDirection,"sn":"In","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}},{"a":2,"n":"Out","is":true,"t":4,"rt":$n[8].MixDirection,"sn":"Out","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}}]}; }, $n);
    /*Spine.MixDirection end.*/

    /*Spine.TimelineType start.*/
    $m("Spine.TimelineType", function () { return {"att":256,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Attachment","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Attachment","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Color","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Color","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Deform","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Deform","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"DrawOrder","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"DrawOrder","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"IkConstraint","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"IkConstraint","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintMix","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"PathConstraintMix","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintPosition","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"PathConstraintPosition","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"PathConstraintSpacing","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"PathConstraintSpacing","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Rotate","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Rotate","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Scale","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Scale","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Shear","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Shear","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"TransformConstraint","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"TransformConstraint","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"Translate","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"Translate","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}},{"a":2,"n":"TwoColor","is":true,"t":4,"rt":$n[8].TimelineType,"sn":"TwoColor","box":function ($v) { return Bridge.box($v, Spine.TimelineType, System.Enum.toStringFn(Spine.TimelineType));}}]}; }, $n);
    /*Spine.TimelineType end.*/

    /*Spine.IBoneTimeline start.*/
    $m("Spine.IBoneTimeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$IBoneTimeline$BoneIndex"},{"a":1,"backing":true,"n":"<BoneIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IBoneTimeline end.*/

    /*Spine.ISlotTimeline start.*/
    $m("Spine.ISlotTimeline", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$ISlotTimeline$SlotIndex"},{"a":1,"backing":true,"n":"<SlotIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ISlotTimeline end.*/

    /*Spine.CurveTimeline start.*/
    $m("Spine.CurveTimeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"GetCurvePercent","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"percent","pt":$n[0].Single,"ps":1}],"sn":"GetCurvePercent","rt":$n[0].Single,"p":[$n[0].Int32,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCurveType","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurveType","rt":$n[0].Single,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetCurve","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"cx1","pt":$n[0].Single,"ps":1},{"n":"cy1","pt":$n[0].Single,"ps":2},{"n":"cx2","pt":$n[0].Single,"ps":3},{"n":"cy2","pt":$n[0].Single,"ps":4}],"sn":"SetCurve","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLinear","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"SetLinear","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetStepped","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0}],"sn":"SetStepped","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"ab":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":3,"n":"BEZIER","is":true,"t":4,"rt":$n[0].Single,"sn":"BEZIER","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"BEZIER_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"LINEAR","is":true,"t":4,"rt":$n[0].Single,"sn":"LINEAR","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"STEPPED","is":true,"t":4,"rt":$n[0].Single,"sn":"STEPPED","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"curves","t":4,"rt":$n[0].Array.type(System.Single),"sn":"curves"},{"a":1,"backing":true,"n":"<PropertyId>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline end.*/

    /*Spine.RotateTimeline start.*/
    $m("Spine.RotateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"degrees","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BoneIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BoneIndex"},"fn":"BoneIndex"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"PREV_ROTATION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"ROTATION","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.RotateTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    $m("Spine.TranslateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"x","pt":$n[0].Single,"ps":2},{"n":"y","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BoneIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BoneIndex"},"fn":"BoneIndex"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_X","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.TranslateTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    $m("Spine.ScaleTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.ScaleTimeline end.*/

    /*Spine.ShearTimeline start.*/
    $m("Spine.ShearTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.ShearTimeline end.*/

    /*Spine.ColorTimeline start.*/
    $m("Spine.ColorTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_A","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ColorTimeline end.*/

    /*Spine.TwoColorTimeline start.*/
    $m("Spine.TwoColorTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5},{"n":"r2","pt":$n[0].Single,"ps":6},{"n":"g2","pt":$n[0].Single,"ps":7},{"n":"b2","pt":$n[0].Single,"ps":8}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_A","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TwoColorTimeline end.*/

    /*Spine.AttachmentTimeline start.*/
    $m("Spine.AttachmentTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Slot,$n[0].String]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].String]},{"a":2,"n":"AttachmentNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_AttachmentNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"AttachmentNames"},"s":{"a":2,"n":"set_AttachmentNames","t":8,"p":[$n[0].Array.type(System.String)],"rt":$n[0].Void,"fs":"AttachmentNames"},"fn":"AttachmentNames"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":4,"n":"attachmentNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"attachmentNames"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AttachmentTimeline end.*/

    /*Spine.DeformTimeline start.*/
    $m("Spine.DeformTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"Attachment","t":16,"rt":$n[8].VertexAttachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].VertexAttachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[8].VertexAttachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SlotIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SlotIndex"},"fn":"SlotIndex"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Array.type(System.Single)),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Array.type(System.Single)),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Array.type(System.Single))],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":4,"n":"attachment","t":4,"rt":$n[8].VertexAttachment,"sn":"attachment"},{"a":4,"n":"frameVertices","t":4,"rt":$n[0].Array.type(System.Array.type(System.Single)),"sn":"frameVertices"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.DeformTimeline end.*/

    /*Spine.EventTimeline start.*/
    $m("Spine.EventTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[8].Event]},{"a":2,"n":"Events","t":16,"rt":System.Array.type(Spine.Event),"g":{"a":2,"n":"get_Events","t":8,"rt":System.Array.type(Spine.Event),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[System.Array.type(Spine.Event)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"events","t":4,"rt":System.Array.type(Spine.Event),"sn":"events"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.EventTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    $m("Spine.DrawOrderTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"drawOrder","pt":$n[0].Array.type(System.Int32),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Int32)]},{"a":2,"n":"DrawOrders","t":16,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"g":{"a":2,"n":"get_DrawOrders","t":8,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"fg":"DrawOrders"},"s":{"a":2,"n":"set_DrawOrders","t":8,"p":[$n[0].Array.type(System.Array.type(System.Int32))],"rt":$n[0].Void,"fs":"DrawOrders"},"fn":"DrawOrders"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"drawOrders","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"drawOrders"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"}]}; }, $n);
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    $m("Spine.IkConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mix","pt":$n[0].Single,"ps":2},{"n":"softness","pt":$n[0].Single,"ps":3},{"n":"bendDirection","pt":$n[0].Int32,"ps":4},{"n":"compress","pt":$n[0].Boolean,"ps":5},{"n":"stretch","pt":$n[0].Boolean,"ps":6}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"IkConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_IkConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"IkConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_IkConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"IkConstraintIndex"},"fn":"IkConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":1,"n":"BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"ikConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"ikConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    $m("Spine.TransformConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"rotateMix","pt":$n[0].Single,"ps":2},{"n":"translateMix","pt":$n[0].Single,"ps":3},{"n":"scaleMix","pt":$n[0].Single,"ps":4},{"n":"shearMix","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"TransformConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TransformConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"TransformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_TransformConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"TransformConstraintIndex"},"fn":"TransformConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"transformConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"transformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    $m("Spine.PathConstraintPositionTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"position","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_PathConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"PathConstraintIndex"},"fn":"PathConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"PREV_VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    $m("Spine.PathConstraintSpacingTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"}]}; }, $n);
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    $m("Spine.PathConstraintMixTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frameIndex","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"rotateMix","pt":$n[0].Single,"ps":2},{"n":"translateMix","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"s":{"a":2,"n":"set_Frames","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Frames"},"fn":"Frames"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_PathConstraintIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"PathConstraintIndex"},"fn":"PathConstraintIndex"},{"ov":true,"a":2,"n":"PropertyId","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_PropertyId","t":8,"rt":$n[0].Int32,"fg":"PropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PropertyId"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TIME","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TIME","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"PREV_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"PREV_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames"},{"a":4,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.AnimationState start.*/
    $m("Spine.AnimationState", function () { return {"nested":[Function,Function],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationStateData],"pi":[{"n":"data","pt":$n[8].AnimationStateData,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation$1","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1},{"n":"delay","pt":$n[0].Single,"ps":2}],"sn":"AddEmptyAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"AddEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[8].AnimationState,"ps":0}],"sn":"AddEventSubscribersFrom","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":1,"n":"AnimationsChanged","t":8,"sn":"AnimationsChanged","rt":$n[0].Void},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Boolean,"p":[$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyAttachmentTimeline","t":8,"pi":[{"n":"timeline","pt":$n[8].AttachmentTimeline,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"blend","pt":$n[8].MixBlend,"ps":3},{"n":"attachments","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyAttachmentTimeline","rt":$n[0].Void,"p":[$n[8].AttachmentTimeline,$n[8].Skeleton,$n[0].Single,$n[8].MixBlend,$n[0].Boolean]},{"a":2,"n":"ApplyEventTimelinesOnly","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"ApplyEventTimelinesOnly","rt":$n[0].Boolean,"p":[$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyMixingFrom","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2}],"sn":"ApplyMixingFrom","rt":$n[0].Single,"p":[$n[8].TrackEntry,$n[8].Skeleton,$n[8].MixBlend],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyMixingFromEventTimelinesOnly","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ApplyMixingFromEventTimelinesOnly","rt":$n[0].Single,"p":[$n[8].TrackEntry,$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyRotateTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].RotateTimeline,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"alpha","pt":$n[0].Single,"ps":3},{"n":"blend","pt":$n[8].MixBlend,"ps":4},{"n":"timelinesRotation","pt":$n[0].Array.type(System.Single),"ps":5},{"n":"i","pt":$n[0].Int32,"ps":6},{"n":"firstFrame","pt":$n[0].Boolean,"ps":7}],"sn":"ApplyRotateTimeline","rt":$n[0].Void,"p":[$n[8].RotateTimeline,$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"AssignEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[8].AnimationState,"ps":0}],"sn":"AssignEventSubscribersFrom","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":2,"n":"ClearListenerNotifications","t":8,"sn":"ClearListenerNotifications","rt":$n[0].Void},{"a":2,"n":"ClearTrack","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"ClearTrack","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"ClearTracks","t":8,"sn":"ClearTracks","rt":$n[0].Void},{"a":1,"n":"ComputeHold","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ComputeHold","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"DisposeNext","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"DisposeNext","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"ExpandToIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"ExpandToIndex","rt":$n[8].TrackEntry,"p":[$n[0].Int32]},{"a":2,"n":"GetCurrent","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrent","rt":$n[8].TrackEntry,"p":[$n[0].Int32]},{"a":1,"n":"NewTrackEntry","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"last","pt":$n[8].TrackEntry,"ps":3}],"sn":"NewTrackEntry","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean,$n[8].TrackEntry]},{"a":4,"n":"OnComplete","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnComplete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnDispose","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnDispose","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnEnd","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnEnd","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":4,"n":"OnInterrupt","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnInterrupt","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnStart","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnStart","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"QueueEvents","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"animationTime","pt":$n[0].Single,"ps":1}],"sn":"QueueEvents","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[0].Single]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation$1","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2},{"n":"attachments","pt":$n[0].Boolean,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Slot,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetCurrent","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"current","pt":$n[8].TrackEntry,"ps":1},{"n":"interrupt","pt":$n[0].Boolean,"ps":2}],"sn":"SetCurrent","rt":$n[0].Void,"p":[$n[0].Int32,$n[8].TrackEntry,$n[0].Boolean]},{"a":2,"n":"SetEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1}],"sn":"SetEmptyAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].Single]},{"a":2,"n":"SetEmptyAnimations","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0}],"sn":"SetEmptyAnimations","rt":$n[0].Void,"p":[$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"UpdateMixingFrom","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"delta","pt":$n[0].Single,"ps":1}],"sn":"UpdateMixingFrom","rt":$n[0].Boolean,"p":[$n[8].TrackEntry,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Data","t":16,"rt":$n[8].AnimationStateData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].AnimationStateData,"fg":"Data"},"s":{"a":2,"n":"set_Data","t":8,"p":[$n[8].AnimationStateData],"rt":$n[0].Void,"fs":"Data"},"fn":"Data"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"Tracks","t":16,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"g":{"a":2,"n":"get_Tracks","t":8,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"fg":"Tracks"},"fn":"Tracks"},{"a":4,"n":"Current","is":true,"t":4,"rt":$n[0].Int32,"sn":"Current","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyAnimation","is":true,"t":4,"rt":$n[8].Animation,"sn":"EmptyAnimation","ro":true},{"a":4,"n":"First","is":true,"t":4,"rt":$n[0].Int32,"sn":"First","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldFirst","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldFirst","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldMix","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldMix","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldSubsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldSubsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Setup","is":true,"t":4,"rt":$n[0].Int32,"sn":"Setup","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Subsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"Subsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationsChanged","t":4,"rt":$n[0].Boolean,"sn":"animationsChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"data","t":4,"rt":$n[8].AnimationStateData,"sn":"data"},{"a":1,"n":"events","t":4,"rt":$n[8].ExposedList$1(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIDs","t":4,"rt":$n[2].HashSet$1(System.Int32),"sn":"propertyIDs","ro":true},{"a":1,"n":"queue","t":4,"rt":$n[8].EventQueue,"sn":"queue","ro":true},{"a":1,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[8].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":1,"n":"tracks","t":4,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"sn":"tracks","ro":true},{"a":1,"n":"unkeyedState","t":4,"rt":$n[0].Int32,"sn":"unkeyedState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.AnimationState end.*/

    /*Spine.TrackEntry start.*/
    $m("Spine.TrackEntry", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"OnComplete","t":8,"sn":"OnComplete","rt":$n[0].Void},{"a":4,"n":"OnDispose","t":8,"sn":"OnDispose","rt":$n[0].Void},{"a":4,"n":"OnEnd","t":8,"sn":"OnEnd","rt":$n[0].Void},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"e","pt":$n[8].Event,"ps":0}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[8].Event]},{"a":4,"n":"OnInterrupt","t":8,"sn":"OnInterrupt","rt":$n[0].Void},{"a":4,"n":"OnStart","t":8,"sn":"OnStart","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"ResetRotationDirections","t":8,"sn":"ResetRotationDirections","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Alpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Alpha","t":8,"rt":$n[0].Single,"fg":"Alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Alpha","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Alpha"},"fn":"Alpha"},{"a":2,"n":"Animation","t":16,"rt":$n[8].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[8].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"AnimationEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationEnd","t":8,"rt":$n[0].Single,"fg":"AnimationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationEnd"},"fn":"AnimationEnd"},{"a":2,"n":"AnimationLast","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationLast","t":8,"rt":$n[0].Single,"fg":"AnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationLast","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationLast"},"fn":"AnimationLast"},{"a":2,"n":"AnimationStart","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationStart","t":8,"rt":$n[0].Single,"fg":"AnimationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationStart","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationStart"},"fn":"AnimationStart"},{"a":2,"n":"AnimationTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationTime","t":8,"rt":$n[0].Single,"fg":"AnimationTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AnimationTime"},{"a":2,"n":"AttachmentThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AttachmentThreshold","t":8,"rt":$n[0].Single,"fg":"AttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AttachmentThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AttachmentThreshold"},"fn":"AttachmentThreshold"},{"a":2,"n":"Delay","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Delay","t":8,"rt":$n[0].Single,"fg":"Delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Delay","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Delay"},"fn":"Delay"},{"a":2,"n":"DrawOrderThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DrawOrderThreshold","t":8,"rt":$n[0].Single,"fg":"DrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DrawOrderThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DrawOrderThreshold"},"fn":"DrawOrderThreshold"},{"a":2,"n":"EventThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_EventThreshold","t":8,"rt":$n[0].Single,"fg":"EventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_EventThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"EventThreshold"},"fn":"EventThreshold"},{"a":2,"n":"HoldPrevious","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HoldPrevious","t":8,"rt":$n[0].Boolean,"fg":"HoldPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HoldPrevious","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HoldPrevious"},"fn":"HoldPrevious"},{"a":2,"n":"IsComplete","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsComplete","t":8,"rt":$n[0].Boolean,"fg":"IsComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsComplete"},{"a":2,"n":"Loop","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Loop","t":8,"rt":$n[0].Boolean,"fg":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Loop","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Loop"},"fn":"Loop"},{"a":2,"n":"MixBlend","t":16,"rt":$n[8].MixBlend,"g":{"a":2,"n":"get_MixBlend","t":8,"rt":$n[8].MixBlend,"fg":"MixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},"s":{"a":2,"n":"set_MixBlend","t":8,"p":[$n[8].MixBlend],"rt":$n[0].Void,"fs":"MixBlend"},"fn":"MixBlend"},{"a":2,"n":"MixDuration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixDuration","t":8,"rt":$n[0].Single,"fg":"MixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixDuration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixDuration"},"fn":"MixDuration"},{"a":2,"n":"MixTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixTime","t":8,"rt":$n[0].Single,"fg":"MixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixTime"},"fn":"MixTime"},{"a":2,"n":"MixingFrom","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_MixingFrom","t":8,"rt":$n[8].TrackEntry,"fg":"MixingFrom"},"fn":"MixingFrom"},{"a":2,"n":"MixingTo","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_MixingTo","t":8,"rt":$n[8].TrackEntry,"fg":"MixingTo"},"fn":"MixingTo"},{"a":2,"n":"Next","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_Next","t":8,"rt":$n[8].TrackEntry,"fg":"Next"},"fn":"Next"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"TrackEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackEnd","t":8,"rt":$n[0].Single,"fg":"TrackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackEnd"},"fn":"TrackEnd"},{"a":2,"n":"TrackIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TrackIndex","t":8,"rt":$n[0].Int32,"fg":"TrackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TrackIndex"},{"a":2,"n":"TrackTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackTime","t":8,"rt":$n[0].Single,"fg":"TrackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackTime"},"fn":"TrackTime"},{"a":4,"n":"alpha","t":4,"rt":$n[0].Single,"sn":"alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animation","t":4,"rt":$n[8].Animation,"sn":"animation"},{"a":4,"n":"animationEnd","t":4,"rt":$n[0].Single,"sn":"animationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationLast","t":4,"rt":$n[0].Single,"sn":"animationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationStart","t":4,"rt":$n[0].Single,"sn":"animationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentThreshold","t":4,"rt":$n[0].Single,"sn":"attachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"drawOrderThreshold","t":4,"rt":$n[0].Single,"sn":"drawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"eventThreshold","t":4,"rt":$n[0].Single,"sn":"eventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"holdPrevious","t":4,"rt":$n[0].Boolean,"sn":"holdPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"interruptAlpha","t":4,"rt":$n[0].Single,"sn":"interruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixBlend","t":4,"rt":$n[8].MixBlend,"sn":"mixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":4,"n":"mixDuration","t":4,"rt":$n[0].Single,"sn":"mixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixTime","t":4,"rt":$n[0].Single,"sn":"mixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixingFrom","t":4,"rt":$n[8].TrackEntry,"sn":"mixingFrom"},{"a":4,"n":"mixingTo","t":4,"rt":$n[8].TrackEntry,"sn":"mixingTo"},{"a":4,"n":"next","t":4,"rt":$n[8].TrackEntry,"sn":"next"},{"a":4,"n":"nextAnimationLast","t":4,"rt":$n[0].Single,"sn":"nextAnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"nextTrackLast","t":4,"rt":$n[0].Single,"sn":"nextTrackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timelineHoldMix","t":4,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"sn":"timelineHoldMix","ro":true},{"a":4,"n":"timelineMode","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"timelineMode","ro":true},{"a":4,"n":"timelinesRotation","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"timelinesRotation","ro":true},{"a":4,"n":"totalAlpha","t":4,"rt":$n[0].Single,"sn":"totalAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackEnd","t":4,"rt":$n[0].Single,"sn":"trackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"trackLast","t":4,"rt":$n[0].Single,"sn":"trackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackTime","t":4,"rt":$n[0].Single,"sn":"trackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.TrackEntry end.*/

    /*Spine.EventQueue start.*/
    $m("Spine.EventQueue", function () { return {"nested":[$n[8].EventQueue.EventQueueEntry,$n[8].EventQueue.EventType],"att":1048576,"a":4,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[8].AnimationState,Function,$n[8].Pool$1(Spine.TrackEntry)],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"HandleAnimationsChanged","pt":Function,"ps":1},{"n":"trackEntryPool","pt":$n[8].Pool$1(Spine.TrackEntry),"ps":2}],"sn":"ctor"},{"a":4,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":4,"n":"Complete","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Complete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Dispose","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Dispose","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Drain","t":8,"sn":"Drain","rt":$n[0].Void},{"a":4,"n":"End","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"End","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Event","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"Event","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":4,"n":"Interrupt","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Interrupt","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Start","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Start","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"drainDisabled","t":4,"rt":$n[0].Boolean,"sn":"drainDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventQueueEntries","t":4,"rt":$n[2].List$1(Spine.EventQueue.EventQueueEntry),"sn":"eventQueueEntries","ro":true},{"a":1,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state","ro":true},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[8].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":4,"n":"AnimationsChanged","t":2,"ad":{"a":4,"n":"add_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAnimationsChanged","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAnimationsChanged","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    $m("Spine.EventQueue.EventQueueEntry", function () { return {"td":$n[8].EventQueue,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].EventQueue.EventType,$n[8].TrackEntry,$n[8].Event],"pi":[{"n":"eventType","pt":$n[8].EventQueue.EventType,"ps":0},{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":1},{"n":"e","dv":null,"o":true,"pt":$n[8].Event,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"e","t":4,"rt":$n[8].Event,"sn":"e"},{"a":2,"n":"entry","t":4,"rt":$n[8].TrackEntry,"sn":"entry"},{"a":2,"n":"type","t":4,"rt":$n[8].EventQueue.EventType,"sn":"type","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    $m("Spine.EventQueue.EventType", function () { return {"td":$n[8].EventQueue,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventType end.*/

    /*Spine.Pool$1 start.*/
    $m("Spine.Pool$1", function (T) { return {"nested":[$n[8].Pool$1.IPoolable],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"initialCapacity","dv":16,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"max","dv":2147483647,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Free","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Free","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Obtain","t":8,"sn":"Obtain","rt":T},{"a":3,"n":"Reset","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Reset","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Peak","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Peak","t":8,"rt":$n[0].Int32,"fg":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_Peak","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Peak"},"fn":"Peak"},{"a":1,"n":"freeObjects","t":4,"rt":$n[2].Stack$1(T),"sn":"freeObjects","ro":true},{"a":2,"n":"max","t":4,"rt":$n[0].Int32,"sn":"max","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Peak>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    $m("Spine.Pool$1.IPoolable", function (T) { return {"td":$n[8].Pool$1(T),"att":162,"a":2,"m":[{"ab":true,"a":2,"n":"Reset","t":8,"sn":"Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset","rt":$n[0].Void}]}; }, $n);
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.AnimationStateData start.*/
    $m("Spine.AnimationStateData", function () { return {"nested":[$n[8].AnimationStateData.AnimationPair,$n[8].AnimationStateData.AnimationPairComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].SkeletonData],"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetMix","t":8,"pi":[{"n":"from","pt":$n[8].Animation,"ps":0},{"n":"to","pt":$n[8].Animation,"ps":1}],"sn":"GetMix","rt":$n[0].Single,"p":[$n[8].Animation,$n[8].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"from","pt":$n[8].Animation,"ps":0},{"n":"to","pt":$n[8].Animation,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix","rt":$n[0].Void,"p":[$n[8].Animation,$n[8].Animation,$n[0].Single]},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"fromName","pt":$n[0].String,"ps":0},{"n":"toName","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].Single]},{"a":2,"n":"DefaultMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DefaultMix","t":8,"rt":$n[0].Single,"fg":"DefaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DefaultMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DefaultMix"},"fn":"DefaultMix"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[8].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":1,"n":"animationToMixTime","t":4,"rt":$n[2].Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single),"sn":"animationToMixTime","ro":true},{"a":4,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeletonData","t":4,"rt":$n[8].SkeletonData,"sn":"skeletonData"}]}; }, $n);
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    $m("Spine.AnimationStateData.AnimationPair", function () { return {"td":$n[8].AnimationStateData,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].Animation,$n[8].Animation],"pi":[{"n":"a1","pt":$n[8].Animation,"ps":0},{"n":"a2","pt":$n[8].Animation,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"a1","t":4,"rt":$n[8].Animation,"sn":"a1","ro":true},{"a":2,"n":"a2","t":4,"rt":$n[8].Animation,"sn":"a2","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    $m("Spine.AnimationStateData.AnimationPairComparer", function () { return {"td":$n[8].AnimationStateData,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":4,"rt":$n[8].AnimationStateData.AnimationPairComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    $m("Spine.Atlas", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].List$1(Spine.AtlasPage),$n[2].List$1(Spine.AtlasRegion)],"pi":[{"n":"pages","pt":$n[2].List$1(Spine.AtlasPage),"ps":0},{"n":"regions","pt":$n[2].List$1(Spine.AtlasRegion),"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].TextReader,$n[0].String,$n[8].TextureLoader],"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0},{"n":"dir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[8].TextureLoader,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[8].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"FlipV","t":8,"sn":"FlipV","rt":$n[0].Void},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(Spine.AtlasRegion)},{"a":1,"n":"Load","t":8,"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0},{"n":"imagesDir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[8].TextureLoader,"ps":2}],"sn":"Load","rt":$n[0].Void,"p":[$n[9].TextReader,$n[0].String,$n[8].TextureLoader]},{"a":1,"n":"ReadTuple","is":true,"t":8,"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0},{"n":"tuple","pt":$n[0].Array.type(System.String),"ps":1}],"sn":"ReadTuple","rt":$n[0].Int32,"p":[$n[9].TextReader,$n[0].Array.type(System.String)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ReadValue","is":true,"t":8,"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0}],"sn":"ReadValue","rt":$n[0].String,"p":[$n[9].TextReader]},{"a":2,"n":"Pages","t":16,"rt":$n[2].List$1(Spine.AtlasPage),"g":{"a":2,"n":"get_Pages","t":8,"rt":$n[2].List$1(Spine.AtlasPage),"fg":"Pages"},"fn":"Pages"},{"a":2,"n":"Regions","t":16,"rt":$n[2].List$1(Spine.AtlasRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":$n[2].List$1(Spine.AtlasRegion),"fg":"Regions"},"fn":"Regions"},{"a":1,"n":"pages","t":4,"rt":$n[2].List$1(Spine.AtlasPage),"sn":"pages","ro":true},{"a":1,"n":"regions","t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"regions"},{"a":1,"n":"textureLoader","t":4,"rt":$n[8].TextureLoader,"sn":"textureLoader"}]}; }, $n);
    /*Spine.Atlas end.*/

    /*Spine.Format start.*/
    $m("Spine.Format", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[8].Format,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"Intensity","is":true,"t":4,"rt":$n[8].Format,"sn":"Intensity","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"LuminanceAlpha","is":true,"t":4,"rt":$n[8].Format,"sn":"LuminanceAlpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB565","is":true,"t":4,"rt":$n[8].Format,"sn":"RGB565","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB888","is":true,"t":4,"rt":$n[8].Format,"sn":"RGB888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA4444","is":true,"t":4,"rt":$n[8].Format,"sn":"RGBA4444","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA8888","is":true,"t":4,"rt":$n[8].Format,"sn":"RGBA8888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}}]}; }, $n);
    /*Spine.Format end.*/

    /*Spine.TextureFilter start.*/
    $m("Spine.TextureFilter", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Linear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"Linear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMap","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMap","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearLinear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapLinearLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearNearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapLinearNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestLinear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapNearestLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestNearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapNearestNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"Nearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"Nearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}}]}; }, $n);
    /*Spine.TextureFilter end.*/

    /*Spine.TextureWrap start.*/
    $m("Spine.TextureWrap", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampToEdge","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"ClampToEdge","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"MirroredRepeat","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"MirroredRepeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"Repeat","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"Repeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}}]}; }, $n);
    /*Spine.TextureWrap end.*/

    /*Spine.AtlasPage start.*/
    $m("Spine.AtlasPage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[8].AtlasPage},{"a":2,"n":"format","t":4,"rt":$n[8].Format,"sn":"format","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"magFilter","t":4,"rt":$n[8].TextureFilter,"sn":"magFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"minFilter","t":4,"rt":$n[8].TextureFilter,"sn":"minFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"rendererObject","t":4,"rt":$n[0].Object,"sn":"rendererObject"},{"a":2,"n":"uWrap","t":4,"rt":$n[8].TextureWrap,"sn":"uWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"vWrap","t":4,"rt":$n[8].TextureWrap,"sn":"vWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasPage end.*/

    /*Spine.AtlasRegion start.*/
    $m("Spine.AtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[8].AtlasRegion},{"a":2,"n":"degrees","t":4,"rt":$n[0].Int32,"sn":"degrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"originalHeight","t":4,"rt":$n[0].Int32,"sn":"originalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"originalWidth","t":4,"rt":$n[0].Int32,"sn":"originalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"pads","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"pads"},{"a":2,"n":"page","t":4,"rt":$n[8].AtlasPage,"sn":"page"},{"a":2,"n":"rotate","t":4,"rt":$n[0].Boolean,"sn":"rotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"splits","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"splits"},{"a":2,"n":"u","t":4,"rt":$n[0].Single,"sn":"u","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"u2","t":4,"rt":$n[0].Single,"sn":"u2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v","t":4,"rt":$n[0].Single,"sn":"v","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v2","t":4,"rt":$n[0].Single,"sn":"v2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"x","t":4,"rt":$n[0].Int32,"sn":"x","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"y","t":4,"rt":$n[0].Int32,"sn":"y","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasRegion end.*/

    /*Spine.TextureLoader start.*/
    $m("Spine.TextureLoader", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[8].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Spine$TextureLoader$Load","rt":$n[0].Void,"p":[$n[8].AtlasPage,$n[0].String]},{"ab":true,"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Spine$TextureLoader$Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.TextureLoader end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    $m("Spine.AtlasAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[8].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]},{"a":1,"n":"atlasArray","t":4,"rt":System.Array.type(Spine.Atlas),"sn":"atlasArray"}]}; }, $n);
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.Attachment start.*/
    $m("Spine.Attachment", function () { return {"att":1048705,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ab":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":1,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":1,"backing":true,"n":"<Name>k__BackingField","t":4,"rt":$n[0].String,"sn":"Name"}]}; }, $n);
    /*Spine.Attachment end.*/

    /*Spine.IHasRendererObject start.*/
    $m("Spine.IHasRendererObject", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"ab":true,"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"Spine$IHasRendererObject$RendererObject"},"s":{"ab":true,"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"Spine$IHasRendererObject$RendererObject"},"fn":"Spine$IHasRendererObject$RendererObject"},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"Spine$IHasRendererObject$RendererObject"}]}; }, $n);
    /*Spine.IHasRendererObject end.*/

    /*Spine.AttachmentLoader start.*/
    $m("Spine.AttachmentLoader", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"Spine$AttachmentLoader$NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]},{"ab":true,"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"Spine$AttachmentLoader$NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]}]}; }, $n);
    /*Spine.AttachmentLoader end.*/

    /*Spine.AttachmentType start.*/
    $m("Spine.AttachmentType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Boundingbox","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Boundingbox","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Clipping","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Clipping","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Linkedmesh","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Linkedmesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Mesh","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Mesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Path","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Path","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Point","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Point","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Region","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Region","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}}]}; }, $n);
    /*Spine.AttachmentType end.*/

    /*Spine.BoundingBoxAttachment start.*/
    $m("Spine.BoundingBoxAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment}]}; }, $n);
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    $m("Spine.ClippingAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"EndSlot","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_EndSlot","t":8,"rt":$n[8].SlotData,"fg":"EndSlot"},"s":{"a":2,"n":"set_EndSlot","t":8,"p":[$n[8].SlotData],"rt":$n[0].Void,"fs":"EndSlot"},"fn":"EndSlot"},{"a":4,"n":"endSlot","t":4,"rt":$n[8].SlotData,"sn":"endSlot"}]}; }, $n);
    /*Spine.ClippingAttachment end.*/

    /*Spine.MeshAttachment start.*/
    $m("Spine.MeshAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"NewLinkedMesh","t":8,"sn":"NewLinkedMesh","rt":$n[8].MeshAttachment},{"a":2,"n":"UpdateUVs","t":8,"sn":"UpdateUVs","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Edges","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Edges","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Edges"},"s":{"a":2,"n":"set_Edges","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Edges"},"fn":"Edges"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"HullLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_HullLength","t":8,"rt":$n[0].Int32,"fg":"HullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_HullLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"HullLength"},"fn":"HullLength"},{"a":2,"n":"ParentMesh","t":16,"rt":$n[8].MeshAttachment,"g":{"a":2,"n":"get_ParentMesh","t":8,"rt":$n[8].MeshAttachment,"fg":"ParentMesh"},"s":{"a":2,"n":"set_ParentMesh","t":8,"p":[$n[8].MeshAttachment],"rt":$n[0].Void,"fs":"ParentMesh"},"fn":"ParentMesh"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RegionDegrees","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_RegionDegrees","t":8,"rt":$n[0].Int32,"fg":"RegionDegrees","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_RegionDegrees","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"RegionDegrees"},"fn":"RegionDegrees"},{"a":2,"n":"RegionHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionHeight","t":8,"rt":$n[0].Single,"fg":"RegionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionHeight"},"fn":"RegionHeight"},{"a":2,"n":"RegionOffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetX","t":8,"rt":$n[0].Single,"fg":"RegionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetX"},"fn":"RegionOffsetX"},{"a":2,"n":"RegionOffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetY","t":8,"rt":$n[0].Single,"fg":"RegionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetY"},"fn":"RegionOffsetY"},{"a":2,"n":"RegionOriginalHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalHeight","t":8,"rt":$n[0].Single,"fg":"RegionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalHeight"},"fn":"RegionOriginalHeight"},{"a":2,"n":"RegionOriginalWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalWidth","t":8,"rt":$n[0].Single,"fg":"RegionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalWidth"},"fn":"RegionOriginalWidth"},{"a":2,"n":"RegionRotate","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RegionRotate","t":8,"rt":$n[0].Boolean,"fg":"RegionRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RegionRotate","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RegionRotate"},"fn":"RegionRotate"},{"a":2,"n":"RegionU","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionU","t":8,"rt":$n[0].Single,"fg":"RegionU","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionU","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionU"},"fn":"RegionU"},{"a":2,"n":"RegionU2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionU2","t":8,"rt":$n[0].Single,"fg":"RegionU2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionU2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionU2"},"fn":"RegionU2"},{"a":2,"n":"RegionUVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_RegionUVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"RegionUVs"},"s":{"a":2,"n":"set_RegionUVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"RegionUVs"},"fn":"RegionUVs"},{"a":2,"n":"RegionV","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionV","t":8,"rt":$n[0].Single,"fg":"RegionV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionV","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionV"},"fn":"RegionV"},{"a":2,"n":"RegionV2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionV2","t":8,"rt":$n[0].Single,"fg":"RegionV2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionV2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionV2"},"fn":"RegionV2"},{"a":2,"n":"RegionWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionWidth","t":8,"rt":$n[0].Single,"fg":"RegionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionWidth"},"fn":"RegionWidth"},{"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"RendererObject"},"s":{"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"RendererObject"},"fn":"RendererObject"},{"a":2,"n":"Triangles","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Triangles","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Triangles"},"s":{"a":2,"n":"set_Triangles","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Triangles"},"fn":"Triangles"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"s":{"a":2,"n":"set_UVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hulllength","t":4,"rt":$n[0].Int32,"sn":"hulllength","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"parentMesh","t":4,"rt":$n[8].MeshAttachment,"sn":"parentMesh"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionHeight","t":4,"rt":$n[0].Single,"sn":"regionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetX","t":4,"rt":$n[0].Single,"sn":"regionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetY","t":4,"rt":$n[0].Single,"sn":"regionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalHeight","t":4,"rt":$n[0].Single,"sn":"regionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalWidth","t":4,"rt":$n[0].Single,"sn":"regionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionUVs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"regionUVs"},{"a":4,"n":"regionWidth","t":4,"rt":$n[0].Single,"sn":"regionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"triangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"triangles"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":1,"backing":true,"n":"<Edges>k__BackingField","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"Edges"},{"a":1,"backing":true,"n":"<Height>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"},{"a":1,"backing":true,"n":"<RegionDegrees>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"RegionDegrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<RegionRotate>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"RegionRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<RegionU>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionU","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionU2>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionU2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionV>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RegionV2>k__BackingField","t":4,"rt":$n[0].Single,"sn":"RegionV2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"RendererObject"},{"a":1,"backing":true,"n":"<Width>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    $m("Spine.PathAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"Closed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Closed","t":8,"rt":$n[0].Boolean,"fg":"Closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Closed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Closed"},"fn":"Closed"},{"a":2,"n":"ConstantSpeed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ConstantSpeed","t":8,"rt":$n[0].Boolean,"fg":"ConstantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ConstantSpeed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ConstantSpeed"},"fn":"ConstantSpeed"},{"a":2,"n":"Lengths","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Lengths","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Lengths"},"s":{"a":2,"n":"set_Lengths","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Lengths"},"fn":"Lengths"},{"a":4,"n":"closed","t":4,"rt":$n[0].Boolean,"sn":"closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"constantSpeed","t":4,"rt":$n[0].Boolean,"sn":"constantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"lengths","t":4,"rt":$n[0].Array.type(System.Single),"sn":"lengths"}]}; }, $n);
    /*Spine.PathAttachment end.*/

    /*Spine.PointAttachment start.*/
    $m("Spine.PointAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldPosition","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"ox","out":true,"pt":$n[0].Single,"ps":1},{"n":"oy","out":true,"pt":$n[0].Single,"ps":2}],"sn":"ComputeWorldPosition","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single]},{"a":2,"n":"ComputeWorldRotation","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"ComputeWorldRotation","rt":$n[0].Single,"p":[$n[8].Bone],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PointAttachment end.*/

    /*Spine.RegionAttachment start.*/
    $m("Spine.RegionAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"offset","pt":$n[0].Int32,"ps":2},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"SetUVs","t":8,"pi":[{"n":"u","pt":$n[0].Single,"ps":0},{"n":"v","pt":$n[0].Single,"ps":1},{"n":"u2","pt":$n[0].Single,"ps":2},{"n":"v2","pt":$n[0].Single,"ps":3},{"n":"rotate","pt":$n[0].Boolean,"ps":4}],"sn":"SetUVs","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"UpdateOffset","t":8,"sn":"UpdateOffset","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"Offset","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Offset","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Offset"},"fn":"Offset"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RegionHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionHeight","t":8,"rt":$n[0].Single,"fg":"RegionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionHeight"},"fn":"RegionHeight"},{"a":2,"n":"RegionOffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetX","t":8,"rt":$n[0].Single,"fg":"RegionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetX"},"fn":"RegionOffsetX"},{"a":2,"n":"RegionOffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOffsetY","t":8,"rt":$n[0].Single,"fg":"RegionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOffsetY"},"fn":"RegionOffsetY"},{"a":2,"n":"RegionOriginalHeight","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalHeight","t":8,"rt":$n[0].Single,"fg":"RegionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalHeight","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalHeight"},"fn":"RegionOriginalHeight"},{"a":2,"n":"RegionOriginalWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionOriginalWidth","t":8,"rt":$n[0].Single,"fg":"RegionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionOriginalWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionOriginalWidth"},"fn":"RegionOriginalWidth"},{"a":2,"n":"RegionWidth","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RegionWidth","t":8,"rt":$n[0].Single,"fg":"RegionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RegionWidth","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RegionWidth"},"fn":"RegionWidth"},{"a":2,"n":"RendererObject","t":16,"rt":$n[0].Object,"g":{"a":2,"n":"get_RendererObject","t":8,"rt":$n[0].Object,"fg":"RendererObject"},"s":{"a":2,"n":"set_RendererObject","t":8,"p":[$n[0].Object],"rt":$n[0].Void,"fs":"RendererObject"},"fn":"RendererObject"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":2,"n":"BLX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BLY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULX","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULY","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URX","is":true,"t":4,"rt":$n[0].Int32,"sn":"URX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URY","is":true,"t":4,"rt":$n[0].Int32,"sn":"URY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offset","t":4,"rt":$n[0].Array.type(System.Single),"sn":"offset"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionHeight","t":4,"rt":$n[0].Single,"sn":"regionHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetX","t":4,"rt":$n[0].Single,"sn":"regionOffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOffsetY","t":4,"rt":$n[0].Single,"sn":"regionOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalHeight","t":4,"rt":$n[0].Single,"sn":"regionOriginalHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionOriginalWidth","t":4,"rt":$n[0].Single,"sn":"regionOriginalWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"regionWidth","t":4,"rt":$n[0].Single,"sn":"regionWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"},{"a":1,"backing":true,"n":"<RendererObject>k__BackingField","t":4,"rt":$n[0].Object,"sn":"RendererObject"}]}; }, $n);
    /*Spine.RegionAttachment end.*/

    /*Spine.VertexAttachment start.*/
    $m("Spine.VertexAttachment", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1}],"sn":"ComputeWorldVertices$1","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Array.type(System.Single)]},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"CopyTo","t":8,"pi":[{"n":"attachment","pt":$n[8].VertexAttachment,"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[$n[8].VertexAttachment]},{"a":2,"n":"Bones","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Bones"},"s":{"a":2,"n":"set_Bones","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Bones"},"fn":"Bones"},{"a":2,"n":"DeformAttachment","t":16,"rt":$n[8].VertexAttachment,"g":{"a":2,"n":"get_DeformAttachment","t":8,"rt":$n[8].VertexAttachment,"fg":"DeformAttachment"},"s":{"a":2,"n":"set_DeformAttachment","t":8,"p":[$n[8].VertexAttachment],"rt":$n[0].Void,"fs":"DeformAttachment"},"fn":"DeformAttachment"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":2,"n":"WorldVerticesLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WorldVerticesLength","t":8,"rt":$n[0].Int32,"fg":"WorldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_WorldVerticesLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"WorldVerticesLength"},"fn":"WorldVerticesLength"},{"a":4,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":4,"n":"deformAttachment","t":4,"rt":$n[8].VertexAttachment,"sn":"deformAttachment"},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"},{"a":4,"n":"worldVerticesLength","t":4,"rt":$n[0].Int32,"sn":"worldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.VertexAttachment end.*/

    /*Spine.BlendMode start.*/
    $m("Spine.BlendMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Additive","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Additive","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Multiply","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Multiply","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Screen","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Screen","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}}]}; }, $n);
    /*Spine.BlendMode end.*/

    /*Spine.Bone start.*/
    $m("Spine.Bone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].BoneData,$n[8].Skeleton,$n[8].Bone],"pi":[{"n":"data","pt":$n[8].BoneData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"parent","pt":$n[8].Bone,"ps":2}],"sn":"ctor"},{"a":2,"n":"LocalToWorld","t":8,"pi":[{"n":"localX","pt":$n[0].Single,"ps":0},{"n":"localY","pt":$n[0].Single,"ps":1},{"n":"worldX","out":true,"pt":$n[0].Single,"ps":2},{"n":"worldY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"LocalToWorld","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"LocalToWorldRotation","t":8,"pi":[{"n":"localRotation","pt":$n[0].Single,"ps":0}],"sn":"LocalToWorldRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RotateWorld","t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"RotateWorld","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":4,"n":"UpdateAppliedTransform","t":8,"sn":"UpdateAppliedTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"rotation","pt":$n[0].Single,"ps":2},{"n":"scaleX","pt":$n[0].Single,"ps":3},{"n":"scaleY","pt":$n[0].Single,"ps":4},{"n":"shearX","pt":$n[0].Single,"ps":5},{"n":"shearY","pt":$n[0].Single,"ps":6}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocal","t":8,"pi":[{"n":"worldX","pt":$n[0].Single,"ps":0},{"n":"worldY","pt":$n[0].Single,"ps":1},{"n":"localX","out":true,"pt":$n[0].Single,"ps":2},{"n":"localY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"WorldToLocal","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocalRotation","t":8,"pi":[{"n":"worldRotation","pt":$n[0].Single,"ps":0}],"sn":"WorldToLocalRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"A"},{"a":2,"n":"AScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleX","t":8,"rt":$n[0].Single,"fg":"AScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleX"},"fn":"AScaleX"},{"a":2,"n":"AScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleY","t":8,"rt":$n[0].Single,"fg":"AScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleY"},"fn":"AScaleY"},{"a":2,"n":"AShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearX","t":8,"rt":$n[0].Single,"fg":"AShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearX"},"fn":"AShearX"},{"a":2,"n":"AShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearY","t":8,"rt":$n[0].Single,"fg":"AShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearY"},"fn":"AShearY"},{"a":2,"n":"AX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AX","t":8,"rt":$n[0].Single,"fg":"AX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AX"},"fn":"AX"},{"a":2,"n":"AY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AY","t":8,"rt":$n[0].Single,"fg":"AY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AY"},"fn":"AY"},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"AppliedRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AppliedRotation","t":8,"rt":$n[0].Single,"fg":"AppliedRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AppliedRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AppliedRotation"},"fn":"AppliedRotation"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"B"},{"a":2,"n":"C","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_C","t":8,"rt":$n[0].Single,"fg":"C","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"C"},{"a":2,"n":"Children","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Children","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Children"},"fn":"Children"},{"a":2,"n":"D","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_D","t":8,"rt":$n[0].Single,"fg":"D","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"D"},{"a":2,"n":"Data","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].BoneData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Parent","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[8].Bone,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"WorldRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationX","t":8,"rt":$n[0].Single,"fg":"WorldRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationX"},{"a":2,"n":"WorldRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationY","t":8,"rt":$n[0].Single,"fg":"WorldRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationY"},{"a":2,"n":"WorldScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleX","t":8,"rt":$n[0].Single,"fg":"WorldScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleX"},{"a":2,"n":"WorldScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleY","t":8,"rt":$n[0].Single,"fg":"WorldScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleY"},{"a":2,"n":"WorldToLocalRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationX","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationX"},{"a":2,"n":"WorldToLocalRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationY","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationY"},{"a":2,"n":"WorldX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldX","t":8,"rt":$n[0].Single,"fg":"WorldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldX"},{"a":2,"n":"WorldY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldY","t":8,"rt":$n[0].Single,"fg":"WorldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldY"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"appliedValid","t":4,"rt":$n[0].Boolean,"sn":"appliedValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"arotation","t":4,"rt":$n[0].Single,"sn":"arotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleX","t":4,"rt":$n[0].Single,"sn":"ascaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleY","t":4,"rt":$n[0].Single,"sn":"ascaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearX","t":4,"rt":$n[0].Single,"sn":"ashearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearY","t":4,"rt":$n[0].Single,"sn":"ashearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ax","t":4,"rt":$n[0].Single,"sn":"ax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ay","t":4,"rt":$n[0].Single,"sn":"ay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"children","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"children"},{"a":4,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[8].BoneData,"sn":"data"},{"a":4,"n":"parent","t":4,"rt":$n[8].Bone,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":4,"n":"sorted","t":4,"rt":$n[0].Boolean,"sn":"sorted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"worldX","t":4,"rt":$n[0].Single,"sn":"worldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"worldY","t":4,"rt":$n[0].Single,"sn":"worldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yDown","is":true,"t":4,"rt":$n[0].Boolean,"sn":"yDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Bone end.*/

    /*Spine.BoneData start.*/
    $m("Spine.BoneData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"parent","pt":$n[8].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Length","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Length","t":8,"rt":$n[0].Single,"fg":"Length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Length","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Length"},"fn":"Length"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Parent","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[8].BoneData,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":2,"n":"TransformMode","t":16,"rt":$n[8].TransformMode,"g":{"a":2,"n":"get_TransformMode","t":8,"rt":$n[8].TransformMode,"fg":"TransformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},"s":{"a":2,"n":"set_TransformMode","t":8,"p":[$n[8].TransformMode],"rt":$n[0].Void,"fs":"TransformMode"},"fn":"TransformMode"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"length","t":4,"rt":$n[0].Single,"sn":"length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"parent","t":4,"rt":$n[8].BoneData,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"transformMode","t":4,"rt":$n[8].TransformMode,"sn":"transformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneData end.*/

    /*Spine.TransformMode start.*/
    $m("Spine.TransformMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NoRotationOrReflection","is":true,"t":4,"rt":$n[8].TransformMode,"sn":"NoRotationOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScale","is":true,"t":4,"rt":$n[8].TransformMode,"sn":"NoScale","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScaleOrReflection","is":true,"t":4,"rt":$n[8].TransformMode,"sn":"NoScaleOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[8].TransformMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"OnlyTranslation","is":true,"t":4,"rt":$n[8].TransformMode,"sn":"OnlyTranslation","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}}]}; }, $n);
    /*Spine.TransformMode end.*/

    /*Spine.ConstraintData start.*/
    $m("Spine.ConstraintData", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Order","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Order","t":8,"rt":$n[0].Int32,"fg":"Order","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Order","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Order"},"fn":"Order"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"order","t":4,"rt":$n[0].Int32,"sn":"order","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    $m("Spine.Event", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[8].EventData],"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"data","pt":$n[8].EventData,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Data","t":16,"rt":$n[8].EventData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].EventData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Time"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"balance","t":4,"rt":$n[0].Single,"sn":"balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[8].EventData,"sn":"data","ro":true},{"a":4,"n":"floatValue","t":4,"rt":$n[0].Single,"sn":"floatValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"intValue","t":4,"rt":$n[0].Int32,"sn":"intValue","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"stringValue","t":4,"rt":$n[0].String,"sn":"stringValue"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    $m("Spine.EventData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":1,"backing":true,"n":"<AudioPath>k__BackingField","t":4,"rt":$n[0].String,"sn":"AudioPath"},{"a":1,"backing":true,"n":"<Balance>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Float>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Int>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<String>k__BackingField","t":4,"rt":$n[0].String,"sn":"String"},{"a":1,"backing":true,"n":"<Volume>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.EventData end.*/

    /*Spine.ExposedList$1 start.*/
    $m("Spine.ExposedList$1", function (T) { return {"nested":[$n[8].ExposedList$1.Enumerator],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[2].IEnumerable$1(T)],"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor3"},{"a":4,"n":".ctor","t":1,"p":[System.Array.type(T),$n[0].Int32],"pi":[{"n":"data","pt":System.Array.type(T),"ps":0},{"n":"size","pt":$n[0].Int32,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Add","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[T]},{"a":1,"n":"AddCollection","t":8,"pi":[{"n":"collection","pt":$n[2].ICollection$1(T),"ps":0}],"sn":"AddCollection","rt":$n[0].Void,"p":[$n[2].ICollection$1(T)]},{"a":1,"n":"AddEnumerable","t":8,"pi":[{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddEnumerable","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"list","pt":$n[8].ExposedList$1(T),"ps":0}],"sn":"AddRange","rt":$n[0].Void,"p":[$n[8].ExposedList$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddRange$1","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":1}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"item","pt":T,"ps":2},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":3}],"sn":"BinarySearch$2","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"CheckCollection","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"CheckCollection","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":1,"n":"CheckIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"CheckIndex","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"CheckMatch","is":true,"t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"CheckMatch","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"CheckRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"CheckRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Clear","t":8,"pi":[{"n":"clearArray","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Contains","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Contains","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ConvertAll","t":8,"pi":[{"n":"converter","pt":Function,"ps":0}],"tpc":1,"tprm":["TOutput"],"sn":"ConvertAll","rt":$n[8].ExposedList$1(System.Object),"p":[Function]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[System.Array.type(T)]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"CopyTo$1","rt":$n[0].Void,"p":[System.Array.type(T),$n[0].Int32]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"array","pt":System.Array.type(T),"ps":1},{"n":"arrayIndex","pt":$n[0].Int32,"ps":2},{"n":"count","pt":$n[0].Int32,"ps":3}],"sn":"CopyTo$2","rt":$n[0].Void,"p":[$n[0].Int32,System.Array.type(T),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"EnsureCapacity","t":8,"pi":[{"n":"min","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Exists","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Exists","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Find","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Find","rt":T,"p":[Function]},{"a":2,"n":"FindAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAll","rt":$n[8].ExposedList$1(T),"p":[Function]},{"a":1,"n":"FindAllList","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAllList","rt":$n[8].ExposedList$1(T),"p":[Function]},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLast","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLast","rt":T,"p":[Function]},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLastIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindLastIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ForEach","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ForEach","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[8].ExposedList$1.Enumerator(T)},{"a":1,"n":"GetIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"GetRange","rt":$n[8].ExposedList$1(T),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"GrowIfNeeded","t":8,"pi":[{"n":"addedCount","pt":$n[0].Int32,"ps":0}],"sn":"GrowIfNeeded","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"IndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"IndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"item","pt":T,"ps":1}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,T]},{"a":1,"n":"InsertCollection","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].ICollection$1(T),"ps":1}],"sn":"InsertCollection","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].ICollection$1(T)]},{"a":1,"n":"InsertEnumeration","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertEnumeration","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"InsertRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"LastIndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"LastIndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"LastIndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pop","t":8,"sn":"Pop","rt":T},{"a":2,"n":"Remove","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Remove","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"RemoveAll","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"RemoveAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"RemoveRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"RemoveRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Resize","t":8,"pi":[{"n":"newSize","pt":$n[0].Int32,"ps":0}],"sn":"Resize","rt":$n[8].ExposedList$1(T),"p":[$n[0].Int32]},{"a":2,"n":"Reverse","t":8,"sn":"Reverse","rt":$n[0].Void},{"a":2,"n":"Reverse","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"Reverse$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":1,"n":"Shift","t":8,"pi":[{"n":"start","pt":$n[0].Int32,"ps":0},{"n":"delta","pt":$n[0].Int32,"ps":1}],"sn":"Shift","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Sort","t":8,"sn":"Sort","rt":$n[0].Void},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":0}],"sn":"Sort$1","rt":$n[0].Void,"p":[$n[2].IComparer$1(T)]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparison","pt":Function,"ps":0}],"sn":"Sort$2","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":2}],"sn":"Sort$3","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[2].IComparer$1(T)]},{"a":2,"n":"ToArray","t":8,"sn":"ToArray","rt":System.Array.type(T)},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TrueForAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"TrueForAll","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Capacity","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Capacity","t":8,"rt":$n[0].Int32,"fg":"Capacity","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Capacity","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Capacity"},"fn":"Capacity"},{"a":2,"n":"Count","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"DefaultCapacity","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyArray","is":true,"t":4,"rt":System.Array.type(T),"sn":"EmptyArray","ro":true},{"a":2,"n":"Items","t":4,"rt":System.Array.type(T),"sn":"Items"},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    $m("Spine.ExposedList$1.Enumerator", function (T) { return {"td":$n[8].ExposedList$1(T),"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":".ctor","t":1,"p":[$n[8].ExposedList$1(T)],"pi":[{"n":"l","pt":$n[8].ExposedList$1(T),"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"MoveNext","t":8,"sn":"moveNext","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"VerifyState","t":8,"sn":"VerifyState","rt":$n[0].Void},{"a":2,"n":"Current","t":16,"rt":T,"g":{"a":2,"n":"get_Current","t":8,"rt":T,"fg":"Current"},"fn":"Current"},{"a":1,"n":"current","t":4,"rt":T,"sn":"current"},{"a":1,"n":"l","t":4,"rt":$n[8].ExposedList$1(T),"sn":"l"},{"a":1,"n":"next","t":4,"rt":$n[0].Int32,"sn":"next","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ver","t":4,"rt":$n[0].Int32,"sn":"ver","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.IkConstraint start.*/
    $m("Spine.IkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].IkConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].IkConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].IkConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].IkConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"targetX","pt":$n[0].Single,"ps":1},{"n":"targetY","pt":$n[0].Single,"ps":2},{"n":"compress","pt":$n[0].Boolean,"ps":3},{"n":"stretch","pt":$n[0].Boolean,"ps":4},{"n":"uniform","pt":$n[0].Boolean,"ps":5},{"n":"alpha","pt":$n[0].Single,"ps":6}],"sn":"Apply$1","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"parent","pt":$n[8].Bone,"ps":0},{"n":"child","pt":$n[8].Bone,"ps":1},{"n":"targetX","pt":$n[0].Single,"ps":2},{"n":"targetY","pt":$n[0].Single,"ps":3},{"n":"bendDir","pt":$n[0].Int32,"ps":4},{"n":"stretch","pt":$n[0].Boolean,"ps":5},{"n":"softness","pt":$n[0].Single,"ps":6},{"n":"alpha","pt":$n[0].Single,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Bone,$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Data","t":16,"rt":$n[8].IkConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].IkConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"data","t":4,"rt":$n[8].IkConstraintData,"sn":"data"},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[8].Bone,"sn":"target"}]}; }, $n);
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    $m("Spine.IkConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"Uniform","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Uniform","t":8,"rt":$n[0].Boolean,"fg":"Uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Uniform","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Uniform"},"fn":"Uniform"},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[8].BoneData,"sn":"target"},{"a":4,"n":"uniform","t":4,"rt":$n[0].Boolean,"sn":"uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IkConstraintData end.*/

    /*Spine.IUpdatable start.*/
    $m("Spine.IUpdatable", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Update","t":8,"sn":"Spine$IUpdatable$Update","rt":$n[0].Void},{"ab":true,"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Spine$IUpdatable$Active"},{"a":1,"backing":true,"n":"<Active>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IUpdatable end.*/

    /*Spine.Json start.*/
    $m("Spine.Json", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Deserialize","is":true,"t":8,"pi":[{"n":"text","pt":$n[9].TextReader,"ps":0}],"sn":"Deserialize","rt":$n[0].Object,"p":[$n[9].TextReader]}]}; }, $n);
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    $m("Spine.MathUtils", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Atan2","is":true,"t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"Atan2","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Clamp","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"Clamp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Cos","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Cos","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"CosDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"CosDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1}],"sn":"RandomTriangle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[0].Single,"ps":2}],"sn":"RandomTriangle$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Sin","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Sin","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SinDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"SinDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DegRad","is":true,"t":4,"rt":$n[0].Single,"sn":"DegRad","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI","is":true,"t":4,"rt":$n[0].Single,"sn":"PI","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI2","is":true,"t":4,"rt":$n[0].Single,"sn":"PI2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RadDeg","is":true,"t":4,"rt":$n[0].Single,"sn":"RadDeg","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"random","is":true,"t":4,"rt":$n[0].Random,"sn":"random"}]}; }, $n);
    /*Spine.MathUtils end.*/

    /*Spine.IInterpolation start.*/
    $m("Spine.IInterpolation", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"start","pt":$n[0].Single,"ps":0},{"n":"end","pt":$n[0].Single,"ps":1},{"n":"a","pt":$n[0].Single,"ps":2}],"sn":"Apply","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Pow2","is":true,"t":4,"rt":$n[8].IInterpolation,"sn":"Pow2"},{"a":2,"n":"Pow2Out","is":true,"t":4,"rt":$n[8].IInterpolation,"sn":"Pow2Out"}]}; }, $n);
    /*Spine.IInterpolation end.*/

    /*Spine.Pow start.*/
    $m("Spine.Pow", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Power","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Power","t":8,"rt":$n[0].Single,"fg":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Power","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Power"},"fn":"Power"},{"a":1,"backing":true,"n":"<Power>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Pow end.*/

    /*Spine.PowOut start.*/
    $m("Spine.PowOut", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PowOut end.*/

    /*Spine.PathConstraint start.*/
    $m("Spine.PathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].PathConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].PathConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].PathConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].PathConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"AddAfterPosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddAfterPosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddBeforePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddBeforePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddCurvePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"cx1","pt":$n[0].Single,"ps":3},{"n":"cy1","pt":$n[0].Single,"ps":4},{"n":"cx2","pt":$n[0].Single,"ps":5},{"n":"cy2","pt":$n[0].Single,"ps":6},{"n":"x2","pt":$n[0].Single,"ps":7},{"n":"y2","pt":$n[0].Single,"ps":8},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":9},{"n":"o","pt":$n[0].Int32,"ps":10},{"n":"tangents","pt":$n[0].Boolean,"ps":11}],"sn":"AddCurvePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"ComputeWorldPositions","t":8,"pi":[{"n":"path","pt":$n[8].PathAttachment,"ps":0},{"n":"spacesCount","pt":$n[0].Int32,"ps":1},{"n":"tangents","pt":$n[0].Boolean,"ps":2},{"n":"percentPosition","pt":$n[0].Boolean,"ps":3},{"n":"percentSpacing","pt":$n[0].Boolean,"ps":4}],"sn":"ComputeWorldPositions","rt":$n[0].Array.type(System.Single),"p":[$n[8].PathAttachment,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].PathConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].PathConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"Target","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Slot,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Slot],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":1,"n":"AFTER","is":true,"t":4,"rt":$n[0].Int32,"sn":"AFTER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"BEFORE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEFORE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Epsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"Epsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NONE","is":true,"t":4,"rt":$n[0].Int32,"sn":"NONE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"curves","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"curves"},{"a":4,"n":"data","t":4,"rt":$n[8].PathConstraintData,"sn":"data"},{"a":4,"n":"lengths","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"lengths"},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positions","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"positions"},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"segments","t":4,"rt":$n[0].Array.type(System.Single),"sn":"segments"},{"a":4,"n":"spaces","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"spaces"},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[8].Slot,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"world","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"world"}]}; }, $n);
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    $m("Spine.PathConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"PositionMode","t":16,"rt":$n[8].PositionMode,"g":{"a":2,"n":"get_PositionMode","t":8,"rt":$n[8].PositionMode,"fg":"PositionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},"s":{"a":2,"n":"set_PositionMode","t":8,"p":[$n[8].PositionMode],"rt":$n[0].Void,"fs":"PositionMode"},"fn":"PositionMode"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"RotateMode","t":16,"rt":$n[8].RotateMode,"g":{"a":2,"n":"get_RotateMode","t":8,"rt":$n[8].RotateMode,"fg":"RotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},"s":{"a":2,"n":"set_RotateMode","t":8,"p":[$n[8].RotateMode],"rt":$n[0].Void,"fs":"RotateMode"},"fn":"RotateMode"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"SpacingMode","t":16,"rt":$n[8].SpacingMode,"g":{"a":2,"n":"get_SpacingMode","t":8,"rt":$n[8].SpacingMode,"fg":"SpacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},"s":{"a":2,"n":"set_SpacingMode","t":8,"p":[$n[8].SpacingMode],"rt":$n[0].Void,"fs":"SpacingMode"},"fn":"SpacingMode"},{"a":2,"n":"Target","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].SlotData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].SlotData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positionMode","t":4,"rt":$n[8].PositionMode,"sn":"positionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"rotateMode","t":4,"rt":$n[8].RotateMode,"sn":"rotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"spacingMode","t":4,"rt":$n[8].SpacingMode,"sn":"spacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":4,"n":"target","t":4,"rt":$n[8].SlotData,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PathConstraintData end.*/

    /*Spine.PositionMode start.*/
    $m("Spine.PositionMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[8].PositionMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[8].PositionMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}}]}; }, $n);
    /*Spine.PositionMode end.*/

    /*Spine.SpacingMode start.*/
    $m("Spine.SpacingMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Length","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Length","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}}]}; }, $n);
    /*Spine.SpacingMode end.*/

    /*Spine.RotateMode start.*/
    $m("Spine.RotateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Chain","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"Chain","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"ChainScale","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"ChainScale","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"Tangent","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"Tangent","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}}]}; }, $n);
    /*Spine.RotateMode end.*/

    /*Spine.Skeleton start.*/
    $m("Spine.Skeleton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].SkeletonData],"pi":[{"n":"data","pt":$n[8].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[8].Bone,"p":[$n[0].String]},{"a":2,"n":"FindBoneIndex","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBoneIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[8].IkConstraint,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[8].PathConstraint,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[8].Slot,"p":[$n[0].String]},{"a":2,"n":"FindSlotIndex","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[8].TransformConstraint,"p":[$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[8].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment$1","rt":$n[8].Attachment,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetBounds","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"width","out":true,"pt":$n[0].Single,"ps":2},{"n":"height","out":true,"pt":$n[0].Single,"ps":3},{"n":"vertexBuffer","ref":true,"pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"GetBounds","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetBonesToSetupPose","t":8,"sn":"SetBonesToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"newSkin","pt":$n[8].Skin,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"SetSkin$1","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetSlotsToSetupPose","t":8,"sn":"SetSlotsToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"a":1,"n":"SortBone","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"SortBone","rt":$n[0].Void,"p":[$n[8].Bone]},{"a":1,"n":"SortIkConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].IkConstraint,"ps":0}],"sn":"SortIkConstraint","rt":$n[0].Void,"p":[$n[8].IkConstraint]},{"a":1,"n":"SortPathConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].PathConstraint,"ps":0}],"sn":"SortPathConstraint","rt":$n[0].Void,"p":[$n[8].PathConstraint]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0},{"n":"slotBone","pt":$n[8].Bone,"ps":1}],"sn":"SortPathConstraintAttachment","rt":$n[0].Void,"p":[$n[8].Attachment,$n[8].Bone]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"slotBone","pt":$n[8].Bone,"ps":2}],"sn":"SortPathConstraintAttachment$1","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,$n[8].Bone]},{"a":1,"n":"SortReset","is":true,"t":8,"pi":[{"n":"bones","pt":$n[8].ExposedList$1(Spine.Bone),"ps":0}],"sn":"SortReset","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Bone)]},{"a":1,"n":"SortTransformConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].TransformConstraint,"ps":0}],"sn":"SortTransformConstraint","rt":$n[0].Void,"p":[$n[8].TransformConstraint]},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateCache","t":8,"sn":"UpdateCache","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"parent","pt":$n[8].Bone,"ps":0}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[8].Bone]},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].SkeletonData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"DrawOrder","t":16,"rt":$n[8].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_DrawOrder","t":8,"rt":$n[8].ExposedList$1(Spine.Slot),"fg":"DrawOrder"},"fn":"DrawOrder"},{"a":2,"n":"FlipX","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipX","t":8,"rt":$n[0].Boolean,"fg":"FlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipX","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipX"},"fn":"FlipX"},{"a":2,"n":"FlipY","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipY","t":8,"rt":$n[0].Boolean,"fg":"FlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipY","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipY"},"fn":"FlipY"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"fg":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"fg":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RootBone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_RootBone","t":8,"rt":$n[8].Bone,"fg":"RootBone"},"fn":"RootBone"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Skin","t":16,"rt":$n[8].Skin,"g":{"a":2,"n":"get_Skin","t":8,"rt":$n[8].Skin,"fg":"Skin"},"s":{"a":2,"n":"set_Skin","t":8,"p":[$n[8].Skin],"rt":$n[0].Void,"fs":"Skin"},"fn":"Skin"},{"a":2,"n":"Slots","t":16,"rt":$n[8].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[8].ExposedList$1(Spine.Slot),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Time","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Time"},"fn":"Time"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"fg":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"UpdateCacheList","t":16,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"g":{"a":2,"n":"get_UpdateCacheList","t":8,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"fg":"UpdateCacheList"},"fn":"UpdateCacheList"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[8].SkeletonData,"sn":"data"},{"a":4,"n":"drawOrder","t":4,"rt":$n[8].ExposedList$1(Spine.Slot),"sn":"drawOrder"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"sn":"ikConstraints"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"sn":"pathConstraints"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skin","t":4,"rt":$n[8].Skin,"sn":"skin"},{"a":4,"n":"slots","t":4,"rt":$n[8].ExposedList$1(Spine.Slot),"sn":"slots"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"transformConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"sn":"transformConstraints"},{"a":4,"n":"updateCache","t":4,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"sn":"updateCache"},{"a":4,"n":"updateCacheReset","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"updateCacheReset"},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonBinary start.*/
    $m("Spine.SkeletonBinary", function () { return {"nested":[$n[8].SkeletonBinary.Vertices,$n[8].SkeletonBinary.SkeletonInput],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"GetVersionString","is":true,"t":8,"pi":[{"n":"file","pt":$n[9].Stream,"ps":0}],"sn":"GetVersionString","rt":$n[0].String,"p":[$n[9].Stream]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[8].Animation,"p":[$n[0].String,$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1},{"n":"skin","pt":$n[8].Skin,"ps":2},{"n":"slotIndex","pt":$n[0].Int32,"ps":3},{"n":"attachmentName","pt":$n[0].String,"ps":4},{"n":"nonessential","pt":$n[0].Boolean,"ps":5}],"sn":"ReadAttachment","rt":$n[8].Attachment,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData,$n[8].Skin,$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"ReadCurve","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"frameIndex","pt":$n[0].Int32,"ps":1},{"n":"timeline","pt":$n[8].CurveTimeline,"ps":2}],"sn":"ReadCurve","rt":$n[0].Void,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[8].CurveTimeline]},{"a":1,"n":"ReadFloatArray","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"n","pt":$n[0].Int32,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ReadShortArray","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0}],"sn":"ReadShortArray","rt":$n[0].Array.type(System.Int32),"p":[$n[8].SkeletonBinary.SkeletonInput]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"file","pt":$n[9].Stream,"ps":0}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[9].Stream]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadSkin","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1},{"n":"defaultSkin","pt":$n[0].Boolean,"ps":2},{"n":"nonessential","pt":$n[0].Boolean,"ps":3}],"sn":"ReadSkin","rt":$n[8].Skin,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1}],"sn":"ReadVertices","rt":$n[8].SkeletonBinary.Vertices,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Int32]},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":2,"n":"BONE_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_POSITION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_POSITION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_SPACING","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_SPACING","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ATTACHMENT","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ATTACHMENT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_COLOR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_COLOR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_TWO_COLOR","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_TWO_COLOR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TransformModeValues","is":true,"t":4,"rt":System.Array.type(Spine.TransformMode),"sn":"TransformModeValues","ro":true},{"a":1,"n":"attachmentLoader","t":4,"rt":$n[8].AttachmentLoader,"sn":"attachmentLoader"},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[2].List$1(Spine.SkeletonJson.LinkedMesh),"sn":"linkedMeshes"},{"a":1,"backing":true,"n":"<Scale>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    $m("Spine.SkeletonBinary.Vertices", function () { return {"td":$n[8].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":2,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"}]}; }, $n);
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    $m("Spine.SkeletonBinary.SkeletonInput", function () { return {"td":$n[8].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].Stream],"pi":[{"n":"input","pt":$n[9].Stream,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetVersionString","t":8,"sn":"GetVersionString","rt":$n[0].String},{"a":2,"n":"ReadBoolean","t":8,"sn":"ReadBoolean","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ReadByte","t":8,"sn":"ReadByte","rt":$n[0].Byte,"box":function ($v) { return Bridge.box($v, System.Byte);}},{"a":2,"n":"ReadFloat","t":8,"sn":"ReadFloat","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ReadFully","t":8,"pi":[{"n":"buffer","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"offset","pt":$n[0].Int32,"ps":1},{"n":"length","pt":$n[0].Int32,"ps":2}],"sn":"ReadFully","rt":$n[0].Void,"p":[$n[0].Array.type(System.Byte),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ReadInt","t":8,"sn":"ReadInt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadInt","t":8,"pi":[{"n":"optimizePositive","pt":$n[0].Boolean,"ps":0}],"sn":"ReadInt$1","rt":$n[0].Int32,"p":[$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadSByte","t":8,"sn":"ReadSByte","rt":$n[0].SByte,"box":function ($v) { return Bridge.box($v, System.SByte);}},{"a":2,"n":"ReadString","t":8,"sn":"ReadString","rt":$n[0].String},{"a":2,"n":"ReadStringRef","t":8,"sn":"ReadStringRef","rt":$n[0].String},{"a":1,"n":"bytesBigEndian","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"bytesBigEndian"},{"a":1,"n":"chars","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"chars"},{"a":1,"n":"input","t":4,"rt":$n[9].Stream,"sn":"input"},{"a":4,"n":"strings","t":4,"rt":$n[8].ExposedList$1(System.String),"sn":"strings"}]}; }, $n);
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBounds start.*/
    $m("Spine.SkeletonBounds", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AabbCompute","t":8,"sn":"AabbCompute","rt":$n[0].Void},{"a":2,"n":"AabbContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"AabbContainsPoint","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"AabbIntersectsSegment","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSkeleton","t":8,"pi":[{"n":"bounds","pt":$n[8].SkeletonBounds,"ps":0}],"sn":"AabbIntersectsSkeleton","rt":$n[0].Boolean,"p":[$n[8].SkeletonBounds],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"ContainsPoint","rt":$n[8].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"polygon","pt":$n[8].Polygon,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"ContainsPoint$1","rt":$n[0].Boolean,"p":[$n[8].Polygon,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetPolygon","t":8,"pi":[{"n":"attachment","pt":$n[8].BoundingBoxAttachment,"ps":0}],"sn":"GetPolygon","rt":$n[8].Polygon,"p":[$n[8].BoundingBoxAttachment]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"IntersectsSegment","rt":$n[8].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"polygon","pt":$n[8].Polygon,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"x2","pt":$n[0].Single,"ps":3},{"n":"y2","pt":$n[0].Single,"ps":4}],"sn":"IntersectsSegment$1","rt":$n[0].Boolean,"p":[$n[8].Polygon,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Update","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"updateAabb","pt":$n[0].Boolean,"ps":1}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Boolean]},{"a":2,"n":"BoundingBoxes","t":16,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"g":{"a":2,"n":"get_BoundingBoxes","t":8,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"fg":"BoundingBoxes"},"s":{"a":1,"n":"set_BoundingBoxes","t":8,"p":[$n[8].ExposedList$1(Spine.BoundingBoxAttachment)],"rt":$n[0].Void,"fs":"BoundingBoxes"},"fn":"BoundingBoxes"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MaxX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxX","t":8,"rt":$n[0].Single,"fg":"MaxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxX"},"fn":"MaxX"},{"a":2,"n":"MaxY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxY","t":8,"rt":$n[0].Single,"fg":"MaxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxY"},"fn":"MaxY"},{"a":2,"n":"MinX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinX","t":8,"rt":$n[0].Single,"fg":"MinX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinX"},"fn":"MinX"},{"a":2,"n":"MinY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinY","t":8,"rt":$n[0].Single,"fg":"MinY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinY"},"fn":"MinY"},{"a":2,"n":"Polygons","t":16,"rt":$n[8].ExposedList$1(Spine.Polygon),"g":{"a":2,"n":"get_Polygons","t":8,"rt":$n[8].ExposedList$1(Spine.Polygon),"fg":"Polygons"},"s":{"a":1,"n":"set_Polygons","t":8,"p":[$n[8].ExposedList$1(Spine.Polygon)],"rt":$n[0].Void,"fs":"Polygons"},"fn":"Polygons"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":1,"n":"maxX","t":4,"rt":$n[0].Single,"sn":"maxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"maxY","t":4,"rt":$n[0].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minX","t":4,"rt":$n[0].Single,"sn":"minX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minY","t":4,"rt":$n[0].Single,"sn":"minY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"polygonPool","t":4,"rt":$n[8].ExposedList$1(Spine.Polygon),"sn":"polygonPool"},{"a":1,"backing":true,"n":"<BoundingBoxes>k__BackingField","t":4,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"sn":"BoundingBoxes"},{"a":1,"backing":true,"n":"<Polygons>k__BackingField","t":4,"rt":$n[8].ExposedList$1(Spine.Polygon),"sn":"Polygons"}]}; }, $n);
    /*Spine.SkeletonBounds end.*/

    /*Spine.Polygon start.*/
    $m("Spine.Polygon", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":1,"backing":true,"n":"<Count>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Vertices>k__BackingField","t":4,"rt":$n[0].Array.type(System.Single),"sn":"Vertices"}]}; }, $n);
    /*Spine.Polygon end.*/

    /*Spine.SkeletonClipping start.*/
    $m("Spine.SkeletonClipping", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Clip","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3},{"n":"x3","pt":$n[0].Single,"ps":4},{"n":"y3","pt":$n[0].Single,"ps":5},{"n":"clippingArea","pt":$n[8].ExposedList$1(System.Single),"ps":6},{"n":"output","pt":$n[8].ExposedList$1(System.Single),"ps":7}],"sn":"Clip","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(System.Single),$n[8].ExposedList$1(System.Single)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ClipEnd","t":8,"sn":"ClipEnd","rt":$n[0].Void},{"a":2,"n":"ClipEnd","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0}],"sn":"ClipEnd$1","rt":$n[0].Void,"p":[$n[8].Slot]},{"a":2,"n":"ClipStart","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"clip","pt":$n[8].ClippingAttachment,"ps":1}],"sn":"ClipStart","rt":$n[0].Int32,"p":[$n[8].Slot,$n[8].ClippingAttachment],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ClipTriangles","t":8,"pi":[{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"verticesLength","pt":$n[0].Int32,"ps":1},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":2},{"n":"trianglesLength","pt":$n[0].Int32,"ps":3},{"n":"uvs","pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"ClipTriangles","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Int32),$n[0].Int32,$n[0].Array.type(System.Single)]},{"a":2,"n":"MakeClockwise","is":true,"t":8,"pi":[{"n":"polygon","pt":$n[8].ExposedList$1(System.Single),"ps":0}],"sn":"MakeClockwise","rt":$n[0].Void,"p":[$n[8].ExposedList$1(System.Single)]},{"a":2,"n":"ClippedTriangles","t":16,"rt":$n[8].ExposedList$1(System.Int32),"g":{"a":2,"n":"get_ClippedTriangles","t":8,"rt":$n[8].ExposedList$1(System.Int32),"fg":"ClippedTriangles"},"fn":"ClippedTriangles"},{"a":2,"n":"ClippedUVs","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedUVs","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"ClippedUVs"},"fn":"ClippedUVs"},{"a":2,"n":"ClippedVertices","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedVertices","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"ClippedVertices"},"fn":"ClippedVertices"},{"a":2,"n":"IsClipping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClipping","t":8,"rt":$n[0].Boolean,"fg":"IsClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClipping"},{"a":4,"n":"clipAttachment","t":4,"rt":$n[8].ClippingAttachment,"sn":"clipAttachment"},{"a":4,"n":"clipOutput","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clipOutput","ro":true},{"a":4,"n":"clippedTriangles","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"clippedTriangles","ro":true},{"a":4,"n":"clippedUVs","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippedUVs","ro":true},{"a":4,"n":"clippedVertices","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippedVertices","ro":true},{"a":4,"n":"clippingPolygon","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippingPolygon","ro":true},{"a":4,"n":"clippingPolygons","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"clippingPolygons"},{"a":4,"n":"scratch","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"scratch","ro":true},{"a":4,"n":"triangulator","t":4,"rt":$n[8].Triangulator,"sn":"triangulator","ro":true}]}; }, $n);
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    $m("Spine.SkeletonData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FindAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0}],"sn":"FindAnimation","rt":$n[8].Animation,"p":[$n[0].String]},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[8].BoneData,"p":[$n[0].String]},{"a":2,"n":"FindBoneIndex","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBoneIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindEvent","t":8,"pi":[{"n":"eventDataName","pt":$n[0].String,"ps":0}],"sn":"FindEvent","rt":$n[8].EventData,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[8].IkConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[8].PathConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraintIndex","t":8,"pi":[{"n":"pathConstraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraintIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"FindSkin","rt":$n[8].Skin,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[8].SlotData,"p":[$n[0].String]},{"a":2,"n":"FindSlotIndex","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[8].TransformConstraintData,"p":[$n[0].String]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Animations","t":16,"rt":$n[8].ExposedList$1(Spine.Animation),"g":{"a":2,"n":"get_Animations","t":8,"rt":$n[8].ExposedList$1(Spine.Animation),"fg":"Animations"},"s":{"a":2,"n":"set_Animations","t":8,"p":[$n[8].ExposedList$1(Spine.Animation)],"rt":$n[0].Void,"fs":"Animations"},"fn":"Animations"},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"DefaultSkin","t":16,"rt":$n[8].Skin,"g":{"a":2,"n":"get_DefaultSkin","t":8,"rt":$n[8].Skin,"fg":"DefaultSkin"},"s":{"a":2,"n":"set_DefaultSkin","t":8,"p":[$n[8].Skin],"rt":$n[0].Void,"fs":"DefaultSkin"},"fn":"DefaultSkin"},{"a":2,"n":"Events","t":16,"rt":$n[8].ExposedList$1(Spine.EventData),"g":{"a":2,"n":"get_Events","t":8,"rt":$n[8].ExposedList$1(Spine.EventData),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[$n[8].ExposedList$1(Spine.EventData)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"Fps","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Fps","t":8,"rt":$n[0].Single,"fg":"Fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Fps","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Fps"},"fn":"Fps"},{"a":2,"n":"Hash","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Hash","t":8,"rt":$n[0].String,"fg":"Hash"},"s":{"a":2,"n":"set_Hash","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Hash"},"fn":"Hash"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"fg":"IkConstraints"},"s":{"a":2,"n":"set_IkConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.IkConstraintData)],"rt":$n[0].Void,"fs":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"ImagesPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_ImagesPath","t":8,"rt":$n[0].String,"fg":"ImagesPath"},"s":{"a":2,"n":"set_ImagesPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"ImagesPath"},"fn":"ImagesPath"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":2,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"fg":"PathConstraints"},"s":{"a":2,"n":"set_PathConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.PathConstraintData)],"rt":$n[0].Void,"fs":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"Skins","t":16,"rt":$n[8].ExposedList$1(Spine.Skin),"g":{"a":2,"n":"get_Skins","t":8,"rt":$n[8].ExposedList$1(Spine.Skin),"fg":"Skins"},"s":{"a":2,"n":"set_Skins","t":8,"p":[$n[8].ExposedList$1(Spine.Skin)],"rt":$n[0].Void,"fs":"Skins"},"fn":"Skins"},{"a":2,"n":"Slots","t":16,"rt":$n[8].ExposedList$1(Spine.SlotData),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[8].ExposedList$1(Spine.SlotData),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"fg":"TransformConstraints"},"s":{"a":2,"n":"set_TransformConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.TransformConstraintData)],"rt":$n[0].Void,"fs":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"Version","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Version","t":8,"rt":$n[0].String,"fg":"Version"},"s":{"a":2,"n":"set_Version","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Version"},"fn":"Version"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"animations","t":4,"rt":$n[8].ExposedList$1(Spine.Animation),"sn":"animations"},{"a":4,"n":"audioPath","t":4,"rt":$n[0].String,"sn":"audioPath"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"defaultSkin","t":4,"rt":$n[8].Skin,"sn":"defaultSkin"},{"a":4,"n":"events","t":4,"rt":$n[8].ExposedList$1(Spine.EventData),"sn":"events"},{"a":4,"n":"fps","t":4,"rt":$n[0].Single,"sn":"fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hash","t":4,"rt":$n[0].String,"sn":"hash"},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"sn":"ikConstraints"},{"a":4,"n":"imagesPath","t":4,"rt":$n[0].String,"sn":"imagesPath"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"sn":"pathConstraints"},{"a":4,"n":"skins","t":4,"rt":$n[8].ExposedList$1(Spine.Skin),"sn":"skins"},{"a":4,"n":"slots","t":4,"rt":$n[8].ExposedList$1(Spine.SlotData),"sn":"slots"},{"a":4,"n":"transformConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"sn":"transformConstraints"},{"a":4,"n":"version","t":4,"rt":$n[0].String,"sn":"version"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    $m("Spine.SkeletonJson", function () { return {"nested":[$n[8].SkeletonJson.LinkedMesh],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":1,"n":"GetBoolean","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Boolean,"ps":2}],"sn":"GetBoolean","rt":$n[0].Boolean,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetFloat","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2}],"sn":"GetFloat","rt":$n[0].Single,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetFloatArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"GetFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single]},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Int32,"ps":2}],"sn":"GetInt","rt":$n[0].Int32,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetIntArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetIntArray","rt":$n[0].Array.type(System.Int32),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String]},{"a":1,"n":"GetString","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].String,"ps":2}],"sn":"GetString","rt":$n[0].String,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].String]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[8].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"skin","pt":$n[8].Skin,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"name","pt":$n[0].String,"ps":3},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":4}],"sn":"ReadAttachment","rt":$n[8].Attachment,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[8].Skin,$n[0].Int32,$n[0].String,$n[8].SkeletonData]},{"a":1,"n":"ReadCurve","is":true,"t":8,"pi":[{"n":"valueMap","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"timeline","pt":$n[8].CurveTimeline,"ps":1},{"n":"frameIndex","pt":$n[0].Int32,"ps":2}],"sn":"ReadCurve","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[8].CurveTimeline,$n[0].Int32]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[9].TextReader]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"attachment","pt":$n[8].VertexAttachment,"ps":1},{"n":"verticesLength","pt":$n[0].Int32,"ps":2}],"sn":"ReadVertices","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[8].VertexAttachment,$n[0].Int32]},{"a":1,"n":"ToColor","is":true,"t":8,"pi":[{"n":"hexString","pt":$n[0].String,"ps":0},{"n":"colorIndex","pt":$n[0].Int32,"ps":1},{"n":"expectedLength","dv":8,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"ToColor","rt":$n[0].Single,"p":[$n[0].String,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":1,"n":"attachmentLoader","t":4,"rt":$n[8].AttachmentLoader,"sn":"attachmentLoader"},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[2].List$1(Spine.SkeletonJson.LinkedMesh),"sn":"linkedMeshes"},{"a":1,"backing":true,"n":"<Scale>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    $m("Spine.SkeletonJson.LinkedMesh", function () { return {"td":$n[8].SkeletonJson,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].MeshAttachment,$n[0].String,$n[0].Int32,$n[0].String,$n[0].Boolean],"pi":[{"n":"mesh","pt":$n[8].MeshAttachment,"ps":0},{"n":"skin","pt":$n[0].String,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"parent","pt":$n[0].String,"ps":3},{"n":"inheritDeform","pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":4,"n":"inheritDeform","t":4,"rt":$n[0].Boolean,"sn":"inheritDeform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mesh","t":4,"rt":$n[8].MeshAttachment,"sn":"mesh"},{"a":4,"n":"parent","t":4,"rt":$n[0].String,"sn":"parent"},{"a":4,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.Skin start.*/
    $m("Spine.Skin", function () { return {"nested":[$n[8].Skin.SkinEntry,$n[8].Skin.SkinEntryComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0}],"sn":"AddSkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":4,"n":"AttachAll","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"oldSkin","pt":$n[8].Skin,"ps":1}],"sn":"AttachAll","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Skin]},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CopySkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0}],"sn":"CopySkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[8].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachments","t":8,"sn":"GetAttachments","rt":$n[2].ICollection$1(Spine.Skin.SkinEntry)},{"a":2,"n":"GetAttachments","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachments","pt":$n[2].List$1(Spine.Skin.SkinEntry),"ps":1}],"sn":"GetAttachments$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].List$1(Spine.Skin.SkinEntry)]},{"a":2,"n":"RemoveAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[8].Attachment,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String,$n[8].Attachment]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Attachments","t":16,"rt":$n[10].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"g":{"a":2,"n":"get_Attachments","t":8,"rt":$n[10].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"fg":"Attachments"},"fn":"Attachments"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Constraints","t":16,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"g":{"a":2,"n":"get_Constraints","t":8,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"fg":"Constraints"},"fn":"Constraints"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"n":"attachments","t":4,"rt":$n[10].OrderedDictionary$2(Spine.Skin.SkinEntry,Spine.Attachment),"sn":"attachments"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones","ro":true},{"a":4,"n":"constraints","t":4,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"sn":"constraints","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    $m("Spine.Skin.SkinEntry", function () { return {"td":$n[8].Skin,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].Attachment],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[8].Attachment,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Attachment","t":16,"rt":$n[8].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"attachment","t":4,"rt":$n[8].Attachment,"sn":"attachment","ro":true},{"a":4,"n":"hashCode","t":4,"rt":$n[0].Int32,"sn":"hashCode","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinEntryComparer start.*/
    $m("Spine.Skin.SkinEntryComparer", function () { return {"td":$n[8].Skin,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[8].Skin.SkinEntryComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Skin+SkinEntryComparer end.*/

    /*Spine.Slot start.*/
    $m("Spine.Slot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].Slot,$n[8].Bone],"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].SlotData,$n[8].Bone],"pi":[{"n":"data","pt":$n[8].SlotData,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"ClampColor","t":8,"sn":"ClampColor","rt":$n[0].Void},{"a":2,"n":"ClampSecondColor","t":8,"sn":"ClampSecondColor","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"Attachment","t":16,"rt":$n[8].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].Attachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[8].Attachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"AttachmentTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AttachmentTime","t":8,"rt":$n[0].Single,"fg":"AttachmentTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AttachmentTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AttachmentTime"},"fn":"AttachmentTime"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"Bone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[8].Bone,"fg":"Bone"},"fn":"Bone"},{"a":2,"n":"Data","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].SlotData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Deform","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_Deform","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"Deform"},"s":{"a":2,"n":"set_Deform","t":8,"p":[$n[8].ExposedList$1(System.Single)],"rt":$n[0].Void,"fs":"Deform"},"fn":"Deform"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachment","t":4,"rt":$n[8].Attachment,"sn":"attachment"},{"a":4,"n":"attachmentState","t":4,"rt":$n[0].Int32,"sn":"attachmentState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"attachmentTime","t":4,"rt":$n[0].Single,"sn":"attachmentTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":4,"n":"data","t":4,"rt":$n[8].SlotData,"sn":"data"},{"a":4,"n":"deform","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"deform"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    $m("Spine.SlotData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"boneData","pt":$n[8].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AttachmentName","t":8,"rt":$n[0].String,"fg":"AttachmentName"},"s":{"a":2,"n":"set_AttachmentName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AttachmentName"},"fn":"AttachmentName"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"BlendMode","t":16,"rt":$n[8].BlendMode,"g":{"a":2,"n":"get_BlendMode","t":8,"rt":$n[8].BlendMode,"fg":"BlendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},"s":{"a":2,"n":"set_BlendMode","t":8,"p":[$n[8].BlendMode],"rt":$n[0].Void,"fs":"BlendMode"},"fn":"BlendMode"},{"a":2,"n":"BoneData","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_BoneData","t":8,"rt":$n[8].BoneData,"fg":"BoneData"},"fn":"BoneData"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentName","t":4,"rt":$n[0].String,"sn":"attachmentName"},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"blendMode","t":4,"rt":$n[8].BlendMode,"sn":"blendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":4,"n":"boneData","t":4,"rt":$n[8].BoneData,"sn":"boneData"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SlotData end.*/

    /*Spine.TransformConstraint start.*/
    $m("Spine.TransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TransformConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].TransformConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].TransformConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].TransformConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteLocal","t":8,"sn":"ApplyAbsoluteLocal","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteWorld","t":8,"sn":"ApplyAbsoluteWorld","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeLocal","t":8,"sn":"ApplyRelativeLocal","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeWorld","t":8,"sn":"ApplyRelativeWorld","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].TransformConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].TransformConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"ScaleMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleMix","t":8,"rt":$n[0].Single,"fg":"ScaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleMix"},"fn":"ScaleMix"},{"a":2,"n":"ShearMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearMix","t":8,"rt":$n[0].Single,"fg":"ShearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearMix"},"fn":"ShearMix"},{"a":2,"n":"Target","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[8].TransformConstraintData,"sn":"data"},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleMix","t":4,"rt":$n[0].Single,"sn":"scaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearMix","t":4,"rt":$n[0].Single,"sn":"shearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[8].Bone,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    $m("Spine.TransformConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Local","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Local","t":8,"rt":$n[0].Boolean,"fg":"Local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Local","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Local"},"fn":"Local"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"OffsetScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleX","t":8,"rt":$n[0].Single,"fg":"OffsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleX"},"fn":"OffsetScaleX"},{"a":2,"n":"OffsetScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleY","t":8,"rt":$n[0].Single,"fg":"OffsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleY"},"fn":"OffsetScaleY"},{"a":2,"n":"OffsetShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetShearY","t":8,"rt":$n[0].Single,"fg":"OffsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetShearY"},"fn":"OffsetShearY"},{"a":2,"n":"OffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetX","t":8,"rt":$n[0].Single,"fg":"OffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetX"},"fn":"OffsetX"},{"a":2,"n":"OffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetY","t":8,"rt":$n[0].Single,"fg":"OffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetY"},"fn":"OffsetY"},{"a":2,"n":"Relative","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Relative","t":8,"rt":$n[0].Boolean,"fg":"Relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Relative","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Relative"},"fn":"Relative"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"ScaleMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleMix","t":8,"rt":$n[0].Single,"fg":"ScaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleMix"},"fn":"ScaleMix"},{"a":2,"n":"ShearMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearMix","t":8,"rt":$n[0].Single,"fg":"ShearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearMix"},"fn":"ShearMix"},{"a":2,"n":"Target","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"TranslateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TranslateMix","t":8,"rt":$n[0].Single,"fg":"TranslateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TranslateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TranslateMix"},"fn":"TranslateMix"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"local","t":4,"rt":$n[0].Boolean,"sn":"local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleX","t":4,"rt":$n[0].Single,"sn":"offsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleY","t":4,"rt":$n[0].Single,"sn":"offsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetShearY","t":4,"rt":$n[0].Single,"sn":"offsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"relative","t":4,"rt":$n[0].Boolean,"sn":"relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"rotateMix","t":4,"rt":$n[0].Single,"sn":"rotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleMix","t":4,"rt":$n[0].Single,"sn":"scaleMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearMix","t":4,"rt":$n[0].Single,"sn":"shearMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[8].BoneData,"sn":"target"},{"a":4,"n":"translateMix","t":4,"rt":$n[0].Single,"sn":"translateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.TransformConstraintData end.*/

    /*Spine.Triangulator start.*/
    $m("Spine.Triangulator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decompose","t":8,"pi":[{"n":"verticesArray","pt":$n[8].ExposedList$1(System.Single),"ps":0},{"n":"triangles","pt":$n[8].ExposedList$1(System.Int32),"ps":1}],"sn":"Decompose","rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"p":[$n[8].ExposedList$1(System.Single),$n[8].ExposedList$1(System.Int32)]},{"a":1,"n":"IsConcave","is":true,"t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2},{"n":"indices","pt":$n[0].Array.type(System.Int32),"ps":3}],"sn":"IsConcave","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"PositiveArea","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"PositiveArea","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Triangulate","t":8,"pi":[{"n":"verticesArray","pt":$n[8].ExposedList$1(System.Single),"ps":0}],"sn":"Triangulate","rt":$n[8].ExposedList$1(System.Int32),"p":[$n[8].ExposedList$1(System.Single)]},{"a":1,"n":"Winding","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"Winding","rt":$n[0].Int32,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"convexPolygons","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"convexPolygons","ro":true},{"a":1,"n":"convexPolygonsIndices","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"convexPolygonsIndices","ro":true},{"a":1,"n":"indicesArray","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"indicesArray","ro":true},{"a":1,"n":"isConcaveArray","t":4,"rt":$n[8].ExposedList$1(System.Boolean),"sn":"isConcaveArray","ro":true},{"a":1,"n":"polygonIndicesPool","t":4,"rt":$n[8].Pool$1(Spine.ExposedList$1(System.Int32)),"sn":"polygonIndicesPool","ro":true},{"a":1,"n":"polygonPool","t":4,"rt":$n[8].Pool$1(Spine.ExposedList$1(System.Single)),"sn":"polygonPool","ro":true},{"a":1,"n":"triangles","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"triangles","ro":true}]}; }, $n);
    /*Spine.Triangulator end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].Bone],"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[8].BoneData],"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[8].BoneMatrix,"p":[$n[8].BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0},{"n":"parentMatrix","pt":$n[8].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[8].BoneMatrix,"p":[$n[8].BoneData,$n[8].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[8].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[8].BoneMatrix,"p":[$n[8].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AllowImmediateQueue","is":true,"t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"AllowImmediateQueue","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":$n[8].TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[$n[8].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":$n[8].TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[$n[8].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[$n[8].Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":$n[8].VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[$n[8].VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetAttachmentToSetupPose","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0}],"sn":"SetAttachmentToSetupPose","rt":$n[0].Void,"p":[$n[8].Slot]},{"a":2,"n":"SetColorToSetupPose","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0}],"sn":"SetColorToSetupPose","rt":$n[0].Void,"p":[$n[8].Slot]},{"a":2,"n":"SetDrawOrderToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"SetDrawOrderToSetupPose","rt":$n[0].Void,"p":[$n[8].Skeleton]},{"a":2,"n":"SetKeyedItemsToSetupPose","is":true,"t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"SetKeyedItemsToSetupPose","rt":$n[0].Void,"p":[$n[8].Animation,$n[8].Skeleton]},{"a":4,"n":"SetPropertyToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"propertyID","pt":$n[0].Int32,"ps":1}],"sn":"SetPropertyToSetupPose","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Int32]},{"a":2,"n":"SetSlotAttachmentToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1}],"sn":"SetSlotAttachmentToSetupPose","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Int32]},{"a":2,"n":"SetSlotAttachmentsToSetupPose","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"SetSlotAttachmentsToSetupPose","rt":$n[0].Void,"p":[$n[8].Skeleton]}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[11].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[8].Animation,"p":[$n[11].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[8].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[8].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[11].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[11].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[8].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"sn":"GetAtlas","rt":$n[8].Atlas},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[11].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[8].AtlasRegion,"p":[$n[8].AtlasRegion,$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[11].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[11].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[8].EventData,"p":[$n[11].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":$n[8].EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":$n[8].EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":$n[8].EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[8].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[8].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[8].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[11].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[11].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[11].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[11].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"sn":"FillStateData","rt":$n[0].Void},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":$n[8].AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[8].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[8].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[0].String,$n[8].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[11].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[8].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":$n[8].AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[11].SkeletonDataCompatibility.SourceType,$n[11].SkeletonDataCompatibility.VersionInfo,$n[11].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[11].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[11].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[11].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[11].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[11].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[11].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[11].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[11].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[11].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$2","rt":$n[11].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"sn":"GetAtlas","rt":$n[8].Atlas},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[8].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[11].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[11].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[8].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[8].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[11].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[11].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[11].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[11].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[11].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[11].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[11].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale. BoneFollower cannot inherit world/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[11].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[11].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[11].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[11].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[11].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[11].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[11].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale. BoneFollower cannot inherit world/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[11].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[11].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[11].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[11].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[8].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[8].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[8].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[8].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[8].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[8].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[11].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[11].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[8].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[8].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[8].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[8].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[8].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[11].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[8].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[11].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[11].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[11].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[11].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[11].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[11].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[8].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[11].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[8].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[11].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[11].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[11].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[8].TrackEntry,"ps":1},{"n":"track","pt":$n[8].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[1].Vector2,$n[8].TrackEntry,$n[8].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[11].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[8].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[$n[11].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":1}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[1].Vector2]},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[8].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[8].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[8].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[11].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[8].Animation,$n[0].Single]},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[11].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"timeline","pt":$n[8].TranslateTimeline,"ps":2},{"n":"animation","pt":$n[8].Animation,"ps":3}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[8].TranslateTimeline,$n[8].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[11].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[11].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":1}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector2,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[8].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[11].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"topLevelBones","t":4,"rt":$n[2].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[11].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[11].SkeletonAnimation,"p":[$n[1].GameObject,$n[11].SkeletonDataAsset,$n[0].Boolean]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[11].SkeletonAnimation,"p":[$n[11].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[11].SkeletonGraphic,"p":[$n[1].GameObject,$n[11].SkeletonDataAsset,$n[1].Material]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[11].SkeletonGraphic,"p":[$n[11].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[4].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[4].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":3,"n":"SyncRawImagesWithCanvasRenderers","t":8,"sn":"SyncRawImagesWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateMesh","t":8,"pi":[{"n":"keepRendererCount","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"UpdateMesh","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"keepRendererCount","pt":$n[0].Boolean,"ps":1}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction,$n[0].Boolean]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[11].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[11].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[2].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[2].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[8].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[8].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[11].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[11].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[11].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[11].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[11].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[2].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[11].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":1,"n":"meshBuffers","t":4,"rt":$n[11].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[11].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshes","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"a":3,"n":"rawImages","t":4,"rt":$n[2].List$1(UnityEngine.UI.RawImage),"sn":"rawImages"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[11].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[11].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[11].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[11].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[11].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[11].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[11].SkeletonMecanim,"nested":[Function,$n[11].SkeletonMecanim.MecanimTranslator.MixMode,$n[11].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[11].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[11].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"reversed","pt":$n[0].Boolean,"ps":2}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[8].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[8].MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[8].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[8].MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[2].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[8].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[11].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,$n[8].MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[11].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[8].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[8].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[2].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[2].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(Spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[2].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[11].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[11].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[11].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[11].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[11].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[11].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[11].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[11].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshFilter, UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[11].SkeletonDataAsset,$n[0].Boolean]},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[12].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[12].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[11].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[11].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[11].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[11].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[11].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[11].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[11].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[11].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[12].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[12].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[12].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[11].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskMaterials","t":4,"rt":$n[11].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[11].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[11].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[11].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[11].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[11].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[11].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[11].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[11].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[11].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[11].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[11].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[11].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[11].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[11].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[11].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[11].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[11].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[11].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[11].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[11].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[11].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[11].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[11].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[11].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[11].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[11].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[11].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[11].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[11].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[11].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[11].SkeletonRenderSeparator,"p":[$n[11].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[11].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[11].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[11].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[11].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[11].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[11].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    $m("Spine.Unity.FollowLocationRigidbody", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    $m("Spine.Unity.FollowLocationRigidbody2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"followFlippedX","t":4,"rt":$n[0].Boolean,"sn":"followFlippedX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody2D,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    $m("Spine.Unity.FollowSkeletonUtilityRootRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensatePositionToXRotation","t":8,"sn":"CompensatePositionToXRotation","rt":$n[0].Void},{"a":1,"n":"CompensatePositionToYRotation","t":8,"sn":"CompensatePositionToYRotation","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"FLIP_ANGLE_THRESHOLD","is":true,"t":4,"rt":$n[0].Single,"sn":"FLIP_ANGLE_THRESHOLD","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevLocalEulerAngles","t":4,"rt":$n[1].Vector3,"sn":"prevLocalEulerAngles"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[$n[8].BoundingBoxAttachment,$n[8].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[8].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,$n[8].BoundingBoxAttachment,$n[8].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[8].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":$n[8].BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[$n[8].BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[11].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[11].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[11].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[11].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[11].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[11].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[8].Slot,$n[8].BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[11].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[8].Bone,$n[1].Transform,$n[11].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[11].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[8].Bone,$n[1].Transform,$n[11].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[11].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[11].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[11].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[11].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[11].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[11].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[11].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[11].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[11].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[11].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[11].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[11].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[11].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[11].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[11].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[11].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[11].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[11].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[11].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[11].SkeletonUtilityBone.Mode,$n[11].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[8].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[11].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[11].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[11].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[11].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[11].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[11].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[11].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[11].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[11].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[11].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[11].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[11].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[11].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[11].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[11].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[11].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[11].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[11].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[8].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[11].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[11].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[11].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[11].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[8].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[11].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[8].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[11].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[11].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[11].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[11].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[11].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[11].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[11].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[11].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[11].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[11].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[8].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[8].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[8].MeshAttachment,$n[8].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction,$n[8].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[2].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction,$n[8].Skeleton,$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[2].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[11].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[11].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[8].SkeletonClipping,"sn":"clipper"},{"a":1,"n":"colorBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[11].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"submeshes","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":1,"n":"uvBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":1,"n":"vertexBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[11].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[11].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[11].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[11].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[11].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[11].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[11].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[11].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[11].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[11].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[11].SkeletonRendererInstruction,$n[11].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[11].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[11].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[8].ExposedList$1(Spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[11].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[8].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[11].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[8].AtlasRegion,"p":[$n[8].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[8].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[8].AtlasPage,"p":[$n[8].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[2].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[11].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[8].Bone,"p":[$n[0].String,$n[11].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":$n[8].BoneData,"p":[$n[0].String,$n[11].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[11].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1}],"sn":"getAttachment","rt":$n[8].Attachment,"p":[$n[0].String,$n[8].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[11].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":$n[8].Attachment,"p":[$n[0].String,$n[11].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[11].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[11].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[8].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[8].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[8].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[8].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[8].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[8].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[8].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[8].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":$n[8].VertexAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[8].VertexAttachment,$n[8].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[$n[8].Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[8].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[8].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[8].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[8].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[8].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].PointAttachment,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[8].PointAttachment,$n[8].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].PointAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[8].PointAttachment,$n[8].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].VertexAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[8].VertexAttachment,$n[8].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[8].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[8].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[8].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[8].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[8].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[11].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry,$n[11].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[11].WaitForSpineAnimation,"p":[$n[8].TrackEntry,$n[11].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[11].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[11].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[11].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[11].WaitForSpineAnimationComplete,"p":[$n[8].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[11].WaitForSpineAnimationEnd,"p":[$n[8].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[11].SkeletonAnimation,$n[8].EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[11].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[11].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[11].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[11].WaitForSpineEvent,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[11].WaitForSpineEvent,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[8].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":$n[8].EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[11].WaitForSpineTrackEntryEnd,"p":[$n[8].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[8].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[1].Vector2,"p":[$n[8].TranslateTimeline,$n[0].Single,$n[8].SkeletonData]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":$n[8].TranslateTimeline,"p":[$n[8].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.SkinUtilities start.*/
    $m("Spine.Unity.AttachmentTools.SkinUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddAttachments","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"otherSkin","pt":$n[8].Skin,"ps":1}],"sn":"AddAttachments","rt":$n[0].Void,"p":[$n[8].Skin,$n[8].Skin]},{"a":2,"n":"Append","is":true,"t":8,"pi":[{"n":"destination","pt":$n[8].Skin,"ps":0},{"n":"source","pt":$n[8].Skin,"ps":1}],"sn":"Append","rt":$n[0].Void,"p":[$n[8].Skin,$n[8].Skin]},{"a":2,"n":"Clear","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":2,"n":"CopyTo","is":true,"t":8,"pi":[{"n":"source","pt":$n[8].Skin,"ps":0},{"n":"destination","pt":$n[8].Skin,"ps":1},{"n":"overwrite","pt":$n[0].Boolean,"ps":2},{"n":"cloneAttachments","pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshesAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"CopyTo","rt":$n[0].Void,"p":[$n[8].Skin,$n[8].Skin,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"skeleton","pt":$n[8].Skeleton,"ps":3}],"sn":"GetAttachment","rt":$n[8].Attachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Skeleton]},{"a":2,"n":"GetClone","is":true,"t":8,"pi":[{"n":"original","pt":$n[8].Skin,"ps":0}],"sn":"GetClone","rt":$n[8].Skin,"p":[$n[8].Skin]},{"a":2,"n":"GetClonedSkin","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"newSkinName","pt":$n[0].String,"ps":1},{"n":"includeDefaultSkin","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"cloneAttachments","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshesAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClonedSkin","rt":$n[8].Skin,"p":[$n[8].Skeleton,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"RemoveAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":3}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].SkeletonData]},{"a":2,"n":"SetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"attachment","pt":$n[8].Attachment,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,$n[0].String,$n[8].Attachment]},{"a":2,"n":"SetAttachment","is":true,"t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"keyName","pt":$n[0].String,"ps":2},{"n":"attachment","pt":$n[8].Attachment,"ps":3},{"n":"skeleton","pt":$n[8].Skeleton,"ps":4}],"sn":"SetAttachment$1","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Attachment,$n[8].Skeleton]},{"a":2,"n":"UnshareSkin","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"includeDefaultSkin","pt":$n[0].Boolean,"ps":1},{"n":"unshareAttachments","pt":$n[0].Boolean,"ps":2},{"n":"state","dv":null,"o":true,"pt":$n[8].AnimationState,"ps":3}],"sn":"UnshareSkin","rt":$n[8].Skin,"p":[$n[8].Skeleton,$n[0].Boolean,$n[0].Boolean,$n[8].AnimationState]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.SkinUtilities end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes", function () { return {"nested":[$n[13].SlotBlendModes.MaterialTexturePair,$n[13].SlotBlendModes.MaterialWithRefcount,$n[13].SlotBlendModes.SlotMaterialTextureTuple],"att":1048577,"a":2,"at":[new UnityEngine.DisallowMultipleComponent()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":4,"n":"GetExistingMaterialFor","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"GetExistingMaterialFor","rt":$n[13].SlotBlendModes.MaterialWithRefcount,"p":[$n[1].Material,$n[1].Texture2D]},{"a":4,"n":"GetOrAddMaterialFor","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"GetOrAddMaterialFor","rt":$n[1].Material,"p":[$n[1].Material,$n[1].Texture2D]},{"a":2,"n":"GetTexture","t":8,"sn":"GetTexture","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"Remove","t":8,"sn":"Remove","rt":$n[0].Void},{"a":4,"n":"RemoveMaterialFromTable","is":true,"t":8,"pi":[{"n":"materialSource","pt":$n[1].Material,"ps":0},{"n":"texture","pt":$n[1].Texture2D,"ps":1}],"sn":"RemoveMaterialFromTable","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Texture2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Applied","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Applied","t":8,"rt":$n[0].Boolean,"fg":"Applied","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_Applied","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Applied"},"fn":"Applied"},{"a":4,"n":"MaterialTable","is":true,"t":16,"rt":$n[2].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"g":{"a":4,"n":"get_MaterialTable","t":8,"rt":$n[2].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"fg":"MaterialTable","is":true},"fn":"MaterialTable"},{"a":1,"n":"materialTable","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair,Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount),"sn":"materialTable"},{"a":2,"n":"multiplyMaterialSource","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialSource"},{"a":2,"n":"screenMaterialSource","t":4,"rt":$n[1].Material,"sn":"screenMaterialSource"},{"a":1,"n":"slotsWithCustomMaterial","t":4,"rt":System.Array.type(Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple),"sn":"slotsWithCustomMaterial"},{"a":1,"n":"texture","t":4,"rt":$n[1].Texture2D,"sn":"texture"},{"a":1,"backing":true,"n":"<Applied>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Applied","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.MaterialTexturePair", function () { return {"td":$n[13].SlotBlendModes,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"texture2D","t":4,"rt":$n[1].Texture2D,"sn":"texture2D"}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialTexturePair end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.MaterialWithRefcount", function () { return {"td":$n[13].SlotBlendModes,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].Material],"pi":[{"n":"mat","pt":$n[1].Material,"ps":0}],"sn":"ctor"},{"a":2,"n":"materialClone","t":4,"rt":$n[1].Material,"sn":"materialClone"},{"a":2,"n":"refcount","t":4,"rt":$n[0].Int32,"sn":"refcount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+MaterialWithRefcount end.*/

    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple start.*/
    $m("Spine.Unity.Deprecated.SlotBlendModes.SlotMaterialTextureTuple", function () { return {"td":$n[13].SlotBlendModes,"att":1048845,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].Slot,$n[1].Material,$n[1].Texture2D],"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"texture","pt":$n[1].Texture2D,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"slot","t":4,"rt":$n[8].Slot,"sn":"slot"},{"a":2,"n":"texture2D","t":4,"rt":$n[1].Texture2D,"sn":"texture2D"}]}; }, $n);
    /*Spine.Unity.Deprecated.SlotBlendModes+SlotMaterialTextureTuple end.*/

    /*Spine.Collections.OrderedDictionary$2 start.*/
    $m("Spine.Collections.OrderedDictionary$2", function (TKey, TValue) { return {"nested":[$n[10].OrderedDictionary$2.KeyCollection,$n[10].OrderedDictionary$2.ValueCollection],"att":1048833,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[2].IEqualityComparer$1(TKey)],"pi":[{"n":"comparer","pt":$n[2].IEqualityComparer$1(TKey),"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[2].IEqualityComparer$1(TKey)],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0},{"n":"comparer","pt":$n[2].IEqualityComparer$1(TKey),"ps":1}],"sn":"$ctor3"},{"a":2,"n":"Add","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"add","rt":$n[0].Void,"p":[TKey,TValue]},{"a":2,"n":"Clear","t":8,"sn":"clear","rt":$n[0].Void},{"a":2,"n":"ContainsKey","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"containsKey","rt":$n[0].Boolean,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))},{"a":2,"n":"GetKey","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetKey","rt":TKey,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"key","pt":TKey,"ps":1},{"n":"value","pt":TValue,"ps":2}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,TKey,TValue]},{"a":2,"n":"Remove","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"remove","rt":$n[0].Boolean,"p":[TKey],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"removeAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"TryGetValue","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","out":true,"pt":TValue,"ps":1}],"sn":"tryGetValue","rt":$n[0].Boolean,"p":[TKey,TValue],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Comparer","t":16,"rt":$n[2].IEqualityComparer$1(TKey),"g":{"a":2,"n":"get_Comparer","t":8,"rt":$n[2].IEqualityComparer$1(TKey),"fg":"Comparer"},"fn":"Comparer"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Item","t":16,"rt":TValue,"p":[$n[0].Int32],"i":true,"ipi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"g":{"a":2,"n":"get_Item","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"getItem$1","rt":TValue,"p":[$n[0].Int32]},"s":{"a":2,"n":"set_Item","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"setItem$1","rt":$n[0].Void,"p":[$n[0].Int32,TValue]}},{"a":2,"n":"Item","t":16,"rt":TValue,"p":[TKey],"i":true,"ipi":[{"n":"key","pt":TKey,"ps":0}],"g":{"a":2,"n":"get_Item","t":8,"pi":[{"n":"key","pt":TKey,"ps":0}],"sn":"getItem","rt":TValue,"p":[TKey]},"s":{"a":2,"n":"set_Item","t":8,"pi":[{"n":"key","pt":TKey,"ps":0},{"n":"value","pt":TValue,"ps":1}],"sn":"setItem","rt":$n[0].Void,"p":[TKey,TValue]}},{"a":2,"n":"Keys","t":16,"rt":$n[10].OrderedDictionary$2.KeyCollection(TKey,TValue),"g":{"a":2,"n":"get_Keys","t":8,"rt":$n[10].OrderedDictionary$2.KeyCollection(TKey,TValue),"fg":"Keys"},"fn":"Keys"},{"a":2,"n":"Values","t":16,"rt":$n[10].OrderedDictionary$2.ValueCollection(TKey,TValue),"g":{"a":2,"n":"get_Values","t":8,"rt":$n[10].OrderedDictionary$2.ValueCollection(TKey,TValue),"fg":"Values"},"fn":"Values"},{"a":1,"n":"CollectionModifiedMessage","is":true,"t":4,"rt":$n[0].String,"sn":"CollectionModifiedMessage"},{"a":1,"n":"EditReadOnlyListMessage","is":true,"t":4,"rt":$n[0].String,"sn":"EditReadOnlyListMessage"},{"a":1,"n":"IndexOutOfRangeMessage","is":true,"t":4,"rt":$n[0].String,"sn":"IndexOutOfRangeMessage"},{"a":1,"n":"dictionary","t":4,"rt":$n[2].Dictionary$2(TKey,System.Int32),"sn":"dictionary","ro":true},{"a":1,"n":"keys","t":4,"rt":$n[2].List$1(TKey),"sn":"keys","ro":true},{"a":1,"n":"values","t":4,"rt":$n[2].List$1(TValue),"sn":"values","ro":true},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2 end.*/

    /*Spine.Collections.OrderedDictionary$2+KeyCollection start.*/
    $m("Spine.Collections.OrderedDictionary$2.KeyCollection", function (TKey, TValue) { return {"td":$n[10].OrderedDictionary$2(TKey,TValue),"att":1048834,"a":2,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[2].Dictionary$2(TKey,System.Int32)],"pi":[{"n":"dictionary","pt":$n[2].Dictionary$2(TKey,System.Int32),"ps":0}],"sn":"ctor"},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(TKey),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"copyTo","rt":$n[0].Void,"p":[System.Array.type(TKey),$n[0].Int32]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(TKey)},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":1,"n":"dictionary","t":4,"rt":$n[2].Dictionary$2(TKey,System.Int32),"sn":"dictionary","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2+KeyCollection end.*/

    /*Spine.Collections.OrderedDictionary$2+ValueCollection start.*/
    $m("Spine.Collections.OrderedDictionary$2.ValueCollection", function (TKey, TValue) { return {"td":$n[10].OrderedDictionary$2(TKey,TValue),"att":1048834,"a":2,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[2].List$1(TValue)],"pi":[{"n":"values","pt":$n[2].List$1(TValue),"ps":0}],"sn":"ctor"},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(TValue),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"copyTo","rt":$n[0].Void,"p":[System.Array.type(TValue),$n[0].Int32]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(TValue)},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":1,"n":"values","t":4,"rt":$n[2].List$1(TValue),"sn":"values","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionary$2+ValueCollection end.*/

    /*Spine.Collections.OrderedDictionaryDebugView$2 start.*/
    $m("Spine.Collections.OrderedDictionaryDebugView$2", function (TKey, TValue) { return {"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[10].OrderedDictionary$2(TKey,TValue)],"pi":[{"n":"dictionary","pt":$n[10].OrderedDictionary$2(TKey,TValue),"ps":0}],"sn":"ctor"},{"a":2,"n":"Items","t":16,"rt":System.Array.type(System.Collections.Generic.KeyValuePair$2(TKey,TValue)),"g":{"a":2,"n":"get_Items","t":8,"rt":System.Array.type(System.Collections.Generic.KeyValuePair$2(TKey,TValue)),"fg":"Items"},"fn":"Items"},{"a":1,"n":"dictionary","t":4,"rt":$n[10].OrderedDictionary$2(TKey,TValue),"sn":"dictionary","ro":true}]}; }, $n);
    /*Spine.Collections.OrderedDictionaryDebugView$2 end.*/

    /*Spine.Collections.CollectionExtensions start.*/
    $m("Spine.Collections.CollectionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ToOrderedDictionary","is":true,"t":8,"pi":[{"n":"source","pt":$n[2].IEnumerable$1(System.Object),"ps":0},{"n":"keySelector","pt":Function,"ps":1}],"tpc":2,"tprm":["TSource","TKey"],"sn":"ToOrderedDictionary","rt":$n[10].OrderedDictionary$2(System.Object,System.Object),"p":[$n[2].IEnumerable$1(System.Object),Function]},{"a":2,"n":"ToOrderedDictionary","is":true,"t":8,"pi":[{"n":"source","pt":$n[2].IEnumerable$1(System.Object),"ps":0},{"n":"keySelector","pt":Function,"ps":1},{"n":"comparer","pt":$n[2].IEqualityComparer$1(System.Object),"ps":2}],"tpc":2,"tprm":["TSource","TKey"],"sn":"ToOrderedDictionary$1","rt":$n[10].OrderedDictionary$2(System.Object,System.Object),"p":[$n[2].IEnumerable$1(System.Object),Function,$n[2].IEqualityComparer$1(System.Object)]}]}; }, $n);
    /*Spine.Collections.CollectionExtensions end.*/

    /*Projects.Scripts.UIController.ButtonEffect start.*/
    $m("Projects.Scripts.UIController.ButtonEffect", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Button)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerEnter","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerEnter","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerExit","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerExit","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerUp","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"_button","t":4,"rt":$n[4].Button,"sn":"_button"},{"a":1,"n":"_isEnter","t":4,"rt":$n[0].Boolean,"sn":"_isEnter","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Projects.Scripts.UIController.ButtonEffect end.*/

    /*Projects.Scripts.UIController.CoinValueText start.*/
    $m("Projects.Scripts.UIController.CoinValueText", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","t":8,"sn":"Complete","rt":$n[0].Void},{"a":2,"n":"SetValue","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"SetValue","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"coinValueText","t":4,"rt":$n[14].TextMeshProUGUI,"sn":"coinValueText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"curve","t":4,"rt":pc.AnimationCurve,"sn":"curve"}]}; }, $n);
    /*Projects.Scripts.UIController.CoinValueText end.*/

    /*Projects.Scripts.UIController.GamePlayController start.*/
    $m("Projects.Scripts.UIController.GamePlayController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ActiveWarning","t":8,"pi":[{"n":"complete","dv":null,"o":true,"pt":Function,"ps":0}],"sn":"ActiveWarning","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"BallDamaged","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"BallDamaged","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"BallDie","t":8,"sn":"BallDie","rt":$n[0].Void},{"a":2,"n":"CollectCoin","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"coinTransform","pt":$n[1].Transform,"ps":1}],"sn":"CollectCoin","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Transform]},{"a":2,"n":"CollectHp","t":8,"pi":[{"n":"hpTransform","pt":$n[1].Transform,"ps":0}],"sn":"CollectHp","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":2,"n":"CollectLife","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"CollectLife","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Transform]},{"a":2,"n":"CollectMagnet","t":8,"pi":[{"n":"magnetItem","pt":$n[1].Transform,"ps":0}],"sn":"CollectMagnet","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":2,"n":"CollectStar","t":8,"pi":[{"n":"starTransform","pt":$n[1].Transform,"ps":0}],"sn":"CollectStar","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":1,"n":"ExitRoom","t":8,"sn":"ExitRoom","rt":$n[0].Void},{"a":2,"n":"GoToStore","t":8,"sn":"GoToStore","rt":$n[0].Void},{"a":2,"n":"IsMagnetActive","t":8,"sn":"IsMagnetActive","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"PauseWhenBallDie","t":8,"sn":"PauseWhenBallDie","rt":$n[0].Void},{"a":2,"n":"SetBossHealth","t":8,"pi":[{"n":"percent","pt":$n[0].Single,"ps":0}],"sn":"SetBossHealth","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetBossSkin","t":8,"pi":[{"n":"asset","pt":$n[11].SkeletonDataAsset,"ps":0}],"sn":"SetBossSkin","rt":$n[0].Void,"p":[$n[11].SkeletonDataAsset]},{"a":2,"n":"SetCheckPoint","t":8,"pi":[{"n":"checkPoint","pt":$n[15].CheckPoint,"ps":0},{"n":"playSound","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetCheckPoint","rt":$n[0].Void,"p":[$n[15].CheckPoint,$n[0].Boolean]},{"a":2,"n":"SetCollectedCurrency","t":8,"sn":"SetCollectedCurrency","rt":$n[0].Void},{"a":2,"n":"SetCollectingCurrency","t":8,"sn":"SetCollectingCurrency","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skin","pt":$n[0].String,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[0].String]},{"a":1,"n":"ShowContinue","t":8,"sn":"ShowContinue","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"StartGame","t":8,"sn":"StartGame","rt":$n[0].Void},{"a":2,"n":"TouchJump","t":8,"pi":[{"n":"release","pt":$n[0].Boolean,"ps":0}],"sn":"TouchJump","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"TouchMoveLeft","t":8,"pi":[{"n":"release","pt":$n[0].Boolean,"ps":0}],"sn":"TouchMoveLeft","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"TouchMoveRight","t":8,"pi":[{"n":"release","pt":$n[0].Boolean,"ps":0}],"sn":"TouchMoveRight","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Win","t":8,"sn":"Win","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[16].GamePlayController,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[16].GamePlayController,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_instance","is":true,"t":4,"rt":$n[16].GamePlayController,"sn":"_instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"ball","t":4,"rt":$n[17].BallController,"sn":"ball"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballUI","t":4,"rt":$n[11].SkeletonGraphic,"sn":"ballUI"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bossGroup","t":4,"rt":$n[1].GameObject,"sn":"bossGroup"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bossHp","t":4,"rt":$n[4].Image,"sn":"bossHp"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bossSkeleton","t":4,"rt":$n[11].SkeletonGraphic,"sn":"bossSkeleton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bossWarning","t":4,"rt":$n[1].CanvasGroup,"sn":"bossWarning"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"coinValuePrefab","t":4,"rt":$n[16].CoinValueText,"sn":"coinValuePrefab"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentCheckPoint","t":4,"rt":$n[15].CheckPoint,"sn":"currentCheckPoint"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentHp","t":4,"rt":$n[0].Int32,"sn":"currentHp","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"gameState","t":4,"rt":$n[18].GameState,"sn":"gameState","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.GameState, System.Enum.toStringFn(Projects.Scripts.Models.GameState));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"hpList","t":4,"rt":System.Array.type(UnityEngine.Transform),"sn":"hpList"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"hpPrefabs","t":4,"rt":$n[1].GameObject,"sn":"hpPrefabs"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"level","t":4,"rt":$n[0].Int32,"sn":"level","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"lifeIcon","t":4,"rt":$n[1].Transform,"sn":"lifeIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"lifeText","t":4,"rt":$n[14].TextMeshProUGUI,"sn":"lifeText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"magnetActive","t":4,"rt":$n[0].Boolean,"sn":"magnetActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"magnetIcon","t":4,"rt":$n[1].GameObject,"sn":"magnetIcon"},{"a":2,"n":"onRevive","t":4,"rt":Function,"sn":"onRevive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pauseButton","t":4,"rt":$n[4].Button,"sn":"pauseButton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"starList","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"starList"},{"a":2,"n":"tapToContinue","t":4,"rt":$n[4].Image,"sn":"tapToContinue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"totalCoin","t":4,"rt":$n[0].Int32,"sn":"totalCoin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"totalStars","t":4,"rt":$n[0].Int32,"sn":"totalStars","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Projects.Scripts.UIController.GamePlayController end.*/

    /*Projects.Scripts.UIController.CustomButton start.*/
    $m("Projects.Scripts.UIController.CustomButton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerEnter","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerEnter","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":2,"n":"OnPointerExit","t":8,"pi":[{"n":"eventData","pt":$n[3].PointerEventData,"ps":0}],"sn":"OnPointerExit","rt":$n[0].Void,"p":[$n[3].PointerEventData]},{"a":1,"n":"_isEnter","t":4,"rt":$n[0].Boolean,"sn":"_isEnter","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"interactive","t":4,"rt":$n[0].Boolean,"sn":"interactive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"onClick","t":4,"rt":$n[19].UnityEvent,"sn":"onClick"},{"a":2,"n":"onEnter","t":4,"rt":$n[19].UnityEvent,"sn":"onEnter"},{"a":2,"n":"onExit","t":4,"rt":$n[19].UnityEvent,"sn":"onExit"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetGraphic","t":4,"rt":$n[1].Transform,"sn":"targetGraphic"}]}; }, $n);
    /*Projects.Scripts.UIController.CustomButton end.*/

    /*Projects.Scripts.UIController.ToggleHelper start.*/
    $m("Projects.Scripts.UIController.ToggleHelper", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Toggle)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"a":3,"n":"OnValueChange","t":8,"pi":[{"n":"value","pt":$n[0].Boolean,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"OnValueChange","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Single]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"_toggle","t":4,"rt":$n[4].Toggle,"sn":"_toggle"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"offObjects","t":4,"rt":System.Array.type(UnityEngine.UI.Graphic),"sn":"offObjects"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onObjects","t":4,"rt":System.Array.type(UnityEngine.UI.Graphic),"sn":"onObjects"}]}; }, $n);
    /*Projects.Scripts.UIController.ToggleHelper end.*/

    /*Projects.Scripts.Models.DamageType start.*/
    $m("Projects.Scripts.Models.DamageType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Enemy","is":true,"t":4,"rt":$n[18].DamageType,"sn":"Enemy","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.DamageType, System.Enum.toStringFn(Projects.Scripts.Models.DamageType));}},{"a":2,"n":"Fire","is":true,"t":4,"rt":$n[18].DamageType,"sn":"Fire","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.DamageType, System.Enum.toStringFn(Projects.Scripts.Models.DamageType));}},{"a":2,"n":"Object","is":true,"t":4,"rt":$n[18].DamageType,"sn":"Object","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.DamageType, System.Enum.toStringFn(Projects.Scripts.Models.DamageType));}},{"a":2,"n":"Water","is":true,"t":4,"rt":$n[18].DamageType,"sn":"Water","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.DamageType, System.Enum.toStringFn(Projects.Scripts.Models.DamageType));}}]}; }, $n);
    /*Projects.Scripts.Models.DamageType end.*/

    /*Projects.Scripts.Models.GameState start.*/
    $m("Projects.Scripts.Models.GameState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"End","is":true,"t":4,"rt":$n[18].GameState,"sn":"End","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.GameState, System.Enum.toStringFn(Projects.Scripts.Models.GameState));}},{"a":2,"n":"Pause","is":true,"t":4,"rt":$n[18].GameState,"sn":"Pause","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.GameState, System.Enum.toStringFn(Projects.Scripts.Models.GameState));}},{"a":2,"n":"Playing","is":true,"t":4,"rt":$n[18].GameState,"sn":"Playing","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.GameState, System.Enum.toStringFn(Projects.Scripts.Models.GameState));}},{"a":2,"n":"Prepare","is":true,"t":4,"rt":$n[18].GameState,"sn":"Prepare","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.GameState, System.Enum.toStringFn(Projects.Scripts.Models.GameState));}}]}; }, $n);
    /*Projects.Scripts.Models.GameState end.*/

    /*Projects.Scripts.Models.ItemType start.*/
    $m("Projects.Scripts.Models.ItemType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Coin","is":true,"t":4,"rt":$n[18].ItemType,"sn":"Coin","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.ItemType, System.Enum.toStringFn(Projects.Scripts.Models.ItemType));}},{"a":2,"n":"Heart","is":true,"t":4,"rt":$n[18].ItemType,"sn":"Heart","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.ItemType, System.Enum.toStringFn(Projects.Scripts.Models.ItemType));}},{"a":2,"n":"Skin","is":true,"t":4,"rt":$n[18].ItemType,"sn":"Skin","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.ItemType, System.Enum.toStringFn(Projects.Scripts.Models.ItemType));}}]}; }, $n);
    /*Projects.Scripts.Models.ItemType end.*/

    /*Projects.Scripts.Models.MoveDirection start.*/
    $m("Projects.Scripts.Models.MoveDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Left","is":true,"t":4,"rt":$n[18].MoveDirection,"sn":"Left","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[18].MoveDirection,"sn":"None","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}},{"a":2,"n":"Right","is":true,"t":4,"rt":$n[18].MoveDirection,"sn":"Right","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}}]}; }, $n);
    /*Projects.Scripts.Models.MoveDirection end.*/

    /*Projects.Scripts.GamePlay.ObjectCollision start.*/
    $m("Projects.Scripts.GamePlay.ObjectCollision", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnCollisionExit2D","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionExit2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnCollisionStay2D","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionStay2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collisionEnter2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collision2D),"sn":"collisionEnter2DEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collisionExit2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collision2D),"sn":"collisionExit2DEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collisionStay2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collision2D),"sn":"collisionStay2DEvent"}]}; }, $n);
    /*Projects.Scripts.GamePlay.ObjectCollision end.*/

    /*Projects.Scripts.GamePlay.ObjectTrigger start.*/
    $m("Projects.Scripts.GamePlay.ObjectTrigger", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnTriggerExit2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerExit2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnTriggerStay2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerStay2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"triggerEnter2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collider2D),"sn":"triggerEnter2DEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"triggerExit2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collider2D),"sn":"triggerExit2DEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"triggerStay2DEvent","t":4,"rt":$n[19].UnityEvent$1(UnityEngine.Collider2D),"sn":"triggerStay2DEvent"}]}; }, $n);
    /*Projects.Scripts.GamePlay.ObjectTrigger end.*/

    /*Projects.Scripts.GamePlay.ParticleCallback start.*/
    $m("Projects.Scripts.GamePlay.ParticleCallback", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnParticleSystemStopped","t":8,"sn":"OnParticleSystemStopped","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"completeEvent","t":4,"rt":$n[19].UnityEvent,"sn":"completeEvent"}]}; }, $n);
    /*Projects.Scripts.GamePlay.ParticleCallback end.*/

    /*Projects.Scripts.GamePlay.Sound.SoundInGameManager start.*/
    $m("Projects.Scripts.GamePlay.Sound.SoundInGameManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"PlayBallAttackSound","t":8,"sn":"PlayBallAttackSound","rt":$n[0].Void},{"a":2,"n":"PlayBallCollectCoin","t":8,"sn":"PlayBallCollectCoin","rt":$n[0].Void},{"a":2,"n":"PlayBallCollectHeart","t":8,"sn":"PlayBallCollectHeart","rt":$n[0].Void},{"a":2,"n":"PlayBallCollectMagnet","t":8,"sn":"PlayBallCollectMagnet","rt":$n[0].Void},{"a":2,"n":"PlayBallCollectStar","t":8,"sn":"PlayBallCollectStar","rt":$n[0].Void},{"a":2,"n":"PlayBallDamagedSound","t":8,"sn":"PlayBallDamagedSound","rt":$n[0].Void},{"a":2,"n":"PlayBallDieSound","t":8,"sn":"PlayBallDieSound","rt":$n[0].Void},{"a":2,"n":"PlayBallExplode","t":8,"sn":"PlayBallExplode","rt":$n[0].Void},{"a":2,"n":"PlayBallInCheckPoint","t":8,"sn":"PlayBallInCheckPoint","rt":$n[0].Void},{"a":2,"n":"PlayBallJumpSound","t":8,"sn":"PlayBallJumpSound","rt":$n[0].Void},{"a":2,"n":"PlayBallLandingSound","t":8,"sn":"PlayBallLandingSound","rt":$n[0].Void},{"a":2,"n":"PlayBallRevive","t":8,"sn":"PlayBallRevive","rt":$n[0].Void},{"a":2,"n":"PlayBallTrySkin","t":8,"sn":"PlayBallTrySkin","rt":$n[0].Void},{"a":2,"n":"PlayBallWinSound","t":8,"sn":"PlayBallWinSound","rt":$n[0].Void},{"a":2,"n":"PlayBgmSound","t":8,"sn":"PlayBgmSound","rt":$n[0].Void},{"a":2,"n":"PlayBossFightSound","t":8,"sn":"PlayBossFightSound","rt":$n[0].Void},{"a":2,"n":"PlayCageBreakSound","t":8,"sn":"PlayCageBreakSound","rt":$n[0].Void},{"a":2,"n":"PlayLoseSound","t":8,"pi":[{"n":"complete","pt":Function,"ps":0}],"sn":"PlayLoseSound","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"PlayRescueSound","t":8,"sn":"PlayRescueSound","rt":$n[0].Void},{"a":2,"n":"PlaySpringSound","t":8,"sn":"PlaySpringSound","rt":$n[0].Void},{"a":2,"n":"PlayWinSound","t":8,"pi":[{"n":"complete","pt":Function,"ps":0}],"sn":"PlayWinSound","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[20].SoundInGameManager,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[20].SoundInGameManager,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_instance","is":true,"t":4,"rt":$n[20].SoundInGameManager,"sn":"_instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballAttack","t":4,"rt":$n[1].AudioClip,"sn":"ballAttack"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballCollectCoin","t":4,"rt":$n[1].AudioClip,"sn":"ballCollectCoin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballCollectHeart","t":4,"rt":$n[1].AudioClip,"sn":"ballCollectHeart"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballCollectMagnet","t":4,"rt":$n[1].AudioClip,"sn":"ballCollectMagnet"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballCollectStar","t":4,"rt":$n[1].AudioClip,"sn":"ballCollectStar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballDie","t":4,"rt":$n[1].AudioClip,"sn":"ballDie"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballExplode","t":4,"rt":$n[1].AudioClip,"sn":"ballExplode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballHurt","t":4,"rt":$n[1].AudioClip,"sn":"ballHurt"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballInCheckPoint","t":4,"rt":$n[1].AudioClip,"sn":"ballInCheckPoint"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballLanding","t":4,"rt":$n[1].AudioClip,"sn":"ballLanding"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballRescueSound","t":4,"rt":$n[1].AudioClip,"sn":"ballRescueSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballRevive","t":4,"rt":$n[1].AudioClip,"sn":"ballRevive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballTrySkin","t":4,"rt":$n[1].AudioClip,"sn":"ballTrySkin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballWin","t":4,"rt":$n[1].AudioClip,"sn":"ballWin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bgm","t":4,"rt":System.Array.type(UnityEngine.AudioClip),"sn":"bgm"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bossFight","t":4,"rt":System.Array.type(UnityEngine.AudioClip),"sn":"bossFight"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cageBreakSound","t":4,"rt":$n[1].AudioClip,"sn":"cageBreakSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"jumpClips","t":4,"rt":System.Array.type(UnityEngine.AudioClip),"sn":"jumpClips"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"lose","t":4,"rt":$n[1].AudioClip,"sn":"lose"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundManager","t":4,"rt":$n[6].SoundManager,"sn":"soundManager"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"spring","t":4,"rt":$n[1].AudioClip,"sn":"spring"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"win","t":4,"rt":$n[1].AudioClip,"sn":"win"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Sound.SoundInGameManager end.*/

    /*Projects.Scripts.GamePlay.Platform.Gate start.*/
    $m("Projects.Scripts.GamePlay.Platform.Gate", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"collider2D","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballLayer","t":4,"rt":$n[1].LayerMask,"sn":"ballLayer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gateLight","t":4,"rt":$n[1].GameObject,"sn":"gateLight"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"target","t":4,"rt":$n[1].Transform,"sn":"target"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Platform.Gate end.*/

    /*Projects.Scripts.GamePlay.Item.Cage start.*/
    $m("Projects.Scripts.GamePlay.Item.Cage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"GetAllSkinName","t":8,"sn":"GetAllSkinName","rt":$n[2].List$1(System.String)},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"collider2D","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnValueChange","t":8,"sn":"OnValueChange","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballImprisoned","t":4,"rt":$n[11].SkeletonAnimation,"sn":"ballImprisoned"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"cageBreakAnim","t":4,"rt":$n[0].String,"sn":"cageBreakAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cageSkeleton","t":4,"rt":$n[11].SkeletonAnimation,"sn":"cageSkeleton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"rescueAnimation","t":4,"rt":$n[0].String,"sn":"rescueAnimation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"startAnimation","t":4,"rt":$n[0].String,"sn":"startAnimation"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"triggerLayer","t":4,"rt":$n[1].LayerMask,"sn":"triggerLayer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"trySkinName","t":4,"rt":$n[0].String,"sn":"trySkinName"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.Cage end.*/

    /*Projects.Scripts.GamePlay.Item.Coin start.*/
    $m("Projects.Scripts.GamePlay.Item.Coin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollect","t":8,"sn":"OnCollect","rt":$n[0].Void},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TriggerEnter","t":8,"pi":[{"n":"collider2D","pt":$n[1].Collider2D,"ps":0}],"sn":"TriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effect","t":4,"rt":$n[1].GameObject,"sn":"effect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].GameObject,"sn":"icon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"mask","t":4,"rt":$n[1].LayerMask,"sn":"mask"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.Coin end.*/

    /*Projects.Scripts.GamePlay.Item.HeartItem start.*/
    $m("Projects.Scripts.GamePlay.Item.HeartItem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"coll","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"adsIcon","t":4,"rt":$n[1].GameObject,"sn":"adsIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audio","t":4,"rt":$n[6].SimpleAudio,"sn":"audio"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"container","t":4,"rt":$n[1].GameObject,"sn":"container"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effect","t":4,"rt":$n[1].GameObject,"sn":"effect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].Transform,"sn":"icon"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"idleAnim","t":4,"rt":$n[0].String,"sn":"idleAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"move","t":4,"rt":$n[1].AudioClip,"sn":"move"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"skeleton","t":4,"rt":$n[11].SkeletonAnimation,"sn":"skeleton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stay","t":4,"rt":$n[1].AudioClip,"sn":"stay"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"triggerAnim","t":4,"rt":$n[0].String,"sn":"triggerAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"watchAd","t":4,"rt":$n[0].Boolean,"sn":"watchAd","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.HeartItem end.*/

    /*Projects.Scripts.GamePlay.Item.MagnetItem start.*/
    $m("Projects.Scripts.GamePlay.Item.MagnetItem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TriggerEnter","t":8,"pi":[{"n":"coll","pt":$n[1].Collider2D,"ps":0}],"sn":"TriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"adsIcon","t":4,"rt":$n[1].GameObject,"sn":"adsIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audio","t":4,"rt":$n[6].SimpleAudio,"sn":"audio"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"container","t":4,"rt":$n[1].GameObject,"sn":"container"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effect","t":4,"rt":$n[1].GameObject,"sn":"effect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].Transform,"sn":"icon"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"idleAnim","t":4,"rt":$n[0].String,"sn":"idleAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"move","t":4,"rt":$n[1].AudioClip,"sn":"move"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"skeleton","t":4,"rt":$n[11].SkeletonAnimation,"sn":"skeleton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stay","t":4,"rt":$n[1].AudioClip,"sn":"stay"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"triggerAnim","t":4,"rt":$n[0].String,"sn":"triggerAnim"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.MagnetItem end.*/

    /*Projects.Scripts.GamePlay.Item.Star start.*/
    $m("Projects.Scripts.GamePlay.Item.Star", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollect","t":8,"sn":"OnCollect","rt":$n[0].Void},{"a":2,"n":"OnCollide","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollide","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TriggerEnter","t":8,"pi":[{"n":"collider2D","pt":$n[1].Collider2D,"ps":0}],"sn":"TriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":2,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effect","t":4,"rt":$n[1].GameObject,"sn":"effect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].GameObject,"sn":"icon"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.Star end.*/

    /*Projects.Scripts.GamePlay.Item.TrySkinItem start.*/
    $m("Projects.Scripts.GamePlay.Item.TrySkinItem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Active","t":8,"sn":"Active","rt":$n[0].Void},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnValueChange","t":8,"sn":"OnValueChange","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TrySkin","t":8,"sn":"TrySkin","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_trySkinName","t":4,"rt":$n[0].String,"sn":"_trySkinName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"adsIcon","t":4,"rt":$n[1].GameObject,"sn":"adsIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audio","t":4,"rt":$n[6].SimpleAudio,"sn":"audio"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"container","t":4,"rt":$n[1].GameObject,"sn":"container"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effect","t":4,"rt":$n[1].GameObject,"sn":"effect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].Transform,"sn":"icon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"move","t":4,"rt":$n[1].AudioClip,"sn":"move"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"skin","t":4,"rt":$n[11].SkeletonAnimation,"sn":"skin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stay","t":4,"rt":$n[1].AudioClip,"sn":"stay"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Item.TrySkinItem end.*/

    /*Projects.Scripts.GamePlay.Enemy.EnemyController start.*/
    $m("Projects.Scripts.GamePlay.Enemy.EnemyController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CheckVisible","t":8,"sn":"CheckVisible","rt":$n[5].IEnumerator},{"v":true,"a":2,"n":"Die","t":8,"sn":"Die","rt":$n[0].Void},{"v":true,"a":2,"n":"Flip","t":8,"sn":"Flip","rt":$n[0].Void},{"v":true,"a":2,"n":"Idle","t":8,"sn":"Idle","rt":$n[0].Void},{"a":2,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"coll","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"v":true,"a":3,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"v":true,"a":2,"n":"ReachPlayer","t":8,"sn":"ReachPlayer","rt":$n[0].Void},{"a":3,"n":"SpawnStar","t":8,"sn":"SpawnStar","rt":$n[5].IEnumerator},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"anim","t":4,"rt":$n[11].SkeletonAnimation,"sn":"anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"attack","t":4,"rt":$n[1].GameObject,"sn":"attack"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"chasing","t":4,"rt":$n[0].String,"sn":"chasing"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"currentHp","t":4,"rt":$n[0].Int32,"sn":"currentHp","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"damageEffect","t":4,"rt":$n[1].ParticleSystem,"sn":"damageEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"delaySpawnStar","t":4,"rt":$n[0].Single,"sn":"delaySpawnStar","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"detectCamera","t":4,"rt":$n[1].SpriteRenderer,"sn":"detectCamera"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"die","t":4,"rt":$n[0].String,"sn":"die"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"dieEffect","t":4,"rt":$n[1].ParticleSystem,"sn":"dieEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"dieSfx","t":4,"rt":$n[1].AudioClip,"sn":"dieSfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"fixedMovement","t":4,"rt":$n[0].Boolean,"sn":"fixedMovement","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"forceSpawn","t":4,"rt":$n[0].Single,"sn":"forceSpawn","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"health","t":4,"rt":$n[1].GameObject,"sn":"health"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"icon","t":4,"rt":$n[1].GameObject,"sn":"icon"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"idle","t":4,"rt":$n[0].String,"sn":"idle"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"idleSfx","t":4,"rt":$n[1].AudioClip,"sn":"idleSfx"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"idle_fx","t":4,"rt":$n[0].String,"sn":"idle_fx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isFallDead","t":4,"rt":$n[0].Boolean,"sn":"isFallDead","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isStar","t":4,"rt":$n[0].Boolean,"sn":"isStar","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"maxHp","t":4,"rt":$n[0].Int32,"sn":"maxHp","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"move","t":4,"rt":$n[0].String,"sn":"move"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"movingSfx","t":4,"rt":$n[1].AudioClip,"sn":"movingSfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"spawnDir","t":4,"rt":$n[1].Vector2,"sn":"spawnDir"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"starPrefab","t":4,"rt":$n[1].GameObject,"sn":"starPrefab"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Enemy.EnemyController end.*/

    /*Projects.Scripts.GamePlay.Damage.DamageToBall start.*/
    $m("Projects.Scripts.GamePlay.Damage.DamageToBall", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"OnCollide","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollide","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"v":true,"a":2,"n":"TriggerEnter","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"TriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"damage","t":4,"rt":$n[0].Int32,"sn":"damage","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"damageType","t":4,"rt":$n[18].DamageType,"sn":"damageType","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.DamageType, System.Enum.toStringFn(Projects.Scripts.Models.DamageType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"firstTimeNoDamage","t":4,"rt":$n[0].Boolean,"sn":"firstTimeNoDamage","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Projects.Scripts.GamePlay.Damage.DamageToBall end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallAnimation start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Die","t":8,"pi":[{"n":"duration","pt":$n[0].Single,"ps":0},{"n":"complete","pt":Function,"ps":1}],"sn":"Die","rt":$n[5].IEnumerator,"p":[$n[0].Single,Function]},{"a":2,"n":"Init","t":8,"pi":[{"n":"controller","pt":$n[17].BallController,"ps":0}],"sn":"Init","rt":$n[0].Void,"p":[$n[17].BallController]},{"a":2,"n":"PlayDie","t":8,"pi":[{"n":"damageType","pt":$n[18].DamageType,"ps":0},{"n":"complete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"PlayDie","rt":$n[0].Void,"p":[$n[18].DamageType,Function]},{"a":2,"n":"PlayHurt","t":8,"sn":"PlayHurt","rt":$n[0].Void},{"a":2,"n":"PlayIdle","t":8,"sn":"PlayIdle","rt":$n[0].Void},{"a":2,"n":"PlayMix","t":8,"sn":"PlayMix","rt":$n[0].Void},{"a":2,"n":"PlayRevive","t":8,"sn":"PlayRevive","rt":$n[0].Void},{"a":2,"n":"PlaySmile","t":8,"sn":"PlaySmile","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skin","pt":$n[0].String,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[0].String]},{"a":1,"n":"_controller","t":4,"rt":$n[17].BallController,"sn":"_controller"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"die","t":4,"rt":$n[0].String,"sn":"die"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"drowning","t":4,"rt":$n[0].String,"sn":"drowning"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"getHurt","t":4,"rt":$n[0].String,"sn":"getHurt"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"idle","t":4,"rt":$n[0].String,"sn":"idle"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"mix","t":4,"rt":$n[0].Array.type(System.String),"sn":"mix"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"revive","t":4,"rt":$n[0].String,"sn":"revive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"skeleton","t":4,"rt":$n[11].SkeletonAnimation,"sn":"skeleton"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"smile","t":4,"rt":$n[0].String,"sn":"smile"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallAnimation end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallAttack start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallAttack", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AfterDamage","t":8,"sn":"AfterDamage","rt":$n[5].IEnumerator},{"a":2,"n":"Init","t":8,"pi":[{"n":"controller","pt":$n[17].BallController,"ps":0}],"sn":"Init","rt":$n[0].Void,"p":[$n[17].BallController]},{"a":2,"n":"OnAttackEnemy","t":8,"pi":[{"n":"coll","pt":$n[1].Collision2D,"ps":0}],"sn":"OnAttackEnemy","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"_controller","t":4,"rt":$n[17].BallController,"sn":"_controller"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"attackForce","t":4,"rt":$n[1].Vector2,"sn":"attackForce"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"attackLayer","t":4,"rt":$n[1].LayerMask,"sn":"attackLayer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pauseDuration","t":4,"rt":$n[0].Single,"sn":"pauseDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallAttack end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallController start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActiveHeartEffect","t":8,"sn":"ActiveHeartEffect","rt":$n[0].Void},{"a":2,"n":"ActiveMagnet","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"ActiveMagnet","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CancelAllMove","t":8,"sn":"CancelAllMove","rt":$n[0].Void},{"a":2,"n":"Collected","t":8,"sn":"Collected","rt":$n[0].Void},{"a":2,"n":"CollectingCoin","t":8,"sn":"CollectingCoin","rt":$n[0].Void},{"a":2,"n":"Damage","t":8,"pi":[{"n":"damageType","pt":$n[18].DamageType,"ps":0},{"n":"damage","pt":$n[0].Int32,"ps":1},{"n":"damageObj","pt":$n[1].Transform,"ps":2}],"sn":"Damage","rt":$n[0].Void,"p":[$n[18].DamageType,$n[0].Int32,$n[1].Transform]},{"a":2,"n":"IsDie","t":8,"sn":"IsDie","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Jump","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Jump","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"MoveLeft","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"MoveLeft","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"MoveRight","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"MoveRight","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Revive","t":8,"sn":"Revive","rt":$n[0].Void},{"a":2,"n":"SetCanDamage","t":8,"pi":[{"n":"value","pt":$n[0].Boolean,"ps":0}],"sn":"SetCanDamage","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetForce","t":8,"pi":[{"n":"force","pt":$n[1].Vector2,"ps":0},{"n":"special","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetForce","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Boolean]},{"a":2,"n":"SetForceInstant","t":8,"pi":[{"n":"force","pt":$n[1].Vector2,"ps":0}],"sn":"SetForceInstant","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TrySkin","t":8,"pi":[{"n":"skin","pt":$n[0].String,"ps":0}],"sn":"TrySkin","rt":$n[0].Void,"p":[$n[0].String]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Win","t":8,"pi":[{"n":"target","pt":$n[1].Transform,"ps":0}],"sn":"Win","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[17].BallController,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[17].BallController,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_holdJump","t":4,"rt":$n[0].Boolean,"sn":"_holdJump","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_instance","is":true,"t":4,"rt":$n[17].BallController,"sn":"_instance"},{"a":1,"n":"_touchDirection","t":4,"rt":$n[18].MoveDirection,"sn":"_touchDirection","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"animation","t":4,"rt":$n[17].BallAnimation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"attack","t":4,"rt":$n[17].BallAttack,"sn":"attack"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"attackTransform","t":4,"rt":$n[1].GameObject,"sn":"attackTransform"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"health","t":4,"rt":$n[17].BallHealth,"sn":"health"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"heartEffect","t":4,"rt":$n[1].GameObject,"sn":"heartEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"magnetic","t":4,"rt":$n[17].BallMagnetic,"sn":"magnetic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"movement","t":4,"rt":$n[17].BallMovement,"sn":"movement"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallController end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallHealth start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallHealth", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Damage","t":8,"pi":[{"n":"damageType","pt":$n[18].DamageType,"ps":0},{"n":"damage","pt":$n[0].Int32,"ps":1},{"n":"damageObj","pt":$n[1].Transform,"ps":2}],"sn":"Damage","rt":$n[0].Void,"p":[$n[18].DamageType,$n[0].Int32,$n[1].Transform]},{"a":1,"n":"Die","t":8,"pi":[{"n":"damageType","pt":$n[18].DamageType,"ps":0}],"sn":"Die","rt":$n[0].Void,"p":[$n[18].DamageType]},{"a":1,"n":"DieComplete","t":8,"sn":"DieComplete","rt":$n[5].IEnumerator},{"a":2,"n":"Init","t":8,"pi":[{"n":"controller","pt":$n[17].BallController,"ps":0}],"sn":"Init","rt":$n[0].Void,"p":[$n[17].BallController]},{"a":2,"n":"Revive","t":8,"sn":"Revive","rt":$n[0].Void},{"a":1,"n":"SetInviolable","t":8,"sn":"SetInviolable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"_controller","t":4,"rt":$n[17].BallController,"sn":"_controller"},{"a":1,"n":"_firstTimeDieWithType","t":4,"rt":$n[0].Boolean,"sn":"_firstTimeDieWithType","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_inviolable","t":4,"rt":$n[0].Boolean,"sn":"_inviolable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentHp","t":4,"rt":$n[0].Int32,"sn":"currentHp","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"damageEffect","t":4,"rt":$n[1].GameObject,"sn":"damageEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"damageForce","t":4,"rt":$n[1].Vector2,"sn":"damageForce"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"dieEffect","t":4,"rt":$n[1].GameObject,"sn":"dieEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].GameObject,"sn":"icon"},{"a":2,"n":"isDie","t":4,"rt":$n[0].Boolean,"sn":"isDie","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxHp","t":4,"rt":$n[0].Int32,"sn":"maxHp","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"waterForce","t":4,"rt":$n[1].Vector2,"sn":"waterForce"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallHealth end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallMagnetic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActiveMagnet","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"ActiveMagnet","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Collected","t":8,"sn":"Collected","rt":$n[0].Void},{"a":2,"n":"CollectingCoin","t":8,"sn":"CollectingCoin","rt":$n[0].Void},{"a":2,"n":"Init","t":8,"pi":[{"n":"controller","pt":$n[17].BallController,"ps":0}],"sn":"Init","rt":$n[0].Void,"p":[$n[17].BallController]},{"a":1,"n":"_coinCollectCount","t":4,"rt":$n[0].Int32,"sn":"_coinCollectCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_controller","t":4,"rt":$n[17].BallController,"sn":"_controller"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"magnetEffect","t":4,"rt":$n[1].GameObject,"sn":"magnetEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"magnetic","t":4,"rt":$n[1].GameObject,"sn":"magnetic"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallMagnetic end.*/

    /*Projects.Scripts.GamePlay.CharacterController.BallMovement start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.BallMovement", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CheckIsGrounded","t":8,"sn":"CheckIsGrounded","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Init","t":8,"pi":[{"n":"controller","pt":$n[17].BallController,"ps":0}],"sn":"Init","rt":$n[0].Void,"p":[$n[17].BallController]},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnCollisionExit2D","t":8,"pi":[{"n":"other","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionExit2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"RollEffect","t":8,"sn":"RollEffect","rt":$n[0].Void},{"a":1,"n":"RunEffect","t":8,"sn":"RunEffect","rt":$n[0].Void},{"a":2,"n":"SetForce","t":8,"pi":[{"n":"force","pt":$n[1].Vector2,"ps":0},{"n":"special","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetForce","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Boolean]},{"a":2,"n":"SetForceInstant","t":8,"pi":[{"n":"force","pt":$n[1].Vector2,"ps":0}],"sn":"SetForceInstant","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":2,"n":"TouchJump","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"TouchJump","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"TouchMoveLeft","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"TouchMoveLeft","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"TouchMoveRight","t":8,"pi":[{"n":"release","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"TouchMoveRight","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"JumpCoyoteTime","t":4,"rt":$n[0].Single,"sn":"JumpCoyoteTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_collisionWithWall","t":4,"rt":$n[0].Boolean,"sn":"_collisionWithWall","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_controller","t":4,"rt":$n[17].BallController,"sn":"_controller"},{"a":1,"n":"_moveEffectSpawnRunning","t":4,"rt":$n[0].Boolean,"sn":"_moveEffectSpawnRunning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_roll","t":4,"rt":$n[18].MoveDirection,"sn":"_roll","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"acceleration","t":4,"rt":$n[0].Single,"sn":"acceleration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ballRadius","t":4,"rt":$n[0].Single,"sn":"ballRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boxLayer","t":4,"rt":$n[1].LayerMask,"sn":"boxLayer"},{"a":1,"n":"countDeccelTime","t":4,"rt":$n[0].Single,"sn":"countDeccelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"deccelTime","t":4,"rt":$n[0].Single,"sn":"deccelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"decceleration","t":4,"rt":$n[0].Single,"sn":"decceleration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"effectByForce","t":4,"rt":$n[0].Boolean,"sn":"effectByForce","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"effectByForceCountTime","t":4,"rt":$n[0].Single,"sn":"effectByForceCountTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"effectByForceTime","t":4,"rt":$n[0].Single,"sn":"effectByForceTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fallGravityMultiple","t":4,"rt":$n[0].Single,"sn":"fallGravityMultiple","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"forcePushBox","t":4,"rt":$n[0].Single,"sn":"forcePushBox","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gravityScale","t":4,"rt":$n[0].Single,"sn":"gravityScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"groundCheckPoint","t":4,"rt":$n[1].Transform,"sn":"groundCheckPoint"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"groundLayer","t":4,"rt":$n[1].LayerMask,"sn":"groundLayer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"icon","t":4,"rt":$n[1].Transform,"sn":"icon"},{"a":1,"n":"isGround","t":4,"rt":$n[0].Boolean,"sn":"isGround","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isJumpButtonRelease","t":4,"rt":$n[0].Boolean,"sn":"isJumpButtonRelease","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isJumping","t":4,"rt":$n[0].Boolean,"sn":"isJumping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"jumpBufferTime","t":4,"rt":$n[0].Single,"sn":"jumpBufferTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"jumpCutMultiple","t":4,"rt":$n[0].Single,"sn":"jumpCutMultiple","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"jumpForce","t":4,"rt":$n[0].Single,"sn":"jumpForce","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"landingEffect","t":4,"rt":$n[1].GameObject,"sn":"landingEffect"},{"a":1,"n":"lastGroundedTime","t":4,"rt":$n[0].Single,"sn":"lastGroundedTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastJumpTime","t":4,"rt":$n[0].Single,"sn":"lastJumpTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"moveDirection","t":4,"rt":$n[18].MoveDirection,"sn":"moveDirection","box":function ($v) { return Bridge.box($v, Projects.Scripts.Models.MoveDirection, System.Enum.toStringFn(Projects.Scripts.Models.MoveDirection));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveEffect","t":4,"rt":$n[1].GameObject,"sn":"moveEffect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveSpeed","t":4,"rt":$n[0].Single,"sn":"moveSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rigidbody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidbody2D"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"totalDisplay","t":4,"rt":$n[1].Transform,"sn":"totalDisplay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"wallLayer","t":4,"rt":$n[1].LayerMask,"sn":"wallLayer"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.BallMovement end.*/

    /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter start.*/
    $m("Projects.Scripts.GamePlay.CharacterController.FollowCharacter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"followTransform","t":4,"rt":$n[1].Transform,"sn":"followTransform"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offset","t":4,"rt":$n[1].Vector2,"sn":"offset"}]}; }, $n);
    /*Projects.Scripts.GamePlay.CharacterController.FollowCharacter end.*/

    /*Projects.Scripts.GamePlay.Building.CheckPoint start.*/
    $m("Projects.Scripts.GamePlay.Building.CheckPoint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":2,"n":"ShowEffect","t":8,"sn":"ShowEffect","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animation","t":4,"rt":$n[11].SkeletonAnimation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collider","t":4,"rt":$n[1].Collider2D,"sn":"collider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSound","t":4,"rt":$n[0].Boolean,"sn":"playSound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"reviveEffect","t":4,"rt":$n[1].GameObject,"sn":"reviveEffect"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Building.CheckPoint end.*/

    /*Projects.Scripts.GamePlay.Building.StartLevel start.*/
    $m("Projects.Scripts.GamePlay.Building.StartLevel", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Init","t":8,"pi":[{"n":"level","pt":$n[0].String,"ps":0}],"sn":"Init","rt":$n[15].CheckPoint,"p":[$n[0].String]},{"a":2,"n":"Instance","is":true,"t":16,"rt":$n[15].StartLevel,"g":{"a":2,"n":"get_Instance","t":8,"rt":$n[15].StartLevel,"fg":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_instance","is":true,"t":4,"rt":$n[15].StartLevel,"sn":"_instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"checkPoint","t":4,"rt":$n[15].CheckPoint,"sn":"checkPoint"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelText","t":4,"rt":$n[14].TextMeshProUGUI,"sn":"levelText"}]}; }, $n);
    /*Projects.Scripts.GamePlay.Building.StartLevel end.*/

    /*EpicToonFX.ETFXButtonScript start.*/
    $m("EpicToonFX.ETFXButtonScript", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"getProjectileNames","t":8,"sn":"getProjectileNames","rt":$n[0].Void},{"a":2,"n":"overButton","t":8,"sn":"overButton","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Button","t":4,"rt":$n[1].GameObject,"sn":"Button"},{"a":1,"n":"MyButtonText","t":4,"rt":$n[4].Text,"sn":"MyButtonText"},{"a":2,"n":"buttonsDistance","t":4,"rt":$n[0].Single,"sn":"buttonsDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"buttonsSizeX","t":4,"rt":$n[0].Single,"sn":"buttonsSizeX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"buttonsSizeY","t":4,"rt":$n[0].Single,"sn":"buttonsSizeY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"buttonsX","t":4,"rt":$n[0].Single,"sn":"buttonsX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"buttonsY","t":4,"rt":$n[0].Single,"sn":"buttonsY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"effectScript","t":4,"rt":$n[21].ETFXFireProjectile,"sn":"effectScript"},{"a":1,"n":"projectileParticleName","t":4,"rt":$n[0].String,"sn":"projectileParticleName"},{"a":1,"n":"projectileScript","t":4,"rt":ETFXProjectileScript,"sn":"projectileScript"}]}; }, $n);
    /*EpicToonFX.ETFXButtonScript end.*/

    /*EpicToonFX.ETFXFireProjectile start.*/
    $m("EpicToonFX.ETFXFireProjectile", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustSpeed","t":8,"pi":[{"n":"newSpeed","pt":$n[0].Single,"ps":0}],"sn":"AdjustSpeed","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"nextEffect","t":8,"sn":"nextEffect","rt":$n[0].Void},{"a":2,"n":"previousEffect","t":8,"sn":"previousEffect","rt":$n[0].Void},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"currentProjectile","t":4,"rt":$n[0].Int32,"sn":"currentProjectile","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"hit","t":4,"rt":$n[1].RaycastHit,"sn":"hit"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"projectiles","t":4,"rt":System.Array.type(UnityEngine.GameObject),"sn":"projectiles"},{"a":1,"n":"selectedProjectileButton","t":4,"rt":$n[21].ETFXButtonScript,"sn":"selectedProjectileButton"},{"at":[new UnityEngine.HeaderAttribute("Missile spawns at attached game object")],"a":2,"n":"spawnPosition","t":4,"rt":$n[1].Transform,"sn":"spawnPosition"},{"a":2,"n":"speed","t":4,"rt":$n[0].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*EpicToonFX.ETFXFireProjectile end.*/

    /*EpicToonFX.ETFXLoopScript start.*/
    $m("EpicToonFX.ETFXLoopScript", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"EffectLoop","t":8,"sn":"EffectLoop","rt":$n[5].IEnumerator},{"a":2,"n":"PlayEffect","t":8,"sn":"PlayEffect","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"chosenEffect","t":4,"rt":$n[1].GameObject,"sn":"chosenEffect"},{"a":2,"n":"loopTimeLimit","t":4,"rt":$n[0].Single,"sn":"loopTimeLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Spawn without")],"a":2,"n":"spawnWithoutLight","t":4,"rt":$n[0].Boolean,"sn":"spawnWithoutLight","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"spawnWithoutSound","t":4,"rt":$n[0].Boolean,"sn":"spawnWithoutSound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*EpicToonFX.ETFXLoopScript end.*/

    /*EpicToonFX.ETFXMouseOrbit start.*/
    $m("EpicToonFX.ETFXMouseOrbit", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampAngle","is":true,"t":8,"pi":[{"n":"angle","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"ClampAngle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"distance","t":4,"rt":$n[0].Single,"sn":"distance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"distanceMax","t":4,"rt":$n[0].Single,"sn":"distanceMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"distanceMin","t":4,"rt":$n[0].Single,"sn":"distanceMin","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rotationXAxis","t":4,"rt":$n[0].Single,"sn":"rotationXAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rotationYAxis","t":4,"rt":$n[0].Single,"sn":"rotationYAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"smoothTime","t":4,"rt":$n[0].Single,"sn":"smoothTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"target","t":4,"rt":$n[1].Transform,"sn":"target"},{"a":1,"n":"velocityX","t":4,"rt":$n[0].Single,"sn":"velocityX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"velocityY","t":4,"rt":$n[0].Single,"sn":"velocityY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"xSpeed","t":4,"rt":$n[0].Single,"sn":"xSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yMaxLimit","t":4,"rt":$n[0].Single,"sn":"yMaxLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yMinLimit","t":4,"rt":$n[0].Single,"sn":"yMinLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ySpeed","t":4,"rt":$n[0].Single,"sn":"ySpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*EpicToonFX.ETFXMouseOrbit end.*/

    /*EpicToonFX.ETFXTarget start.*/
    $m("EpicToonFX.ETFXTarget", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter","t":8,"pi":[{"n":"col","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":1,"n":"Respawn","t":8,"sn":"Respawn","rt":$n[5].IEnumerator},{"a":1,"n":"SpawnTarget","t":8,"sn":"SpawnTarget","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.HeaderAttribute("Effect shown on target hit")],"a":2,"n":"hitParticle","t":4,"rt":$n[1].GameObject,"sn":"hitParticle"},{"at":[new UnityEngine.HeaderAttribute("Effect shown on target respawn")],"a":2,"n":"respawnParticle","t":4,"rt":$n[1].GameObject,"sn":"respawnParticle"},{"a":1,"n":"targetCollider","t":4,"rt":$n[1].Collider,"sn":"targetCollider"},{"a":1,"n":"targetRenderer","t":4,"rt":$n[1].Renderer,"sn":"targetRenderer"}]}; }, $n);
    /*EpicToonFX.ETFXTarget end.*/

    /*EpicToonFX.ETFXLightFade start.*/
    $m("EpicToonFX.ETFXLightFade", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"initIntensity","t":4,"rt":$n[0].Single,"sn":"initIntensity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"killAfterLife","t":4,"rt":$n[0].Boolean,"sn":"killAfterLife","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"li","t":4,"rt":$n[1].Light,"sn":"li"},{"at":[new UnityEngine.HeaderAttribute("Seconds to dim the light")],"a":2,"n":"life","t":4,"rt":$n[0].Single,"sn":"life","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*EpicToonFX.ETFXLightFade end.*/

    /*EpicToonFX.ETFXPitchRandomizer start.*/
    $m("EpicToonFX.ETFXPitchRandomizer", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"randomPercent","t":4,"rt":$n[0].Single,"sn":"randomPercent","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*EpicToonFX.ETFXPitchRandomizer end.*/

    /*EpicToonFX.ETFXRotation start.*/
    $m("EpicToonFX.ETFXRotation", function () { return {"nested":[$n[21].ETFXRotation.spaceEnum],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"rotateSpace","t":4,"rt":$n[21].ETFXRotation.spaceEnum,"sn":"rotateSpace","box":function ($v) { return Bridge.box($v, EpicToonFX.ETFXRotation.spaceEnum, System.Enum.toStringFn(EpicToonFX.ETFXRotation.spaceEnum));}},{"at":[new UnityEngine.HeaderAttribute("Rotate axises by degrees per second")],"a":2,"n":"rotateVector","t":4,"rt":$n[1].Vector3,"sn":"rotateVector"}]}; }, $n);
    /*EpicToonFX.ETFXRotation end.*/

    /*EpicToonFX.ETFXRotation+spaceEnum start.*/
    $m("EpicToonFX.ETFXRotation.spaceEnum", function () { return {"td":$n[21].ETFXRotation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[21].ETFXRotation.spaceEnum,"sn":"Local","box":function ($v) { return Bridge.box($v, EpicToonFX.ETFXRotation.spaceEnum, System.Enum.toStringFn(EpicToonFX.ETFXRotation.spaceEnum));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[21].ETFXRotation.spaceEnum,"sn":"World","box":function ($v) { return Bridge.box($v, EpicToonFX.ETFXRotation.spaceEnum, System.Enum.toStringFn(EpicToonFX.ETFXRotation.spaceEnum));}}]}; }, $n);
    /*EpicToonFX.ETFXRotation+spaceEnum end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[22].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[22].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[22].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[22].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[22].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[22].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[24].Sequence,"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[25].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[25].Path,$n[0].Single,$n[24].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[24].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[24].PathType,$n[24].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"towards","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[24].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[23].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[24].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[25].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[25].Path,$n[0].Single,$n[24].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[24].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[24].PathType,$n[24].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[24].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[23].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[24].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[24].Sequence,"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[24].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[24].PathType,$n[24].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[24].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[24].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[24].PathType,$n[24].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[24].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[24].Sequence,"p":[$n[1].SpriteRenderer,$n[1].Gradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[24].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[24].Tweener,"p":[$n[4].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[24].Tweener,"p":[$n[4].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[24].Tweener,"p":[$n[4].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Outline,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[26].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[23].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[4].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[26].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[23].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[24].Sequence,"p":[$n[4].Image,$n[1].Gradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[24].Tweener,"p":[$n[4].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[24].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[24].Tweener,"p":[$n[4].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[24].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Outline,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos","rt":$n[24].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos$1","rt":$n[24].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[24].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[23].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[4].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[24].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[23].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[24].Tweener,"p":[$n[4].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[24].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[24].Sequence,"p":[$n[1].Material,$n[1].Gradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":$n[1].Gradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[24].Sequence,"p":[$n[1].Material,$n[1].Gradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[23].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[24].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[24].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[24].DOTweenCYInstruction.WaitForCompletion,$n[24].DOTweenCYInstruction.WaitForRewind,$n[24].DOTweenCYInstruction.WaitForKill,$n[24].DOTweenCYInstruction.WaitForElapsedLoops,$n[24].DOTweenCYInstruction.WaitForPosition,$n[24].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[24].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[24].Tween],"pi":[{"n":"tween","pt":$n[24].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[24].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[24].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[24].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[25].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[24].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[23].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[25].Path,$n[0].Single,$n[24].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[27].PathOptions,"ps":0},{"n":"t","pt":$n[24].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[27].PathOptions,$n[24].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

});
